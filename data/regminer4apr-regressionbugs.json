[
    {
        "bugId": "RegressionBug-1",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.adobe.epubcheck.api.Epub30CheckExpandedTest",
                "error": "java.lang.AssertionError",
                "message": "The error results do not match expected:<[]> but was:<[MessageId.CSS_020]>",
                "methodName": "testIssue922"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 6,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 6
        },
        "program": "RegressionBug-1",
        "project": "RegressionBug-1",
        "repairOperators": [
            "condBranIfAdd",
            "condBranCaseAdd",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java\n@@ -582,6 +582,14 @@\n               // report absolute font-size as ACC USAGE message\n               getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n               break;\n+            case INTEGER:\n+              if (!quantity.toCssString().equals(\"0\"))\n+              {\n+                getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n+              }\n+              break;\n             default:\n               // report unsupported font-size as ERROR message\n               getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java\n@@ -559,11 +567,17 @@\n           switch (quantity.getUnit())\n           {\n             case EMS:\n+            case EXS:\n             case REMS:\n             case PERCENTAGE:\n               break;\n+            case LENGTH:\n+              getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n+              break;\n             default:\n-              getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()));\n+              getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n               break;\n           }\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/adobe/epubcheck/messages/MessageDictionary.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/adobe/epubcheck/messages/MessageDictionary.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/adobe/epubcheck/messages/MessageDictionary.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/adobe/epubcheck/messages/MessageDictionary.java\n@@ -112,7 +112,7 @@\n       map.put(MessageId.CSS_016, Severity.SUPPRESSED);\n       map.put(MessageId.CSS_017, Severity.WARNING);\n       map.put(MessageId.CSS_019, Severity.WARNING);\n-      map.put(MessageId.CSS_020, Severity.USAGE);\n+      map.put(MessageId.CSS_020, Severity.ERROR);\n       map.put(MessageId.CSS_021, Severity.USAGE);\n       map.put(MessageId.CSS_022, Severity.USAGE);\n       map.put(MessageId.CSS_023, Severity.USAGE);",
        "bugType": "Unmask"
    },
    {
        "bugId": "RegressionBug-2",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "net.lingala.zip4j.io.inputstream.ZipInputStreamIT",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[6]> but was:<[1]>",
                "methodName": "testReadingZipBySkippingDataCreatedWithJDKZipReadsAllEntries"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-2",
        "project": "RegressionBug-2",
        "repairOperators": [
            "condExpExpand",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java\n@@ -303,7 +302,10 @@\n     }\n     \n     private void readUntilEndOfEntry() throws IOException {\n-    if (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0) {\n+    if (!localFileHeader.isDataDescriptorExists() && (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0)) {\n       return;\n     }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java\n@@ -300,9 +310,14 @@\n+    if (localFileHeader.getCompressedSize() == 0) {\n+      return;\n+    }\n     if (endOfEntryBuffer == null) {\n       endOfEntryBuffer = new byte[512];\n     }\n     while (read(endOfEntryBuffer) != -1);\n   }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-3",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.logicng.transformations.FormulaFactoryImporterTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[0]> but was:<[2]>",
                "methodName": "testImplication"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 0,
            "linesRem": 2,
            "methods": 1,
            "sizeInLines": 0
        },
        "program": "RegressionBug-3",
        "project": "RegressionBug-3",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/logicng/formulas/FormulaFactory.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/logicng/formulas/FormulaFactory.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/logicng/formulas/FormulaFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/logicng/formulas/FormulaFactory.java\n@@ -278,8 +276,6 @@ public Formula implication(final Formula left, final Formula right) {\n       return this.not(left);\n     if (left.equals(right))\n       return this.verum();\n-    if (left.negate().equals(right))\n-      return left.negate();\n     final Pair<Formula, Formula> key = new Pair<>(left, right);\n     Implication implication = this.implications.get(key);\n     if (implication == null) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/formulas/FormulaFactory.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/formulas/FormulaFactory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/formulas/FormulaFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/formulas/FormulaFactory.java\n@@ -276,6 +278,8 @@ public Formula implication(final Formula left, final Formula right) {\n       return this.not(left);\n     if (left.equals(right))\n       return this.verum();\n+    if (left.negate().equals(right))\n+      return left.negate();\n     final Pair<Formula, Formula> key = new Pair<>(left, right);\n     Implication implication = this.implications.get(key);\n     if (implication == null) {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-4",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.logicng.explanations.smus.SmusComputationTest",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Cannot compute a smallest MUS for a satisfiable formula set.",
                "methodName": "testSatisfiable"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 3,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-4",
        "project": "RegressionBug-4",
        "repairOperators": [
            "condExpExpand",
            "condBranRem",
            "exThrowsRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/logicng/explanations/smus/SmusComputation.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/logicng/explanations/smus/SmusComputation.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/logicng/explanations/smus/SmusComputation.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/logicng/explanations/smus/SmusComputation.java\n@@ -110,16 +110,13 @@\n             growSolver.add(f.equivalence(selector, proposition.formula()));\n         }\n         final boolean sat = growSolver.sat(satHandler(handler), propositionMapping.keySet()) == Tristate.TRUE;\n-        if (aborted(handler)) {\n+        if (sat || aborted(handler)) {\n             return null;\n         }\n-        if (sat) {\n-            throw new IllegalArgumentException(\"Cannot compute a smallest MUS for a satisfiable formula set.\");\n-        }\n         final SATSolver hSolver = MiniSat.miniSat(f);\n         while (true) {\n             final SortedSet<Variable> h = minimumHs(hSolver, propositionMapping.keySet(), handler);\n-            if (aborted(handler)) {\n+            if (h == null || aborted(handler)) {\n                 return null;\n             }\n             final SortedSet<Variable> c = grow(growSolver, h, propositionMapping.keySet(), handler);",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/explanations/smus/SmusComputation.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/explanations/smus/SmusComputation.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/explanations/smus/SmusComputation.java\t2024-09-08 01:36:07.773764185 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/explanations/smus/SmusComputation.java\t2024-09-08 01:36:07.689763596 +1000\n@@ -71,13 +76,31 @@\n      * @param handler               the handler, can be {@code null}\n      * @return the SMUS or {@code null} if the given propositions are satisfiable\n      */\n+    public static <P extends Proposition> List<P> computeSmus(final List<P> propositions, final List<Formula> additionalConstraints, final FormulaFactory f,\n+                                                              final OptimizationHandler handler) {\n+        start(handler);\n         final SATSolver growSolver = MiniSat.miniSat(f);\n         growSolver.add(additionalConstraints == null ? Collections.singletonList(f.verum()) : additionalConstraints);\n         final Map<Variable, P> propositionMapping = new TreeMap<>();\n@@ -86,13 +109,23 @@\n             propositionMapping.put(selector, proposition);\n             growSolver.add(f.equivalence(selector, proposition.formula()));\n         }\n-        if (growSolver.sat(propositionMapping.keySet()) == Tristate.TRUE) {\n-            return null; // no MUS, since propositions are SAT\n+        final boolean sat = growSolver.sat(satHandler(handler), propositionMapping.keySet()) == Tristate.TRUE;\n+        if (aborted(handler)) {\n+            return null;\n+        }\n+        if (sat) {\n+            throw new IllegalArgumentException(\"Cannot compute a smallest MUS for a satisfiable formula set.\");\n         }\n         final SATSolver hSolver = MiniSat.miniSat(f);\n         while (true) {\n-            final SortedSet<Variable> h = minimumHs(hSolver, propositionMapping.keySet());\n-            final SortedSet<Variable> c = grow(growSolver, h, propositionMapping.keySet());\n+            final SortedSet<Variable> h = minimumHs(hSolver, propositionMapping.keySet(), handler);\n+            if (aborted(handler)) {\n+                return null;\n+            }\n+            final SortedSet<Variable> c = grow(growSolver, h, propositionMapping.keySet(), handler);\n+            if (aborted(handler)) {\n+                return null;\n+            }\n             if (c == null) {\n                 return h.stream().map(propositionMapping::get).collect(Collectors.toList());\n             }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/handlers/Handler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/handlers/Handler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/handlers/Handler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/handlers/Handler.java\n@@ -41,10 +41,33 @@\n      * Returns whether the computation was aborted by the handler.\n      * @return {@code true} if the computation was aborted by the handler, otherwise {@code false}\n      */\n-    boolean aborted();\n+    default boolean aborted() {\n+        return false;\n+    }\n \n     /**\n      * This method is called when the computation starts.\n      */\n-    void started();\n+    default void started() {\n+    }\n\n     /**\n      * Returns {@code true} if the handler is not {@code null} and is already aborted.\n      * @param handler the handler to check\n      * @return {@code true} if the handler is not {@code null} and is already aborted, otherwise {@code false}\n      */\n+    static boolean aborted(final Handler handler) {\n+        return handler != null && handler.aborted();\n+    }\n\n     /**\n      * Null-safe helper method to start a handler.\n      * @param handler the handler to start, may be {@code null}\n      */\n+    static void start(final Handler handler) {\n+        if (handler != null) {\n+            handler.started();\n+        }\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/handlers/OptimizationHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/handlers/OptimizationHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/handlers/OptimizationHandler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/handlers/OptimizationHandler.java\n@@ -54,19 +54,33 @@\n      * @param handler the optimization handler\n      * @return The SAT handler if the optimization handler is not {@code null}, otherwise {@code null}\n      */\n+    static SATHandler satHandler(final OptimizationHandler handler) {\n+        return handler == null ? null : handler.satHandler();\n+    }\n+}\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/handlers/SATHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/handlers/SATHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/handlers/SATHandler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/handlers/SATHandler.java\n@@ -54,19 +54,33 @@\n      * Null-safe helper method to call {@link SATHandler#finishedSolving} on a handler.\n      * @param handler the handler to finished, may be {@code null}\n      */\n+    static void finishSolving(final SATHandler handler) {\n+        if (handler != null) {\n+            handler.finishedSolving();\n+        }\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/solvers/sat/MiniSat2Solver.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/solvers/sat/MiniSat2Solver.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/logicng/solvers/sat/MiniSat2Solver.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/logicng/solvers/sat/MiniSat2Solver.java\n@@ -194,9 +197,7 @@\n     @Override\n     public Tristate solve(final SATHandler handler) {\n         this.handler = handler;\n-        if (this.handler != null) {\n-            this.handler.started();\n-        }\n+        start(handler);\n         this.model.clear();\n         this.conflict.clear();\n         if (!this.ok) {\n@@ -227,9 +228,7 @@\n         } else if (status == Tristate.FALSE && this.conflict.empty()) {\n             this.ok = false;\n         }\n-        if (this.handler != null) {\n-            this.handler.finishedSolving();\n-        }\n+        finishSolving(handler);\n         cancelUntil(0);\n         this.handler = null;\n         this.canceledByHandler = false;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-5",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "hudson.tasks.junit.CaseResultTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : is <SUCCESS>\n     but: was <FAILURE>",
                "methodName": "emptyName"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-5",
        "project": "RegressionBug-5",
        "repairOperators": [
            "mcParAdd",
            "condExpExpand"
        ],
        "repairTools": [
            "rtCodeGen2B",
            "rtIncoder1B",
            "rtIncoder6B",
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/hudson/tasks/junit/CaseResult.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/hudson/tasks/junit/CaseResult.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/hudson/tasks/junit/CaseResult.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/hudson/tasks/junit/CaseResult.java\n@@ -320,9 +320,9 @@\n      */\n     @Exported(visibility=999)\n     public @Override String getName() {\n-    \tif (testName.isEmpty()) {\n+       if (StringUtils.isEmpty(testName)) {\n            return \"(?)\";\n        }\n         return testName;\n     }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/hudson/tasks/junit/CaseResult.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/hudson/tasks/junit/CaseResult.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/hudson/tasks/junit/CaseResult.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/hudson/tasks/junit/CaseResult.java\n@@ -270,7 +270,7 @@\n     public String getTransformedTestName() {\n-        return TestNameTransformer.getTransformedName(testName);\n+        return TestNameTransformer.getTransformedName(getName());\n     }\n \n     public String getDisplayName() {\n@@ -300,6 +300,9 @@\n      */\n     @Exported(visibility=999)\n     public @Override String getName() {\n+    \tif (testName.isEmpty()) {\n+    \t\treturn \"(?)\";\n+    \t}\n         return testName;\n     }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-6",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.ice4j.stack.ShallowStackTest",
                "error": "junit.framework.AssertionFailedError",
                "message": "",
                "methodName": "testRetransmissionOriginalWait"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-6",
        "project": "RegressionBug-6",
        "repairOperators": [
            "objInstRem",
            "objInstAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/ice4j/stack/StunClientTransaction.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/ice4j/stack/StunClientTransaction.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/ice4j/stack/StunClientTransaction.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/ice4j/stack/StunClientTransaction.java\n@@ -150,7 +150,7 @@\n     /**\n      * A transaction request retransmitter\n      */\n-    private final Retransmitter retransmitter = new Retransmitter();\n+    private final Retransmitter retransmitter;\n \n     /**\n      * Creates a client transaction.\n@@ -206,6 +206,8 @@\n \n         initTransactionConfiguration();\n \n+        retransmitter = new Retransmitter();\n\n         this.transactionID = transactionID;\n \n         try",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/ice4j/stack/StunClientTransaction.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/ice4j/stack/StunClientTransaction.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/ice4j/stack/StunClientTransaction.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/ice4j/stack/StunClientTransaction.java\n@@ -46,13 +47,12 @@\n  * @author Lyubomir Marinov\n  */\n public class StunClientTransaction\n-    implements Runnable\n {\n     /**\n      * Our class logger.\n      */\n@@ -77,40 +77,20 @@\n      * The pool of <tt>Thread</tt>s which retransmit\n      * <tt>StunClientTransaction</tt>s.\n      */\n-    private static final ExecutorService retransmissionThreadPool\n-        = Executors.newCachedThreadPool(\n-                new ThreadFactory()\n-                {\n-                    private final ThreadFactory defaultThreadFactory\n-                        = Executors.defaultThreadFactory();\n-\n-                    @Override\n-                    public Thread newThread(Runnable r)\n-                    {\n-                        Thread t = defaultThreadFactory.newThread(r);\n-\n-                        if (t != null)\n-                        {\n-                            t.setDaemon(true);\n-                            String name = t.getName();\n-\n-                            if (name == null)\n-                                name = \"\";\n-                            t.setName(\"StunClientTransaction-\" + name);\n-                        }\n-                        return t;\n-                    }\n-                });\n+    private static final ScheduledExecutorService retransmissionThreadPool;\n+\n+    static {\n+        CustomizableThreadFactory threadFactory\n+            = new CustomizableThreadFactory(\"ice4j.StunClientTransaction-\", true);\n+\n+        final ScheduledThreadPoolExecutor terminationExecutor\n+            = new ScheduledThreadPoolExecutor(0, threadFactory);\n+        terminationExecutor.setKeepAliveTime(60, TimeUnit.SECONDS);\n+        terminationExecutor.setRemoveOnCancelPolicy(true);\n+        retransmissionThreadPool\n+            = Executors.unconfigurableScheduledExecutorService(\n+            terminationExecutor);\n+    }\n \n     /**\n      * Maximum number of retransmissions. Once this number is reached and if no\n@@ -166,25 +146,12 @@\n     /**\n      * Determines whether the transaction is active or not.\n      */\n-    private boolean cancelled = false;\n\n-    private final Lock lock = new ReentrantLock();\n+    private final AtomicBoolean cancelled = new AtomicBoolean(false);\n \n-    private final Condition lockCondition = lock.newCondition();\n+    private final Retransmitter retransmitter = new Retransmitter();\n \n     /**\n      * Creates a client transaction.\n@@ -257,102 +224,6 @@\n     }\n \n-    @Override\n-    public void run()\n-    {\n-        lock.lock();\n-        try\n-        {\n-            runLocked();\n-        }\n-        finally\n-        {\n-            lock.unlock();\n-        }\n-    }\n\n-    private void runLocked()\n-    {\n-        int retransmissionCounter = 0;\n-        int nextWaitInterval = originalWaitInterval;\n\n-        for (retransmissionCounter = 0;\n-             retransmissionCounter < maxRetransmissions;\n-             retransmissionCounter ++)\n-        {\n-            waitFor(nextWaitInterval);\n\n-            if(cancelled)\n-                return;\n\n-            int curWaitInterval = nextWaitInterval;\n-            if(nextWaitInterval < maxWaitInterval)\n-                nextWaitInterval *= 2;\n\n-            try\n-            {\n-                logger.fine(\n-                        \"retrying STUN tid \" + transactionID + \" from \"\n-                            + localAddress + \" to \" + requestDestination\n-                            + \" waited \" + curWaitInterval + \" ms retrans \"\n-                            + (retransmissionCounter + 1) + \" of \"\n-                            + maxRetransmissions);\n-                sendRequest0();\n-            }\n-            catch (Exception ex)\n-            {\n-                logger.log(\n-                        Level.INFO,\n-                        \"A client tran retransmission failed\",\n-                        ex);\n-            }\n-        }\n\n-        if(nextWaitInterval < maxWaitInterval)\n-            nextWaitInterval *= 2;\n\n-        waitFor(nextWaitInterval);\n-\n-        if(cancelled)\n-            return;\n\n-        stackCallback.removeClientTransaction(this);\n-        responseCollector.processTimeout(\n-                new StunTimeoutEvent(\n-                        stackCallback,\n-                        this.request, getLocalAddress(), transactionID));\n-    }\n\n      * Sends the request and schedules the first retransmission for after\n      * {@link #originalWaitInterval} and thus starts the retransmission\n      * algorithm.\n@@ -371,7 +242,7 @@\n                     + localAddress + \" to \" + requestDestination);\n         sendRequest0();\n \n-        retransmissionThreadPool.execute(this);\n+        this.retransmitter.schedule();\n     }\n \n     /**\n@@ -385,7 +256,7 @@\n     private void sendRequest0()\n         throws IllegalArgumentException, IOException\n     {\n-        if(cancelled)\n+        if (cancelled.get())\n         {\n             logger.finer(\"Trying to resend a cancelled transaction.\");\n         }\n@@ -409,73 +280,17 @@\n      *\n      * @param millis the number of milliseconds to wait for.\n      */\n-    void waitFor(long millis)\n-    {\n-        lock.lock();\n-        try\n-        {\n-            lockCondition.await(millis, TimeUnit.MILLISECONDS);\n-        }\n-        catch (InterruptedException ex)\n-        {\n-            throw new RuntimeException(ex);\n-        }\n-        finally\n-        {\n-            lock.unlock();\n-        }\n-    }\n\n-    void cancel(boolean waitForResponse)\n+    void cancel()\n     {\n-        cancelled = true;\n-\n-        if(!waitForResponse)\n-        {\n-            if (lock.tryLock())\n-            {\n-                try\n-                {\n-                    lockCondition.signal();\n-                }\n-                finally\n-                {\n-                    lock.unlock();\n-                }\n-            }\n-        }\n-    }\n\n+        cancelled.set(true);\n \n\n-    void cancel()\n-    {\n-        cancel(false);\n+        this.retransmitter.cancel();\n     }\n \n     /**\n@@ -486,27 +301,21 @@\n      */\n     public void handleResponse(StunMessageEvent evt)\n     {\n-        lock.lock();\n-        try\n-        {\n-            TransactionID transactionID = getTransactionID();\n+        TransactionID transactionID = getTransactionID();\n \n-            logger.log(Level.FINE, \"handleResponse tid \" + transactionID);\n-            if(!Boolean.getBoolean(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE))\n-                cancel();\n-\n-            responseCollector.processResponse(\n-                    new StunResponseEvent(\n-                            stackCallback,\n-                            evt.getRawMessage(),\n-                            (Response) evt.getMessage(),\n-                            request,\n-                            transactionID));\n-        }\n-        finally\n+        logger.fine(\"handleResponse tid \" + transactionID);\n+        if(!Boolean.getBoolean(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE))\n         {\n-            lock.unlock();\n+            cancel();\n         }\n+\n+        responseCollector.processResponse(\n+            new StunResponseEvent(\n+                stackCallback,\n+                evt.getRawMessage(),\n+                (Response) evt.getMessage(),\n+                request,\n+                transactionID));\n     }\n \n     /**\n@@ -608,4 +417,152 @@\n     {\n         return requestDestination;\n     }\n\n+    private final class Retransmitter\n+    {\n+        private int retransmissionCounter = 0;\n+        private int nextRetransmissionDelay = originalWaitInterval;\n+        private ScheduledFuture<?> retransmissionFuture;\n\n+        private final Runnable retransmissionAttempt = new Runnable()\n+        {\n+            @Override\n+            public void run()\n+            {\n+                if (cancelled.get())\n+                {\n+                    return;\n+                }\n\n+                retransmissionCounter++;\n\n+                int curWaitInterval = nextRetransmissionDelay;\n+                nextRetransmissionDelay\n+                    = Math.min(maxWaitInterval, 2 * nextRetransmissionDelay);\n\n+                try\n+                {\n+                    logger.fine(\n+                        \"retrying STUN tid \" + transactionID + \" from \"\n+                            + localAddress + \" to \" + requestDestination\n+                            + \" waited \" + curWaitInterval + \" ms retrans \"\n+                            + retransmissionCounter + \" of \"\n+                            + maxRetransmissions);\n+                    sendRequest0();\n+                }\n+                catch (Exception ex)\n+                {\n+                    logger.log(\n+                        Level.INFO,\n+                        \"A client tran retransmission failed\",\n+                        ex);\n+                }\n+                if(!cancelled.get())\n+                {\n+                    reschedule();\n+                }\n+            }\n\n+            private void reschedule()\n+            {\n+                if (retransmissionCounter < maxRetransmissions)\n+                {\n+                    retransmissionFuture = retransmissionThreadPool.schedule(\n+                        retransmissionAttempt,\n+                        nextRetransmissionDelay,\n+                        TimeUnit.MILLISECONDS);\n+                }\n+                else\n+                {\n+                    nextRetransmissionDelay =\n+                        Math.min(maxWaitInterval, 2* nextRetransmissionDelay);\n+\n+                    retransmissionFuture = retransmissionThreadPool.schedule(\n+                        transactionTimedOut,\n+                        nextRetransmissionDelay,\n+                        TimeUnit.MILLISECONDS);\n+                }\n+            }\n+        };\n\n+        private final Runnable transactionTimedOut = new Runnable()\n+        {\n+            @Override\n+            public void run()\n+            {\n+                if (cancelled.get())\n+                {\n+                    return;\n+                }\n\n+                stackCallback.removeClientTransaction(\n+                    StunClientTransaction.this);\n\n+                responseCollector.processTimeout(\n+                    new StunTimeoutEvent(\n+                        stackCallback,\n+                        getRequest(), getLocalAddress(), getTransactionID()));\n+            }\n+        };\n\n+        void schedule()\n+        {\n+            if (retransmissionFuture != null)\n+            {\n+                return;\n+            }\n+            retransmissionFuture = retransmissionThreadPool.schedule(\n+                retransmissionAttempt,\n+                nextRetransmissionDelay,\n+                TimeUnit.MILLISECONDS);\n+        }\n\n+        void cancel()\n+        {\n+            final ScheduledFuture<?> retransmissionFuture =\n+                this.retransmissionFuture;\n+            if (retransmissionFuture != null)\n+            {\n+                retransmissionFuture.cancel(true);\n+            }\n+        }\n+    }\n }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-7",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.googlecode.aviator.test.function.GrammarUnitTest",
                "error": "java.lang.AssertionError",
                "message": "Expected exception: com.googlecode.aviator.exception.ExpressionSyntaxErrorException",
                "methodName": "testIssue177"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 13,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 13
        },
        "program": "RegressionBug-7",
        "project": "RegressionBug-7",
        "repairOperators": [
            "condBranIfAdd",
            "condBranCaseAdd",
            "mcAdd",
            "mdAdd",
            "retBranchAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java\n@@ -457,8 +457,12 @@\n       factor();\n     }\n\n     while (expectChar('[') || expectChar('(')) {\n+      if (isConstant(this.prevToken)) {\n+        break;\n+      }\n\n       if (expectChar('[')) {\n         // (...)[index]\n         arrayAccess();\n@@ -893,4 +897,29 @@\n     }\n   }\n \n+  public static boolean isConstant(final Token<?> token) {\n+    switch (token.getType()) {\n+      case Number:\n+      case Pattern:\n+      case String:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }",
        "bicdiff": "Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator: AviatorEvaluatorInstance.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/AviatorEvaluator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/AviatorEvaluator.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/AviatorEvaluator.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/AviatorEvaluator.java\n@@ -107,28 +44,72 @@\n   /**\n    * Aviator version\n    */\n-  public static final String VERSION = \"2.1.1\";\n+  public static final String VERSION = \"3.0.0\";\n \n-  public static int BYTECODE_VER = Opcodes.V1_6;\n+  @Deprecated\n+  public static final Map<String, Object> FUNC_MAP = getInstance().getFuncMap();\n \n-  private static OutputStream traceOutputStream = System.out;\n+  @Deprecated\n+  public static final Map<OperatorType, AviatorFunction> OPS_MAP = getInstance().getOpsMap();\n \n-  private static final ConcurrentHashMap<Options, Object> options =\n-      new ConcurrentHashMap<Options, Object>();\n-  private static FunctionMissing functionMissing;\n\n+  @Deprecated\n+  public static int BYTECODE_VER = getInstance().getBytecodeVersion();\n \n+  private static class StaticHolder {\n+    private static AviatorEvaluatorInstance INSTANCE = new AviatorEvaluatorInstance();\n+  }\n\n+  public static AviatorEvaluatorInstance getInstance() {\n+    return StaticHolder.INSTANCE;\n+  }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/BaseExpression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/BaseExpression.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/BaseExpression.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/BaseExpression.java\n@@ -16,11 +18,12 @@\n   private List<String> varNames;\n   private List<String> varFullNames;\n   private String expression;\n+  protected AviatorEvaluatorInstance instance;\n \n\n-  public BaseExpression(List<String> varNames) {\n+  public BaseExpression(AviatorEvaluatorInstance instance, List<String> varNames) {\n     super();\n     this.varFullNames = varNames;\n+    this.instance = instance;\n     LinkedHashSet<String> tmp = new LinkedHashSet<String>(varNames.size());\n     // process nested names\n     for (String name : varNames) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/ClassExpression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/ClassExpression.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/ClassExpression.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/ClassExpression.java\n@@ -30,10 +33,28 @@\n+  public void setLambdaBootstraps(Map<String, LambdaFunctionBootstrap> lambdaBootstraps) {\n+    this.lambdaBootstraps = lambdaBootstraps;\n   }\n \n+  public ClassExpression(AviatorEvaluatorInstance instance, List<String> varNames) {\n+    super(instance, varNames);\n+  }\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator: ClassPathConfigFunctionLoader.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java\n@@ -75,7 +85,14 @@\n  *\n  */\n public class ASMCodeGenerator implements CodeGenerator {\n-  private static final String FIELD_PREFIX = \"var_\";\n\n+  private static final String FIELD_PREFIX = \"f\";\n+  private AviatorEvaluatorInstance instance;\n+  private Env compileEnv;\n   // Class Writer to generate class\n   // private final ClassWriter clazzWriter;\n   // Trace visitor\n@@ -88,6 +105,10 @@\n   private final String className;\n   // Class loader to define generated class\n   private final AviatorClassLoader classLoader;\n+  private LambdaGenerator lambdaGenerator;\n+  private Parser parser;\n \n   private static final AtomicLong CLASS_COUNTER = new AtomicLong();\n \n@@ -101,22 +122,36 @@\n \n   private int fieldCounter = 0;\n \n-  private final Map<String/* variable name */, String/* inner var name */> innerVarMap = new HashMap<String, String>();\n-  private final Map<String/* method name */, String/* inner method name */> innerMethodMap = new HashMap<String, String>();\n+  private Map<String/* variable name */, String/* inner var name */> innerVars = Collections.emptyMap();\n+  private Map<String/* method name */, String/* inner method name */> innerMethodMap = Collections.emptyMap();\n \n-  private Map<String, Integer/* counter */> varTokens = new LinkedHashMap<String, Integer>();\n-  private Map<String, Integer/* counter */> methodTokens = new HashMap<String, Integer>();\n+  private Map<String, Integer/* counter */> varTokens = Collections.emptyMap();\n+  private Map<String, Integer/* counter */> methodTokens = Collections.emptyMap();\n \n   private final Map<Label, Map<String/* inner name */, Integer/* local index */>> labelNameIndexMap =\n-      new HashMap<Label, Map<String, Integer>>();\n+      new IdentityHashMap<Label, Map<String, Integer>>();\n\n+  private Map<String, LambdaFunctionBootstrap> lambdaBootstraps;\n \n   private static final Label START_LABEL = new Label();\n \n   private Label currentLabel = START_LABEL;\n \n+  private CodeGenerator parentCodeGenerator;\n\n+  @Override\n+  public void setParser(Parser parser) {\n+    this.parser = parser;\n+  }\n+\n \n   private void setMaxStacks(int newMaxStacks) {\n     if (newMaxStacks > this.maxStacks) {\n@@ -125,8 +160,12 @@\n   }\n \n-  public ASMCodeGenerator(AviatorClassLoader classLoader, OutputStream traceOut, boolean trace) {\n+  public ASMCodeGenerator(AviatorEvaluatorInstance instance, AviatorClassLoader classLoader,\n+      OutputStream traceOut, boolean trace) {\n     this.classLoader = classLoader;\n+    this.instance = instance;\n+    this.compileEnv = new Env();\n+    this.compileEnv.setInstance(this.instance);\n     // Generate inner class name\n     this.className = \"Script_\" + System.currentTimeMillis() + \"_\" + CLASS_COUNTER.getAndIncrement();\n     // Auto compute frames\n@@ -149,8 +199,8 @@\n \n   private void startVisitMethodCode() {\n     this.mv = this.classWriter.visitMethod(ACC_PUBLIC + +ACC_FINAL, \"execute0\",\n-        \"(Ljava/util/Map;)Ljava/lang/Object;\",\n-        \"(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;)Ljava/lang/Object;\", null);\n+        \"(Lcom/googlecode/aviator/utils/Env;)Ljava/lang/Object;\",\n+        \"(Lcom/googlecode/aviator/utils/Env;)Ljava/lang/Object;\", null);\n     this.mv.visitCode();\n   }\n \n@@ -189,15 +239,16 @@\n    */\n   private void makeConstructor() {\n     {\n-      this.mv =\n-          this.classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/util/List;)V\", null, null);\n+      this.mv = this.classWriter.visitMethod(ACC_PUBLIC, \"<init>\",\n+          \"(Lcom/googlecode/aviator/AviatorEvaluatorInstance;Ljava/util/List;)V\", null, null);\n       this.mv.visitCode();\n       this.mv.visitVarInsn(ALOAD, 0);\n       this.mv.visitVarInsn(ALOAD, 1);\n+      this.mv.visitVarInsn(ALOAD, 2);\n       this.mv.visitMethodInsn(INVOKESPECIAL, \"com/googlecode/aviator/ClassExpression\", \"<init>\",\n-          \"(Ljava/util/List;)V\");\n-      if (!this.innerVarMap.isEmpty()) {\n-        for (Map.Entry<String, String> entry : this.innerVarMap.entrySet()) {\n+          \"(Lcom/googlecode/aviator/AviatorEvaluatorInstance;Ljava/util/List;)V\");\n+      if (!this.innerVars.isEmpty()) {\n+        for (Map.Entry<String, String> entry : this.innerVars.entrySet()) {\n           String outterName = entry.getKey();\n           String innerName = entry.getValue();\n           this.mv.visitVarInsn(ALOAD, 0);\n@@ -233,7 +285,7 @@\n \n \n   private void visitClass() {\n-    this.classWriter.visit(AviatorEvaluator.BYTECODE_VER, ACC_PUBLIC + ACC_SUPER, this.className,\n+    this.classWriter.visit(instance.getBytecodeVersion(), ACC_PUBLIC + ACC_SUPER, this.className,\n         null, \"com/googlecode/aviator/ClassExpression\", null);\n   }\n \n@@ -524,7 +583,7 @@\n \n \n   private void visitCompare(int ints, OperatorType opType) {\n-    if (!OperationRuntime.hasRuntimeContext(opType)) {\n+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {\n       this.mv.visitMethodInsn(INVOKEVIRTUAL, \"com/googlecode/aviator/runtime/type/AviatorObject\",\n           \"compare\", \"(Lcom/googlecode/aviator/runtime/type/AviatorObject;Ljava/util/Map;)I\");\n       Label l0 = this.makeLabel();\n@@ -666,10 +725,18 @@\n \n     byte[] bytes = this.classWriter.toByteArray();\n     try {\n-      Class<?> defineClass = ClassDefiner.defineClass(this.className, bytes, this.classLoader);\n-      Constructor<?> constructor = defineClass.getConstructor(List.class);\n-      return (Expression) constructor.newInstance(new ArrayList<String>(this.varTokens.keySet()));\n+      Class<?> defineClass =\n+          ClassDefiner.defineClass(this.className, Expression.class, bytes, this.classLoader);\n+      Constructor<?> constructor =\n+          defineClass.getConstructor(AviatorEvaluatorInstance.class, List.class);\n+      ClassExpression exp = (ClassExpression) constructor.newInstance(this.instance,\n+          new ArrayList<String>(this.varTokens.keySet()));\n+      exp.setLambdaBootstraps(lambdaBootstraps);\n+      return exp;\n     } catch (Exception e) {\n+      if (e.getCause() instanceof ExpressionRuntimeException) {\n+        throw (ExpressionRuntimeException) e.getCause();\n+      }\n       throw new CompileExpressionErrorException(\"define class error\", e);\n     }\n   }\n@@ -703,10 +770,13 @@\n           this.mv.visitMethodInsn(INVOKESTATIC, \"com/googlecode/aviator/runtime/type/AviatorBigInt\",\n               \"valueOf\", \"(Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorBigInt;\");\n         } else if (TypeUtils.isDecimal(number)) {\n+          this.loadEnv();\n+          // this.pushOperand();\n           this.mv.visitLdcInsn(numberToken.getLexeme());\n           this.mv.visitMethodInsn(INVOKESTATIC,\n               \"com/googlecode/aviator/runtime/type/AviatorDecimal\", \"valueOf\",\n-              \"(Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorDecimal;\");\n+              \"(Ljava/util/Map;Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorDecimal;\");\n+          this.popOperand();\n         } else if (TypeUtils.isDouble(number)) {\n           this.mv.visitLdcInsn(number);\n           this.mv.visitMethodInsn(INVOKESTATIC, \"com/googlecode/aviator/runtime/type/AviatorDouble\",\n@@ -760,7 +830,7 @@\n           this.pushOperand();\n         } else {\n           String outterVarName = variable.getLexeme();\n-          String innerVarName = this.innerVarMap.get(outterVarName);\n+          String innerVarName = this.innerVars.get(outterVarName);\n           if (innerVarName != null) {\n             // Is it stored in local?\n             Map<String, Integer> name2Index = this.labelNameIndexMap.get(this.currentLabel);\n@@ -811,12 +881,18 @@\n   }\n \n \n+  public void setLambdaBootstraps(Map<String, LambdaFunctionBootstrap> lambdaBootstraps) {\n+    this.lambdaBootstraps = lambdaBootstraps;\n+  }\n+\n+\n   public void initVariables(Map<String, Integer/* counter */> varTokens) {\n     this.varTokens = varTokens;\n+    this.innerVars = new HashMap<String, String>(varTokens.size());\n     for (String outterVarName : varTokens.keySet()) {\n       // Use inner variable name instead of outter variable name\n       String innerVarName = this.getInnerName(outterVarName);\n-      this.innerVarMap.put(outterVarName, innerVarName);\n+      this.innerVars.put(outterVarName, innerVarName);\n       this.classWriter.visitField(ACC_PRIVATE + ACC_FINAL, innerVarName,\n           \"Lcom/googlecode/aviator/runtime/type/AviatorJavaType;\", null, null).visitEnd();\n \n@@ -826,13 +902,13 @@\n \n   public void initMethods(Map<String, Integer/* counter */> methods) {\n     this.methodTokens = methods;\n+    this.innerMethodMap = new HashMap<String, String>(methods.size());\n     for (String outterMethodName : methods.keySet()) {\n       // Use inner method name instead of outter method name\n       String innerMethodName = this.getInnerName(outterMethodName);\n       this.innerMethodMap.put(outterMethodName, innerMethodName);\n       this.classWriter.visitField(ACC_PRIVATE + ACC_FINAL, innerMethodName,\n           \"Lcom/googlecode/aviator/runtime/type/AviatorFunction;\", null, null).visitEnd();\n-\n     }\n   }\n \n@@ -842,7 +918,7 @@\n   }\n \n \n-  private String getInvokeMethodDesc(int paramCount) {\n+  private static String getInvokeMethodDesc(int paramCount) {\n     StringBuilder sb = new StringBuilder(\"(Ljava/util/Map;\");\n     if (paramCount <= 20) {\n       for (int i = 0; i < paramCount; i++) {\n@@ -890,7 +966,7 @@\n       }\n     }\n     this.mv.visitMethodInsn(INVOKEINTERFACE, \"com/googlecode/aviator/runtime/type/AviatorFunction\",\n-        \"call\", this.getInvokeMethodDesc(parameterCount));\n+        \"call\", getInvokeMethodDesc(parameterCount));\n \n     this.popOperand(); // method object\n     this.popOperand(); // env map\n@@ -976,7 +1052,7 @@\n \n   @Override\n   public void onArrayIndexEnd(Token<?> lookhead) {\n-    if (!OperationRuntime.hasRuntimeContext(OperatorType.INDEX)) {\n+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, OperatorType.INDEX)) {\n       this.mv.visitMethodInsn(INVOKEVIRTUAL, \"com/googlecode/aviator/runtime/type/AviatorObject\",\n           \"getElement\",\n           \"(Ljava/util/Map;Lcom/googlecode/aviator/runtime/type/AviatorObject;)Lcom/googlecode/aviator/runtime/type/AviatorObject;\");\n@@ -1000,14 +1076,78 @@\n   @Override\n   public void onMethodName(Token<?> lookhead) {\n-    String outtterMethodName = lookhead.getLexeme();\n-    String innerMethodName = this.innerMethodMap.get(outtterMethodName);\n-    if (innerMethodName != null) {\n-      this.loadAviatorFunction(outtterMethodName, innerMethodName);\n+    String outtterMethodName = \"lambda\";\n+    if (lookhead.getType() != TokenType.Delegate) {\n+      outtterMethodName = lookhead.getLexeme();\n+      String innerMethodName = this.innerMethodMap.get(outtterMethodName);\n+      if (innerMethodName != null) {\n+        this.loadAviatorFunction(outtterMethodName, innerMethodName);\n+      } else {\n+        this.createAviatorFunctionObject(outtterMethodName);\n+      }\n     } else {\n-      this.createAviatorFunctionObject(outtterMethodName);\n+      this.loadEnv();\n+      this.mv.visitMethodInsn(INVOKESTATIC, \"com/googlecode/aviator/runtime/RuntimeUtils\",\n+          \"getFunction\",\n+          \"(Ljava/lang/Object;Ljava/util/Map;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;\");\n+      this.popOperand();\n+    }\n+    if (this.instance.getOption(Options.TRACE_EVAL)) {\n+      this.mv.visitMethodInsn(INVOKESTATIC, \"com/googlecode/aviator/runtime/function/TraceFunction\",\n+          \"wrapTrace\",\n+          \"(Lcom/googlecode/aviator/runtime/type/AviatorFunction;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;\");\n     }\n     this.loadEnv();\n     this.methodMetaDataStack.push(new MethodMetaData(outtterMethodName));\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java\n@@ -41,17 +40,32 @@\n     }\n   }\n \n+  private static boolean isPreferClassLoaderDefinerByDefault() {\n+    String version = (System.getProperty(\"java.version\"));\n+    try {\n+      return version != null && version.startsWith(\"1.7\");\n+    } catch (Throwable e) {\n+      return false;\n+    }\n+  }\n\n   private static boolean preferClassLoader =\n-      Boolean.valueOf(System.getProperty(\"aviator.preferClassloaderDefiner\", \"false\"));\n+      Boolean.valueOf(System.getProperty(\"aviator.preferClassloaderDefiner\",\n+          String.valueOf(isPreferClassLoaderDefinerByDefault())));\n\n+  static {\n+    if (preferClassLoader) {\n+      System.out.println(\"[Aviator WARN] aviator.preferClassloaderDefiner=\" + preferClassLoader);\n+    }\n+  }\n \n   private static int errorTimes = 0;\n \n-  public static final Class<?> defineClass(String className, byte[] bytes,\n+  public static final Class<?> defineClass(String className, Class<?> clazz, byte[] bytes,\n       AviatorClassLoader classLoader) throws NoSuchFieldException, IllegalAccessException {\n     if (!preferClassLoader && DEFINE_CLASS_HANDLE != null) {\n       try {\n-        Class<?> defineClass =\n-            (Class<?>) DEFINE_CLASS_HANDLE.invokeExact(Expression.class, bytes, EMPTY_OBJS);\n+        Class<?> defineClass = (Class<?>) DEFINE_CLASS_HANDLE.invokeExact(clazz, bytes, EMPTY_OBJS);\n         return defineClass;\n       } catch (Throwable e) {\n         // fallback to class loader mode.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/CodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/CodeGenerator.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/CodeGenerator.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/CodeGenerator.java\n@@ -17,16 +17,19 @@\n \n import com.googlecode.aviator.Expression;\n import com.googlecode.aviator.lexer.token.Token;\n+import com.googlecode.aviator.parser.Parser;\n \n \n /**\n  * Code generator interface\n- * \n+ *\n  * @author dennis\n- * \n+ *\n  */\n public interface CodeGenerator {\n \n+  public void setParser(Parser parser);\n+\n   public void onShiftRight(Token<?> lookhead);\n \n \n@@ -74,6 +77,8 @@\n \n   public void onTernaryRight(Token<?> lookhead);\n \n+  public void onTernaryEnd(Token<?> lookhead);\n+\n \n   public void onJoinLeft(Token<?> lookhead);\n \n@@ -110,27 +115,27 @@\n \n   public void onNeg(Token<?> lookhead);\n \n   public Expression getResult();\n \n   public void onConstant(Token<?> lookhead);\n \n   public void onMethodName(Token<?> lookhead);\n \n   public void onMethodParameter(Token<?> lookhead);\n \n   public void onMethodInvoke(Token<?> lookhead);\n \n+  public void onLambdaDefineStart(Token<?> lookhead);\n \n-  public void onArray(Token<?> lookhead);\n+  public void onLambdaArgument(Token<?> lookhead);\n \n+  public void onLambdaBodyStart(Token<?> lookhead);\n \n-  public void onArrayIndexStart(Token<?> token);\n+  public void onLambdaBodyEnd(Token<?> lookhead);\n \n+  public void onArray(Token<?> lookhead);\n\n+  public void onArrayIndexStart(Token<?> token);\n \n   public void onArrayIndexEnd(Token<?> lookhead);\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java\n@@ -52,19 +59,38 @@\n  *\n  */\n public class OptimizeCodeGenerator implements CodeGenerator {\n-  private final ASMCodeGenerator asmCodeGenerator;\n+  private ASMCodeGenerator codeGen;\n \n   private final List<Token<?>> tokenList = new ArrayList<Token<?>>();\n \n+  private LambdaGenerator lambdaGenerator;\n\n+  private CodeGenerator parentCodeGenerator;\n\n   private boolean trace = false;\n+  private AviatorEvaluatorInstance instance;\n\n+  private Parser parser;\n\n+  private Map<String, LambdaFunctionBootstrap> lambdaBootstraps;\n \n \n-  public OptimizeCodeGenerator(ClassLoader classLoader, OutputStream traceOutStream,\n-      boolean trace) {\n-    this.asmCodeGenerator =\n-        new ASMCodeGenerator(AviatorEvaluator.getAviatorClassLoader(), traceOutStream, trace);\n+  public OptimizeCodeGenerator(AviatorEvaluatorInstance instance, ClassLoader classLoader,\n+      OutputStream traceOutStream, boolean trace) {\n+    this.instance = instance;\n+    this.codeGen =\n+        new ASMCodeGenerator(instance, (AviatorClassLoader) classLoader, traceOutStream, trace);\n     this.trace = trace;\n+  }\n \n+  @Override\n+  public void setParser(Parser parser) {\n+    this.parser = parser;\n+    this.codeGen.setParser(parser);\n   }\n\n@@ -314,6 +362,9 @@\n           DelegateToken delegateToken = (DelegateToken) token;\n           if (delegateToken.getDelegateTokenType() == DelegateTokenType.Method_Name) {\n             Token<?> realToken = delegateToken.getToken();\n+            if (realToken == null) {\n+              continue;\n+            }\n             if (realToken.getType() == TokenType.Variable) {\n               String methodName = token.getLexeme();\n               if (!methods.containsKey(methodName)) {\n@@ -342,25 +393,27 @@\n \n     // get result from asm\n-    return this.asmCodeGenerator.getResult();\n+    return this.codeGen.getResult();\n   }\n \n \n   private void callASM(Map<String, Integer/* counter */> variables,\n       Map<String, Integer/* counter */> methods) {\n-    this.asmCodeGenerator.initVariables(variables);\n-    this.asmCodeGenerator.initMethods(methods);\n-    this.asmCodeGenerator.start();\n+    this.codeGen.initVariables(variables);\n+    this.codeGen.initMethods(methods);\n+    this.codeGen.setLambdaBootstraps(lambdaBootstraps);\n+    this.codeGen.start();\n \n     for (int i = 0; i < this.tokenList.size(); i++) {\n       Token<?> token = this.tokenList.get(i);\n@@ -370,82 +423,82 @@\n \n           switch (op.getOperatorType()) {\n             case ADD:\n-              this.asmCodeGenerator.onAdd(token);\n+              this.codeGen.onAdd(token);\n               break;\n             case SUB:\n-              this.asmCodeGenerator.onSub(token);\n+              this.codeGen.onSub(token);\n               break;\n             case MULT:\n-              this.asmCodeGenerator.onMult(token);\n+              this.codeGen.onMult(token);\n               break;\n             case DIV:\n-              this.asmCodeGenerator.onDiv(token);\n+              this.codeGen.onDiv(token);\n               break;\n             case MOD:\n-              this.asmCodeGenerator.onMod(token);\n+              this.codeGen.onMod(token);\n               break;\n             case EQ:\n-              this.asmCodeGenerator.onEq(token);\n+              this.codeGen.onEq(token);\n               break;\n             case NEQ:\n-              this.asmCodeGenerator.onNeq(token);\n+              this.codeGen.onNeq(token);\n               break;\n             case LT:\n-              this.asmCodeGenerator.onLt(token);\n+              this.codeGen.onLt(token);\n               break;\n             case LE:\n-              this.asmCodeGenerator.onLe(token);\n+              this.codeGen.onLe(token);\n               break;\n             case GT:\n-              this.asmCodeGenerator.onGt(token);\n+              this.codeGen.onGt(token);\n               break;\n             case GE:\n-              this.asmCodeGenerator.onGe(token);\n+              this.codeGen.onGe(token);\n               break;\n             case NOT:\n-              this.asmCodeGenerator.onNot(token);\n+              this.codeGen.onNot(token);\n               break;\n             case NEG:\n-              this.asmCodeGenerator.onNeg(token);\n+              this.codeGen.onNeg(token);\n               break;\n             case AND:\n-              this.asmCodeGenerator.onAndRight(token);\n+              this.codeGen.onAndRight(token);\n               break;\n             case OR:\n-              this.asmCodeGenerator.onJoinRight(token);\n+              this.codeGen.onJoinRight(token);\n               break;\n             case FUNC:\n-              this.asmCodeGenerator.onMethodInvoke(token);\n+              this.codeGen.onMethodInvoke(token);\n               break;\n             case INDEX:\n-              this.asmCodeGenerator.onArrayIndexEnd(token);\n+              this.codeGen.onArrayIndexEnd(token);\n               break;\n             case MATCH:\n-              this.asmCodeGenerator.onMatch(token);\n+              this.codeGen.onMatch(token);\n               break;\n             case TERNARY:\n-              this.asmCodeGenerator.onTernaryRight(token);\n+              this.codeGen.onTernaryRight(token);\n               break;\n             case BIT_AND:\n-              this.asmCodeGenerator.onBitAnd(token);\n+              this.codeGen.onBitAnd(token);\n               break;\n             case BIT_OR:\n-              this.asmCodeGenerator.onBitOr(token);\n+              this.codeGen.onBitOr(token);\n               break;\n             case BIT_XOR:\n-              this.asmCodeGenerator.onBitXor(token);\n+              this.codeGen.onBitXor(token);\n               break;\n             case BIT_NOT:\n-              this.asmCodeGenerator.onBitNot(token);\n+              this.codeGen.onBitNot(token);\n               break;\n             case SHIFT_LEFT:\n-              this.asmCodeGenerator.onShiftLeft(token);\n+              this.codeGen.onShiftLeft(token);\n               break;\n             case SHIFT_RIGHT:\n-              this.asmCodeGenerator.onShiftRight(token);\n+              this.codeGen.onShiftRight(token);\n               break;\n             case U_SHIFT_RIGHT:\n-              this.asmCodeGenerator.onUnsignedShiftRight(token);\n+              this.codeGen.onUnsignedShiftRight(token);\n               break;\n           }\n           break;\n@@ -454,34 +507,40 @@\n           final Token<?> realToken = delegateToken.getToken();\n           switch (delegateToken.getDelegateTokenType()) {\n             case And_Left:\n-              this.asmCodeGenerator.onAndLeft(realToken);\n+              this.codeGen.onAndLeft(realToken);\n               break;\n             case Join_Left:\n-              this.asmCodeGenerator.onJoinLeft(realToken);\n+              this.codeGen.onJoinLeft(realToken);\n               break;\n             case Array:\n-              this.asmCodeGenerator.onArray(realToken);\n+              this.codeGen.onArray(realToken);\n               break;\n             case Index_Start:\n-              this.asmCodeGenerator.onArrayIndexStart(realToken);\n+              this.codeGen.onArrayIndexStart(realToken);\n               break;\n             case Ternary_Boolean:\n-              this.asmCodeGenerator.onTernaryBoolean(realToken);\n+              this.codeGen.onTernaryBoolean(realToken);\n               break;\n             case Ternary_Left:\n-              this.asmCodeGenerator.onTernaryLeft(realToken);\n+              this.codeGen.onTernaryLeft(realToken);\n               break;\n             case Method_Name:\n-              this.asmCodeGenerator.onMethodName(realToken);\n+              this.codeGen.onMethodName(realToken);\n               break;\n             case Method_Param:\n-              this.asmCodeGenerator.onMethodParameter(realToken);\n+              this.codeGen.onMethodParameter(realToken);\n+              break;\n+            case Lambda_New:\n+              this.codeGen.genNewLambdaCode(delegateToken.getLambdaFunctionBootstrap());\n+              break;\n+            case Ternay_End:\n+              this.codeGen.onTernaryEnd(realToken);\n               break;\n           }\n           break;\n \n         default:\n-          this.asmCodeGenerator.onConstant(token);\n+          this.codeGen.onConstant(token);\n           break;\n       }\n\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator: CustomFunctionLoader.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/Expression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/Expression.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/Expression.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/Expression.java\n@@ -34,7 +34,7 @@\n    * @param env Binding variable environment\n    * @return\n    */\n-  public abstract Object execute(Map<String, Object> env);\n+  Object execute(Map<String, Object> env);\n \n \n   /**\n@@ -42,7 +42,7 @@\n    * \n    * @return\n    */\n-  public abstract Object execute();\n+  Object execute();\n \n \n   /**\n@@ -52,7 +52,7 @@\n    * @see com.googlecode.aviator.AviatorEvaluator#EVAL\n    * @return\n    */\n-  public List<String> getVariableNames();\n+  List<String> getVariableNames();\n \n \n   /**\n@@ -61,6 +61,6 @@\n    * \n    * @return\n    */\n-  public List<String> getVariableFullNames();\n+  List<String> getVariableFullNames();\n \n }\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator: FunctionLoader.java\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator: FunctionMissing.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java\n@@ -47,15 +47,22 @@\n   private final SymbolTable symbolTable;\n   // Tokens buffer\n   private final Stack<Token<?>> tokenBuffer = new Stack<Token<?>>();\n+  private AviatorEvaluatorInstance instance;\n+  private String expression;\n+  private MathContext mathContext;\n+  private boolean parseFloatIntoDecimal;\n \n-  public ExpressionLexer(String expression) {\n+  public ExpressionLexer(AviatorEvaluatorInstance instance, String expression) {\n     this.iterator = new StringCharacterIterator(expression);\n+    this.expression = expression;\n     this.symbolTable = new SymbolTable();\n     this.peek = this.iterator.current();\n+    this.instance = instance;\n+    this.mathContext = this.instance.getOption(Options.MATH_CONTEXT);\n+    this.parseFloatIntoDecimal =\n+        this.instance.getOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL);\n   }\n \n   /**\n    * Push back token\n    *\n@@ -231,16 +238,12 @@\n           || this.peek == 'e' || this.peek == 'M' || this.peek == 'N');\n       Number value;\n       if (isBigDecimal) {\n-        value = new BigDecimal(this.getBigNumberLexeme(sb),\n-            (MathContext) AviatorEvaluator.getOption(Options.MATH_CONTEXT));\n+        value = new BigDecimal(this.getBigNumberLexeme(sb), this.mathContext);\n       } else if (isBigInt) {\n         value = new BigInteger(this.getBigNumberLexeme(sb));\n       } else if (hasDot) {\n-        boolean alwaysUseDecimalAsDouble =\n-            AviatorEvaluator.getOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL);\n-        if (alwaysUseDecimalAsDouble) {\n-          value = new BigDecimal(sb.toString(),\n-              (MathContext) AviatorEvaluator.getOption(Options.MATH_CONTEXT));\n+        if (this.parseFloatIntoDecimal) {\n+          value = new BigDecimal(sb.toString(), this.mathContext);\n         } else {\n           value = dval;\n         }\n@@ -322,9 +325,12 @@\n     return token;\n   }\n \n+  public String getScanString() {\n+    return this.expression.substring(0, this.iterator.getIndex());\n+  }\n \n   private Token<?> reserverVar(String lexeme, Variable variable) {\n     // If it is a reserved word(true/false/nil/lambda)\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java\n@@ -35,12 +35,13 @@\n     reserve(\"true\", Variable.TRUE);\n     reserve(\"false\", Variable.FALSE);\n     reserve(\"nil\", Variable.NIL);\n+    reserve(\"lambda\", Variable.LAMBDA);\n   }\n  \n   /**\n    * Reserve variable\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java\n@@ -1,21 +1,37 @@\n \n   public static enum DelegateTokenType {\n-    And_Left, Join_Left, Ternary_Boolean, Ternary_Left, Array, Index_Start, Method_Name, Method_Param\n+    And_Left, Join_Left, Ternary_Boolean, Ternary_Left, Array, Index_Start, //\n+    Method_Name, Method_Param, Lambda_New, //\n+    Ternay_End\n   }\n \n \n@@ -36,11 +52,13 @@\n   }\n \n \n+  @Override\n   public com.googlecode.aviator.lexer.token.Token.TokenType getType() {\n     return TokenType.Delegate;\n   }\n \n \n+  @Override\n   public Token<?> getValue(Map<String, Object> env) {\n     return this.token;\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/Variable.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/Variable.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/Variable.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/Variable.java\n@@ -20,12 +20,15 @@\n\n public class Variable extends AbstractToken<Object> {\n \n+  public static final String INSTANCE_VAR = \"__instance__\";\n+  public static final String ENV_VAR = \"__env__\";\n+\n   public boolean isQuote() {\n     return quote;\n   }\n@@ -74,11 +77,26 @@\n   };\n \n+  /**\n+   * Lambda keyword\n+   */\n+  public static final Variable LAMBDA = new Variable(\"lambda\", -1) {\n\n+  @Override\n   public com.googlecode.aviator.lexer.token.Token.TokenType getType() {\n     return TokenType.Variable;\n   }\n \n+  @Override\n   public Object getValue(Map<String, Object> env) {\n     if (env != null) {\n       return env.get(this.lexeme);\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser: DepthState.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java\n@@ -16,26 +16,29 @@\n-public class ExpressionParser {\n+public class ExpressionParser implements Parser {\n   private final ExpressionLexer lexer;\n \n   static final Set<String> RESERVED_WORDS = new HashSet<String>();\n@@ -51,37 +54,96 @@\n \n   private Token<?> prevToken;\n \n-  private final CodeGenerator codeGenerator;\n+  private CodeGenerator codeGenerator;\n \n   private int parenDepth = 0;\n \n   private int bracketDepth = 0;\n \n+  private int lambdaDepth = 0;\n+\n+  private LinkedList<DepthState> depthState = new LinkedList<DepthState>();\n\n   private boolean inPattern = false;\n \n+  private AviatorEvaluatorInstance instance;\n\n   public void ternary() {\n     this.join();\n-    if (this.lookhead == null || this.expectLexeme(\":\") || this.expectLexeme(\",\")) {\n+    if (this.lookhead == null || this.expectChar(':') || this.expectChar(',')) {\n       return;\n     }\n-    if (this.expectLexeme(\"?\")) {\n+    if (this.expectChar('?')) {\n       this.move(true);\n       this.codeGenerator.onTernaryBoolean(this.lookhead);\n       this.ternary();\n-      if (this.expectLexeme(\":\")) {\n+      if (this.expectChar(':')) {\n         this.move(true);\n         this.codeGenerator.onTernaryLeft(this.lookhead);\n         this.ternary();\n\n@@ -128,9 +171,7 @@\n       } else {\n         if (this.lookhead == null) {\n           break;\n-        }\n\n-        else {\n+        } else {\n           break;\n         }\n       }\n@@ -140,21 +181,20 @@\n \n \n   private boolean isJoinToken() {\n-    return this.expectLexeme(\"|\");\n+    return this.expectChar('|');\n   }\n \n \n-  private boolean expectLexeme(String s) {\n+  private boolean expectChar(char ch) {\n     if (this.lookhead == null) {\n       return false;\n     }\n-    return this.lookhead.getType() == TokenType.Char\n-        && ((CharToken) this.lookhead).getLexeme().equals(s);\n+    return this.lookhead.getType() == TokenType.Char && ((CharToken) this.lookhead).getCh() == ch;\n   }\n \n \n   private boolean isAndToken() {\n-    return this.expectLexeme(\"&\");\n+    return this.expectChar('&');\n   }\n \n \n@@ -179,7 +219,7 @@\n   public void xor() {\n     this.bitAnd();\n     while (true) {\n-      if (this.expectLexeme(\"^\")) {\n+      if (this.expectChar('^')) {\n         this.move(true);\n         this.bitAnd();\n         this.codeGenerator.onBitXor(this.lookhead);\n@@ -232,13 +272,13 @@\n   public void equality() {\n     this.rel();\n     while (true) {\n-      if (this.expectLexeme(\"=\")) {\n+      if (this.expectChar('=')) {\n         this.move(true);\n-        if (this.expectLexeme(\"=\")) {\n+        if (this.expectChar('=')) {\n           this.move(true);\n           this.rel();\n           this.codeGenerator.onEq(this.lookhead);\n-        } else if (this.expectLexeme(\"~\")) {\n+        } else if (this.expectChar('~')) {\n           // It is a regular expression\n           this.move(true);\n           this.rel();\n@@ -246,9 +286,9 @@\n         } else {\n           this.reportSyntaxError(\"Aviator doesn't support assignment\");\n         }\n-      } else if (this.expectLexeme(\"!\")) {\n+      } else if (this.expectChar('!')) {\n         this.move(true);\n-        if (this.expectLexeme(\"=\")) {\n+        if (this.expectChar('=')) {\n           this.move(true);\n           this.rel();\n           this.codeGenerator.onNeq(this.lookhead);\n@@ -265,9 +305,9 @@\n   public void rel() {\n     this.shift();\n     while (true) {\n-      if (this.expectLexeme(\"<\")) {\n+      if (this.expectChar('<')) {\n         this.move(true);\n-        if (this.expectLexeme(\"=\")) {\n+        if (this.expectChar('=')) {\n           this.move(true);\n           this.expr();\n           this.codeGenerator.onLe(this.lookhead);\n@@ -275,9 +315,9 @@\n           this.expr();\n           this.codeGenerator.onLt(this.lookhead);\n         }\n-      } else if (this.expectLexeme(\">\")) {\n+      } else if (this.expectChar('>')) {\n         this.move(true);\n-        if (this.expectLexeme(\"=\")) {\n+        if (this.expectChar('=')) {\n           this.move(true);\n           this.expr();\n           this.codeGenerator.onGe(this.lookhead);\n@@ -295,9 +335,9 @@\n   public void shift() {\n     this.expr();\n     while (true) {\n-      if (this.expectLexeme(\"<\")) {\n+      if (this.expectChar('<')) {\n         this.move(true);\n-        if (this.expectLexeme(\"<\")) {\n+        if (this.expectChar('<')) {\n           this.move(true);\n           this.expr();\n           this.codeGenerator.onShiftLeft(this.lookhead);\n@@ -305,11 +345,11 @@\n           this.back();\n           break;\n         }\n-      } else if (this.expectLexeme(\">\")) {\n+      } else if (this.expectChar('>')) {\n         this.move(true);\n-        if (this.expectLexeme(\">\")) {\n+        if (this.expectChar('>')) {\n           this.move(true);\n-          if (this.expectLexeme(\">\")) {\n+          if (this.expectChar('>')) {\n             this.move(true);\n             this.expr();\n             this.codeGenerator.onUnsignedShiftRight(this.lookhead);\n@@ -332,11 +372,11 @@\n   public void expr() {\n     this.term();\n     while (true) {\n-      if (this.expectLexeme(\"+\")) {\n+      if (this.expectChar('+')) {\n         this.move(true);\n         this.term();\n         this.codeGenerator.onAdd(this.lookhead);\n-      } else if (this.expectLexeme(\"-\")) {\n+      } else if (this.expectChar('-')) {\n         this.move(true);\n         this.term();\n         this.codeGenerator.onSub(this.lookhead);\n@@ -350,15 +390,15 @@\n   public void term() {\n     this.unary();\n     while (true) {\n-      if (this.expectLexeme(\"*\")) {\n+      if (this.expectChar('*')) {\n         this.move(true);\n         this.unary();\n         this.codeGenerator.onMult(this.lookhead);\n-      } else if (this.expectLexeme(\"/\")) {\n+      } else if (this.expectChar('/')) {\n         this.move(true);\n         this.unary();\n         this.codeGenerator.onDiv(this.lookhead);\n-      } else if (this.expectLexeme(\"%\")) {\n+      } else if (this.expectChar('%')) {\n         this.move(true);\n         this.unary();\n         this.codeGenerator.onMod(this.lookhead);\n@@ -370,30 +410,30 @@\n \n \n   public void unary() {\n-    if (this.expectLexeme(\"!\")) {\n+    if (this.expectChar('!')) {\n       this.move(true);\n       // check if it is a seq function call,\"!\" as variable\n-      if (this.expectLexeme(\",\") || this.expectLexeme(\")\")) {\n+      if (this.expectChar(',') || this.expectChar(')')) {\n         this.back();\n         this.factor();\n       } else {\n         this.unary();\n         this.codeGenerator.onNot(this.lookhead);\n       }\n-    } else if (this.expectLexeme(\"-\")) {\n+    } else if (this.expectChar('-')) {\n       this.move(true);\n       // check if it is a seq function call,\"!\" as variable\n-      if (this.expectLexeme(\",\") || this.expectLexeme(\")\")) {\n+      if (this.expectChar(',') || this.expectChar(')')) {\n         this.back();\n         this.factor();\n       } else {\n         this.unary();\n         this.codeGenerator.onNeg(this.lookhead);\n       }\n-    } else if (this.expectLexeme(\"~\")) {\n+    } else if (this.expectChar('~')) {\n       this.move(true);\n       // check if it is a seq function call,\"~\" as variable\n-      if (this.expectLexeme(\",\") || this.expectLexeme(\")\")) {\n+      if (this.expectChar(',') || this.expectChar(')')) {\n         this.back();\n         this.factor();\n       } else {\n@@ -403,6 +443,36 @@\n     } else {\n       this.factor();\n     }\n+\n+    while (expectChar('[') || expectChar('(')) {\n+      if (expectChar('[')) {\n+        // (...)[index]\n+        arrayAccess();\n+      } else if (expectChar('(')) {\n+        // May be call chain, such as \"s(1)(2)(3)\"\n+        this.parenDepth++;\n+        this.depthState.add(DepthState.Parent);\n+        this.codeGenerator.onMethodName(new DelegateToken(this.lookhead.getStartIndex(),\n+            this.lookhead, DelegateTokenType.Method_Name));\n+        this.move(true);\n+        if (!this.expectChar(')')) {\n+          this.ternary();\n+          this.codeGenerator.onMethodParameter(this.lookhead);\n+          while (this.expectChar(',')) {\n+            this.move(true);\n+            this.ternary();\n+            this.codeGenerator.onMethodParameter(this.lookhead);\n+          }\n+        }\n+        if (this.expectChar(')')) {\n+          this.parenDepth--;\n+          this.depthState.removeLast();\n+          this.move(true);\n+          this.codeGenerator.onMethodInvoke(this.lookhead);\n+        }\n+      }\n+    }\n+\n   }\n \n   public static final CharToken LEFT_PAREN = new CharToken('(', -1);",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-8",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "liqp.tags.CycleTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : is \"123\"\n     but: was \"121\"",
                "methodName": "testCycleInNestedScope"
            }
        ],
        "metrics": {
            "chunks": 8,
            "classes": 2,
            "files": 2,
            "linesAdd": 23,
            "linesMod": 2,
            "linesRem": 6,
            "methods": 3,
            "sizeInLines": 25
        },
        "program": "RegressionBug-8",
        "project": "RegressionBug-8",
        "repairOperators": [
            "assignExpChange",
            "assignAdd",
            "assignRem",
            "condBranIfAdd",
            "condBranRem",
            "mcAdd",
            "mcRem",
            "mdAdd",
            "objInstRem",
            "objInstAdd",
            "varAdd",
            "varRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/liqp/tags/Cycle.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/liqp/tags/Cycle.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/liqp/tags/Cycle.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/liqp/tags/Cycle.java\n@@ -5,11 +5,10 @@\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n \n class Cycle extends Tag {\n \n-    private static final String PREPEND = \"\\\"'\";\n\n     /*\n      * Cycle is usually used within a loop to alternate\n      * between values, like colors or DOM classes.\n@@ -17,25 +16,25 @@\n     @Override\n     public Object render(TemplateContext context, LNode... nodes) {\n \n-        String groupName = nodes[0] == null ?\n-                PREPEND + (nodes.length - 1) :\n-                super.asString(nodes[0].render(context)); \n-        groupName = PREPEND + groupName;\n-        Object obj = context.remove(groupName);\n\n-        List<Object> elements = new ArrayList<Object>();\n+        List<Object> elements = new ArrayList<>();\n \n         for (int i = 1; i < nodes.length; i++) {\n             elements.add(nodes[i].render(context));\n         }\n \n+        String groupName = nodes[0] == null ?\n+                super.asString(elements) :\n+                super.asString(nodes[0].render(context));\n+        Map<String, Object> cycleRegistry = context.getRegistry(TemplateContext.REGISTRY_CYCLE);\n+        Object obj = cycleRegistry.remove(groupName);\n\n         CycleGroup group;\n \n         if (obj == null) {\n@@ -45,7 +44,7 @@\n             group = (CycleGroup) obj;\n         }\n \n-        context.put(groupName, group);\n+        cycleRegistry.put(groupName, group);\n \n         return group.next(elements);\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/liqp/TemplateContext.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/liqp/TemplateContext.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/liqp/TemplateContext.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/liqp/TemplateContext.java\n@@ -10,12 +10,15 @@\n public class TemplateContext {\n \n+    public static final String REGISTRY_CYCLE = \"cycle\";\n\n     protected TemplateContext parent;\n     public final ProtectionSettings protectionSettings;\n     public final RenderSettings renderSettings;\n     public final ParseSettings parseSettings;\n     private Map<String, Object> variables;\n     private Map<String, Object> environmentMap;\n+    private Map<String, Map<String, Object>> registry;\n \n     private List<RuntimeException> errors;\n \n@@ -133,4 +136,24 @@\n         }\n         return environmentMap;\n     }\n\n+    public Map<String, Object> getRegistry(String registryName) {\n+        if (parent != null) {\n+            return parent.getRegistry(registryName);\n+        }\n+        if (!REGISTRY_CYCLE.equals(registryName)) {\n+            throw new RuntimeException(\"unknown registry type: \" + registryName);\n+        }\n+        if (registry == null) {\n+            registry = new HashMap<>();\n+        }\n+        if (!registry.containsKey(registryName)) {\n+            registry.put(registryName, new HashMap<String, Object>());\n+        }\n+        return registry.get(registryName);\n+    }\n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/ProtectionSettings.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/ProtectionSettings.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/ProtectionSettings.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/ProtectionSettings.java\n@@ -7,6 +9,9 @@\n     public final long maxRenderTimeMillis;\n     public final long maxTemplateSizeBytes;\n \n+    private int iterations = 0;\n\n     public static class Builder {\n \n         private int maxIterations;\n@@ -52,4 +57,13 @@ \n         this.maxRenderTimeMillis = maxRenderTimeMillis;\n         this.maxTemplateSizeBytes = maxTemplateSizeBytes;\n     }\n\n+    public void incrementIterations() {\n+        this.iterations++;\n+        if (this.iterations > this.maxIterations) {\n+            throw new ExceededMaxIterationsException(this.maxIterations);\n+        }\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/tags/Assign.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/tags/Assign.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/tags/Assign.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/tags/Assign.java\n@@ -31,7 +31,8 @@\n             value = filter.apply(value, context);\n         }\n \n-        context.put(id, value);\n+        context.put(id, value, true);\n \n         return \"\";\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/tags/For.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/tags/For.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/tags/For.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/tags/For.java\n@@ -48,11 +48,12 @@\n \n         String id = super.asString(nodes[1].render(context));\n \n-        context.put(FORLOOP, new HashMap<String, Object>());\n+        TemplateContext nestedContext = new TemplateContext(context);\n \n-        Object rendered = array ? renderArray(id, context, nodes) : renderRange(id, context, nodes);\n+        nestedContext.put(FORLOOP, new HashMap<String, Object>());\n \n-        context.remove(FORLOOP);\n+        Object rendered = array ? renderArray(id, nestedContext, nodes) : renderRange(id, nestedContext, nodes);\n \n         return rendered;\n     }\n@@ -140,7 +141,7 @@\n             }\n         }\n \n-        context.put(CONTINUE, continueIndex + 1);\n+        context.put(CONTINUE, continueIndex + 1, true);\n \n         return builder.toString();\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/TemplateContext.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/TemplateContext.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/liqp/TemplateContext.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/liqp/TemplateContext.java\n@@ -8,45 +7,93 @@\n \n public class TemplateContext {\n \n+    protected TemplateContext parent;\n     public final ProtectionSettings protectionSettings;\n     public final Flavor flavor;\n-    private final Map<String, Object> variables;\n-    private int iterations;\n+    private Map<String, Object> variables;\n \n     public TemplateContext() {\n         this(new ProtectionSettings.Builder().build(), Flavor.LIQUID, new LinkedHashMap<String, Object>());\n     }\n \n     public TemplateContext(ProtectionSettings protectionSettings, Flavor flavor, Map<String, Object> variables) {\n+        this.parent = null;\n         this.protectionSettings = protectionSettings;\n         this.flavor = flavor;\n         this.variables = variables;\n-        this.iterations = 0;\n+    }\n\n+    public TemplateContext(TemplateContext parent) {\n+        this.parent = parent;\n+        this.protectionSettings = parent.protectionSettings;\n+        this.flavor = parent.flavor;\n+        this.variables = new LinkedHashMap<String, Object>();\n     }\n \n     public void incrementIterations() {\n+        this.protectionSettings.incrementIterations();\n+    }\n \n-        this.iterations++;\n+    public boolean containsKey(String key) {\n \n-        if (this.iterations > this.protectionSettings.maxIterations) {\n-            throw new ExceededMaxIterationsException(this.protectionSettings.maxIterations);\n+        if (this.containsKey(key)) {\n+            return true;\n         }\n-    }\n \n-    public boolean containsKey(String key) {\n-        return this.variables.containsKey(key);\n+        if (parent != null) {\n+            return parent.containsKey(key);\n+        }\n\n+        return false;\n     }\n \n     public Object get(String key) {\n-        return this.variables.get(key);\n\n+        Object value = this.variables.get(key);\n\n+        if (value != null) {\n+            return value;\n+        }\n\n+        if (parent != null) {\n+            return parent.get(key);\n+        }\n\n+        return null;\n     }\n \n     public Object put(String key, Object value) {\n-        return this.variables.put(key, value);\n+        return this.put(key, value, false);\n+    }\n\n+    public Object put(String key, Object value, boolean putInRootContext) {\n+\n+        if (!putInRootContext || parent == null) {\n+            return this.variables.put(key, value);\n+        }\n\n+        return parent.put(key, value, putInRootContext);\n     }\n \n     public Object remove(String key) {\n-        return this.variables.remove(key);\n\n+        if (this.variables.containsKey(key)) {\n+            return this.variables.remove(key);\n+        }\n\n+        if (parent != null) {\n+            return parent.remove(key);\n+        }\n\n+        return null;\n     }\n \n     public Map<String,Object> getVariables() {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-9",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.github.javafaker.FakerTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : to match the regular expression [1-9]\n     but: was \"10\"",
                "methodName": "numberBetweenRepeated"
            },
            {
                "className": "com.github.javafaker.NumberTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : is a value less than <10>\n     but: <10> was equal to <10>",
                "methodName": "testIntNumberBetweenRepeated"
            },
            {
                "className": "com.github.javafaker.NumberTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : is a value less than <10L>\n     but: <10L> was equal to <10L>",
                "methodName": "testLongNumberBetweenRepeated"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 4
        },
        "program": "RegressionBug-9",
        "project": "RegressionBug-9",
        "repairOperators": [
            "retBranchAdd",
            "retExpChange",
            "condBranIfElseAdd",
            "condBranIfAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/javafaker/Number.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/javafaker/Number.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/javafaker/Number.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/javafaker/Number.java\n@@ -27,7 +27,10 @@\n      * @see Number#numberBetween(long, long) \n      */\n     public int numberBetween(int min, int max) {\n+        if (min == max) return min;\n-        return decimalBetween(min, max).setScale(0, BigDecimal.ROUND_HALF_DOWN).intValue();\n+        return decimalBetween(min, max).setScale(0, BigDecimal.ROUND_HALF_DOWN).intValue() == max ? value - 1 : value;\n     }\n \n     /**\n@@ -39,7 +42,10 @@\n      * @param max exclusive (unless min == max)\n      */\n     public long numberBetween(long min, long max) {\n+        if (min == max) return min;          \n-        return decimalBetween(min, max).setScale(0, BigDecimal.ROUND_HALF_DOWN).longValue();\n+        return decimalBetween(min, max).setScale(0, BigDecimal.ROUND_HALF_DOWN).longValue() == max ? value - 1 : value;\n     }\n     \n     /**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/javafaker/Number.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/javafaker/Number.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/javafaker/Number.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/javafaker/Number.java\n@@ -39,7 +39,7 @@\n      * @param max exclusive (unless min == max)\n      */\n     public long numberBetween(long min, long max) {\n-        return decimalBetween(min,max).longValue();\n+        return decimalBetween(min,max).setScale(0, BigDecimal.ROUND_HALF_DOWN).longValue();\n     }\n     \n     /**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-10",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.springframework.data.mapping.model.KotlinCopyMethodUnitTests",
                "error": "java.lang.AssertionError",
                "message": ": \n\nExpecting Optional to contain a value but it was empty.",
                "methodName": "shouldDetermineCopyMethodForParametrizedType"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 0,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-10",
        "project": "RegressionBug-10",
        "repairOperators": [
            "assignAdd",
            "mcRepl",
            "varAdd",
            "retRem",
            "mcAdd",
            "retBranchAdd",
            "retExpChange",
            "condBranIfAdd"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n@@ -278,7 +278,8 @@\n \n \t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n \n-\t\treturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));\n+\t\tClass<?> rawClass = ResolvableType.forType(parameterType).getRawClass();\n+\t\treturn rawClass == null || target.isAssignableFrom(rawClass);\n \t}\n \n \t/**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n@@ -220,15 +220,71 @@\n \n \tprivate static Optional<Method> findSyntheticCopyMethod(Class<?> type) {\n \n+\t\tKClass<?> kotlinClass = JvmClassMappingKt.getKotlinClass(type);\n+\t\tKFunction<?> primaryConstructor = KClasses.getPrimaryConstructor(kotlinClass);\n\n+\t\tif (primaryConstructor == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n\n \t\treturn Arrays.stream(type.getDeclaredMethods()) //\n \t\t\t\t.filter(it -> it.getName().equals(\"copy$default\") //\n \t\t\t\t\t\t&& Modifier.isStatic(it.getModifiers()) //\n \t\t\t\t\t\t&& it.getReturnType().equals(type))\n \t\t\t\t.filter(Method::isSynthetic) //\n+\t\t\t\t.filter(it -> matchesPrimaryConstructor(it.getParameterTypes(), primaryConstructor))\n \t\t\t\t.findFirst();\n \t}\n\n+\tprivate static boolean matchesPrimaryConstructor(Class<?>[] parameterTypes, KFunction<?> primaryConstructor) {\n+\t\tList<KParameter> constructorArguments = getComponentArguments(primaryConstructor);\n+\t\tint defaultingArgs = KotlinDefaultMask.from(primaryConstructor, kParameter -> false).getDefaulting().length;\n+\t\tif (parameterTypes.length != 1 /* $this */ + constructorArguments.size() + defaultingArgs + 1 /* object marker */) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!isAssignableFrom(parameterTypes[0], primaryConstructor.getReturnType())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (int i = 0; i < constructorArguments.size(); i++) {\n+\t\t\tKParameter kParameter = constructorArguments.get(i);\n+\t\t\tif (!isAssignableFrom(parameterTypes[i + 1], kParameter.getType())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n\n+\tprivate static List<KParameter> getComponentArguments(KFunction<?> primaryConstructor) {\n+\t\treturn primaryConstructor.getParameters() //\n+\t\t\t\t.stream() //\n+\t\t\t\t.filter(it -> it.getKind() == Kind.VALUE) //\n+\t\t\t\t.collect(Collectors.toList());\n+\t}\n\n+\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n+\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n+\t\tif (parameterType instanceof Class) {\n+\t\t\treturn target.isAssignableFrom((Class<?>) parameterType);\n+\t\t}\n+\t\treturn false;\n+\t}\n\n\t/**\n \t * Value object to represent Kotlin {@literal copy$default} invocation metadata.\n \t *\n \t * @author Mark Paluch",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-11",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.springframework.data.mapping.model.KotlinCopyMethodUnitTests",
                "error": "java.lang.AssertionError",
                "message": ": \n\nExpecting Optional to contain a value but it was empty.",
                "methodName": "shouldDetermineCopyMethodForParametrizedType"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 0,
            "linesRem": 4,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-11",
        "project": "RegressionBug-11",
        "repairOperators": [
            "condBranRem",
            "retBranchAdd",
            "retRem",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\t2024-09-08 01:36:08.937772337 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\t2024-09-08 01:36:08.885771972 +1000\n@@ -33,6 +33,7 @@\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n+import org.springframework.core.ResolvableType;\n import org.springframework.data.mapping.PersistentEntity;\n import org.springframework.data.mapping.PersistentProperty;\n import org.springframework.data.mapping.SimplePropertyHandler;\n@@ -277,11 +278,7 @@\n \n \t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n \n-\t\tif (parameterType instanceof Class) {\n-\t\t\treturn target.isAssignableFrom((Class<?>) parameterType);\n-\t\t}\n-\t\treturn false;\n+\t\treturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));\n \t}\n \n \t/**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java\n@@ -220,15 +220,71 @@\n \n \tprivate static Optional<Method> findSyntheticCopyMethod(Class<?> type) {\n \n+\t\tKClass<?> kotlinClass = JvmClassMappingKt.getKotlinClass(type);\n+\t\tKFunction<?> primaryConstructor = KClasses.getPrimaryConstructor(kotlinClass);\n+\t\tif (primaryConstructor == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n\n \t\treturn Arrays.stream(type.getDeclaredMethods()) //\n \t\t\t\t.filter(it -> it.getName().equals(\"copy$default\") //\n \t\t\t\t\t\t&& Modifier.isStatic(it.getModifiers()) //\n \t\t\t\t\t\t&& it.getReturnType().equals(type))\n \t\t\t\t.filter(Method::isSynthetic) //\n+\t\t\t\t.filter(it -> matchesPrimaryConstructor(it.getParameterTypes(), primaryConstructor))\n \t\t\t\t.findFirst();\n \t}\n \n+\tprivate static boolean matchesPrimaryConstructor(Class<?>[] parameterTypes, KFunction<?> primaryConstructor) {\n+\t\tList<KParameter> constructorArguments = getComponentArguments(primaryConstructor);\n+\t\tint defaultingArgs = KotlinDefaultMask.from(primaryConstructor, kParameter -> false).getDefaulting().length;\n+\t\tif (parameterTypes.length != 1 /* $this */ + constructorArguments.size() + defaultingArgs + 1 /* object marker */) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!isAssignableFrom(parameterTypes[0], primaryConstructor.getReturnType())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (int i = 0; i < constructorArguments.size(); i++) {\n+\t\t\tKParameter kParameter = constructorArguments.get(i);\n+\t\t\tif (!isAssignableFrom(parameterTypes[i + 1], kParameter.getType())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n\n+\tprivate static List<KParameter> getComponentArguments(KFunction<?> primaryConstructor) {\n+\t\treturn primaryConstructor.getParameters() //\n+\t\t\t\t.stream() //\n+\t\t\t\t.filter(it -> it.getKind() == Kind.VALUE) //\n+\t\t\t\t.collect(Collectors.toList());\n+\t}\n\n+\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n+\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n+\t\tif (parameterType instanceof Class) {\n+\t\t\treturn target.isAssignableFrom((Class<?>) parameterType);\n+\t\t}\n+\t\treturn false;\n+\t}\n\n\t/**\n \t * Value object to represent Kotlin {@literal copy$default} invocation metadata.\n \t *\n \t * @author Mark Paluch",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-12",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.amihaiemil.eoyaml.ReadYamlMappingTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : \"2\"\n     but: was \"1\"",
                "methodName": "returnsValueOfStringKeys"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-12",
        "project": "RegressionBug-12",
        "repairOperators": [
            "condExpExpand",
            "mcAdd",
            "mcRepl",
            "condExpMod"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n@@ -238,7 +238,7 @@\n         for(final String tryKey : keys) {\n             for (final YamlLine line : this.significant) {\n                 final String trimmed = line.trimmed();\n-                if(trimmed.endsWith(tryKey + \":\")\n+                if(trimmed.equals(tryKey + \":\") || trimmed.equals(\"- \"+ tryKey + \":\")\n                     || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                     || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                 ) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n@@ -179,23 +179,34 @@ private YamlNode valueOfStringKey(final String key) {\n         YamlNode value = null;\n-        for (final YamlLine line : this.significant) {\n-            final String trimmed = line.trimmed();\n-            if(trimmed.endsWith(key + \":\")\n-                || trimmed.matches(\"^\" + key + \"\\\\:[ ]*\\\\>$\")\n-                || trimmed.matches(\"^\" + key + \"\\\\:[ ]*\\\\|$\")\n-            ) {\n-                value = this.significant.toYamlNode(line);\n-            } else if(trimmed.startsWith(key + \":\")\n-                && trimmed.length() > 1\n-            ) {\n-                value = new ReadPlainScalar(this.all, line);\n+        final String[] keys = new String[] {\n+            key,\n+            \"\\\"\" + key + \"\\\"\",\n+            \"'\" + key + \"'\",\n+        };\n+        for(final String tryKey : keys) {\n+            for (final YamlLine line : this.significant) {\n+                final String trimmed = line.trimmed();\n+                if(trimmed.endsWith(tryKey + \":\")\n+                    || trimmed.matches(\"^\" + tryKey + \"\\\\:[ ]*\\\\>$\")\n+                    || trimmed.matches(\"^\" + tryKey + \"\\\\:[ ]*\\\\|$\")\n+                ) {\n+                    value = this.significant.toYamlNode(line);\n+                } else if(trimmed.startsWith(tryKey + \":\")\n+                    && trimmed.length() > 1\n+                ) {\n+                    value = new ReadPlainScalar(this.all, line);\n+                }\n+                if(value != null) {\n+                    return value;\n+                }\n             }\n         }\n-        return value;\n+        return null;\n     }\n \n     /**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-13",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.amihaiemil.eoyaml.ReadYamlMappingTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : \"2\"\n     but: was \"1\"",
                "methodName": "returnsValueOfStringKeys"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-13",
        "project": "RegressionBug-13",
        "repairOperators": [
            "mcRepl",
            "mcParValChange",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n@@ -238,7 +238,7 @@\n         for(final String tryKey : keys) {\n             for (final YamlLine line : this.significant) {\n                 final String trimmed = line.trimmed();\n-                if(trimmed.endsWith(tryKey + \":\")\n+                if(trimmed.matches(\"^-?[ ]*\" + Pattern.quote(tryKey) + \":\")\n                     || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                     || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                 ) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\t2024-09-08 01:36:09.293774829 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\t2024-09-08 01:36:09.261774605 +1000\n@@ -179,23 +179,34 @@\n      * The YamlNode value associated with a String (scalar) key.\n      * @param key String key.\n      * @return YamlNode.\n      * @checkstyle ReturnCount (50 lines)\n      */\n     private YamlNode valueOfStringKey(final String key) {\n         YamlNode value = null;\n-        for (final YamlLine line : this.significant) {\n-            final String trimmed = line.trimmed();\n-            if(trimmed.endsWith(key + \":\")\n-                || trimmed.matches(\"^\" + key + \"\\\\:[ ]*\\\\>$\")\n-                || trimmed.matches(\"^\" + key + \"\\\\:[ ]*\\\\|$\")\n-            ) {\n-                value = this.significant.toYamlNode(line);\n-            } else if(trimmed.startsWith(key + \":\")\n-                && trimmed.length() > 1\n-            ) {\n-                value = new ReadPlainScalar(this.all, line);\n+        final String[] keys = new String[] {\n+            key,\n+            \"\\\"\" + key + \"\\\"\",\n+            \"'\" + key + \"'\",\n+        };\n+        for(final String tryKey : keys) {\n+            for (final YamlLine line : this.significant) {\n+                final String trimmed = line.trimmed();\n+                if(trimmed.endsWith(tryKey + \":\")\n+                    || trimmed.matches(\"^\" + tryKey + \"\\\\:[ ]*\\\\>$\")\n+                    || trimmed.matches(\"^\" + tryKey + \"\\\\:[ ]*\\\\|$\")\n+                ) {\n+                    value = this.significant.toYamlNode(line);\n+                } else if(trimmed.startsWith(tryKey + \":\")\n+                    && trimmed.length() > 1\n+                ) {\n+                    value = new ReadPlainScalar(this.all, line);\n+                }\n+                if(value != null) {\n+                    return value;\n+                }\n             }\n         }\n-        return value;\n+        return null;\n     }\n \n     /**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-14",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.amihaiemil.eoyaml.RtYamlInputTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : \"escaped: scalar, looks like mapping\"\n     but: was null",
                "methodName": "readsEscapedScalarsFromSequence"
            }
        ],
        "metrics": {
            "chunks": 8,
            "classes": 4,
            "files": 4,
            "linesAdd": 25,
            "linesMod": 3,
            "linesRem": 4,
            "methods": 7,
            "sizeInLines": 29
        },
        "program": "RegressionBug-14",
        "project": "RegressionBug-14",
        "repairOperators": [
            "condExpMod",
            "assignRem",
            "condBranRem",
            "condBranIfElseAdd",
            "assignAdd",
            "mdAdd",
            "assignExpChange",
            "varAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java\n@@ -70,12 +70,16 @@\n         final String value;\n         final String trimmed = this.scalar.trimmed();\n-        if(trimmed.contains(\":\") && !trimmed.endsWith(\":\")) {\n-            value = trimmed.substring(trimmed.indexOf(\":\") + 1).trim();\n-        } else if(trimmed.startsWith(\"-\") && trimmed.length() > 1) {\n+        if(this.escapedSequenceScalar(this.scalar)) {\n             value = trimmed.substring(trimmed.indexOf('-')+1).trim();\n         } else {\n-            value = trimmed;\n+            if (trimmed.contains(\":\") && !trimmed.endsWith(\":\")) {\n+                value = trimmed.substring(trimmed.indexOf(\":\") + 1).trim();\n+            } else if (trimmed.startsWith(\"-\") && trimmed.length() > 1) {\n+                value = trimmed.substring(trimmed.indexOf('-') + 1).trim();\n+            } else {\n+                value = trimmed;\n+            }\n         }\n         if(\"null\".equals(value)) {\n             return null;\n@@ -125,4 +129,16 @@\n\n     * @param dashLine Line.\n     * @return True of false.\n     */\n+    private boolean escapedSequenceScalar(final YamlLine dashLine) {\n+        final String trimmed = dashLine.trimmed();\n+        return trimmed.matches(\"^[ ]*\\\\-[ ]*\\\".*\\\"$\")\n+            || trimmed.matches(\"^[ ]*\\\\-[ ]*\\'.*\\'$\");\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadYamlSequence.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadYamlSequence.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/ReadYamlSequence.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/ReadYamlSequence.java\n@@ -150,7 +150,7 @@ public Collection<YamlNode> values() {\n                         )\n                     );\n                 } else {\n-                    if(trimmed.matches(\"^.*\\\\-.*\\\\:.*$\")) {\n+                    if(this.mappingStartsAtDash(line)) {\n                         kids.add(\n                             new ReadYamlMapping(\n                                 new RtYamlLine(\"\", line.number()-1),\n@@ -202,4 +202,16 @@\n      * @param dashLine Line.\n      * @return True of false.\n      */\n+    private boolean mappingStartsAtDash(final YamlLine dashLine) {\n+        final String trimmed = dashLine.trimmed();\n+        final boolean escapedScalar = trimmed.matches(\"^[ ]*\\\\-[ ]*\\\".*\\\"$\")\n+            || trimmed.matches(\"^[ ]*\\\\-[ ]*\\'.*\\'$\");\n+        return trimmed.matches(\"^.*\\\\-.*\\\\:.*$\") && !escapedScalar;\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/RtYamlPrinter.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/RtYamlPrinter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/RtYamlPrinter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/RtYamlPrinter.java\n@@ -346,7 +346,7 @@ static class Escaped extends BaseScalar {\n         /**\n          * Special chars that need escaping.\n          */\n-        private final String RESERVED = \"#:->|$%&\";\n+        private final String RESERVED = \"#:->|$%&{}[]\";\n \n         /**\n          * Original unescaped scalar.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java\n@@ -77,7 +77,7 @@ public Iterator<YamlLine> iterator() {\n             final YamlLine first = iterator.next();\n             sameIndentation.add(first);\n             int firstIndentation = first.indentation();\n-            if(first.trimmed().matches(\"^[ ]*\\\\-.*\\\\:.+$\")) {\n+            if(this.mappingStartsAtDash(first)) {\n                 firstIndentation += 2;\n             }\n             while (iterator.hasNext()) {\n@@ -106,4 +106,17 @@ public YamlNode toYamlNode(\n      * @param dashLine Line.\n      * @return True of false.\n      */\n+    private boolean mappingStartsAtDash(final YamlLine dashLine) {\n+        final String trimmed = dashLine.trimmed();\n+        final boolean escapedScalar = trimmed.matches(\"^[ ]*\\\\-[ ]*\\\".*\\\"$\")\n+            || trimmed.matches(\"^[ ]*\\\\-[ ]*\\'.*\\'$\");\n+        return trimmed.matches(\"^[ ]*\\\\-.*\\\\:.+$\") && !escapedScalar;\n+    }\n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/AllYamlLines.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/AllYamlLines.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/AllYamlLines.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/AllYamlLines.java\n@@ -110,10 +110,10 @@\n             line -> line.trimmed().startsWith(\"%\"),\n             line -> line.trimmed().startsWith(\"!!\")\n         ).iterator().next();\n-        if(first.trimmed().startsWith(\"-\")) {\n-            node = new ReadYamlSequence(prev, this);\n-        } else if (first.trimmed().contains(\":\")){\n+        if(first.trimmed().contains(\":\")) {\n             node = new ReadYamlMapping(prev, this);\n+        } else if (first.trimmed().startsWith(\"-\")){\n+            node = new ReadYamlSequence(prev, this);\n         } else if(this.original().size() == 1) {\n             node = new ReadPlainScalar(this, first);\n         } else {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadPlainScalar.java\n@@ -70,10 +70,10 @@\n         final String value;\n         final String trimmed = this.scalar.trimmed();\n-        if(trimmed.startsWith(\"-\") && trimmed.length() > 1) {\n-            value = trimmed.substring(trimmed.indexOf('-')+1).trim();\n-        } else if(trimmed.contains(\":\") && !trimmed.endsWith(\":\")) {\n+        if(trimmed.contains(\":\") && !trimmed.endsWith(\":\")) {\n             value = trimmed.substring(trimmed.indexOf(\":\") + 1).trim();\n+        } else if(trimmed.startsWith(\"-\") && trimmed.length() > 1) {\n+            value = trimmed.substring(trimmed.indexOf('-')+1).trim();\n         } else {\n             value = trimmed;\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java\n@@ -119,8 +119,15 @@\n                         + \"[\" + line.trimmed() + \"].\"\n                     );\n                 }\n-                final String key = trimmed.substring(\n-                        0, trimmed.indexOf(\":\")).trim();\n+                final String key;\n+                if(trimmed.startsWith(\"-\")) {\n+                    key = trimmed.substring(\n+                        1, trimmed.indexOf(\":\")\n+                    ).trim();\n+                } else {\n+                    key = trimmed.substring(\n+                        0, trimmed.indexOf(\":\")\n+                    ).trim();                }\n                 if(!key.isEmpty()) {\n                     keys.add(new PlainStringScalar(key));\n                 }\n@@ -196,7 +203,8 @@ private YamlNode valueOfStringKey(final String key) {\n                     || trimmed.matches(\"^\" + tryKey + \"\\\\:[ ]*\\\\|$\")\n                 ) {\n                     value = this.significant.toYamlNode(line);\n-                } else if(trimmed.startsWith(tryKey + \":\")\n+                } else if((trimmed.startsWith(tryKey + \":\")\n+                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                     && trimmed.length() > 1\n                 ) {\n                     value = new ReadPlainScalar(this.all, line);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/SameIndentationLevel.java\n@@ -76,11 +76,15 @@ public Iterator<YamlLine> iterator() {\n             final List<YamlLine> sameIndentation = new ArrayList<>();\n             final YamlLine first = iterator.next();\n             sameIndentation.add(first);\n+            int firstIndentation = first.indentation();\n+            if(first.trimmed().matches(\"^[ ]*\\\\-.*\\\\:.*$\")) {\n+                firstIndentation += 2;\n+            }\n             while (iterator.hasNext()) {\n                 YamlLine current = iterator.next();\n-                if(current.indentation() == first.indentation()) {\n+                if(current.indentation() == firstIndentation) {\n                     sameIndentation.add(current);\n-                } else if (current.indentation() < first.indentation()) {\n+                } else if (current.indentation() < firstIndentation) {\n                     break;\n                 }\n             }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/WellIndented.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/WellIndented.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/WellIndented.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/WellIndented.java\n@@ -102,7 +102,7 @@ public Iterator<YamlLine> iterator() {\n                 YamlLine line = iterator.next();\n                 if(!(previous instanceof YamlLine.NullYamlLine)) {\n                     int prevIndent = previous.indentation();\n-                    if(previous.trimmed().matches(\"^[ ]*\\\\-.*\\\\:$\")) {\n+                    if(previous.trimmed().matches(\"^[ ]*\\\\-.*\\\\:.*$\")) {\n                         prevIndent += 2;\n                     }\n                     int lineIndent = line.indentation();",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-15",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.amihaiemil.eoyaml.FirstCommentFoundTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : an empty iterable\n     but: [<# second map>]",
                "methodName": "noFirstComment"
            }
        ],
        "metrics": {
            "chunks": 4,
            "classes": 1,
            "files": 1,
            "linesAdd": 6,
            "linesMod": 0,
            "linesRem": 12,
            "methods": 1,
            "sizeInLines": 6
        },
        "program": "RegressionBug-15",
        "project": "RegressionBug-15",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java\n@@ -37,17 +37,12 @@\n  * @since 4.2.0\n  */\n final class FirstCommentFound implements YamlLines {\n \n-    private boolean enteredComments;\n\n      * Lines where we look for the comment.\n      */\n     private final YamlLines lines;\n@@ -116,23 +111,18 @@\n      * @return Iterator of YamlLine.\n      */\n     private Iterator<YamlLine> nodeComment() {\n-        enteredComments = false;\n         Iterator<YamlLine> iterator = this.lines.iterator();\n         final List<YamlLine> comment = new ArrayList<>();\n         while (iterator.hasNext()) {\n             final YamlLine line = iterator.next();\n             boolean hasComment = !line.comment().isEmpty();\n-            if (enteredComments && !hasComment) {\n-                break;\n-            } else {\n-                if (hasComment) {\n-                    enteredComments = true;\n-                    if (!\"---\".equals(line.trimmed())) {\n-                        if (line.trimmed().startsWith(\"#\")) {\n-                            comment.add(line);\n-                        }\n-                    }\n+            boolean notYamlStart = !\"---\".equals(line.trimmed());\n+            if(notYamlStart && hasComment) {\n+                if(line.trimmed().startsWith(\"#\")) {\n+                    comment.add(line);\n                 }\n+            } else {\n+                break;\n             }\n         }\n         iterator = comment.iterator(); ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java\n@@ -37,11 +37,13 @@ final class FirstCommentFound implements YamlLines {\n  * @version $Id: 0929a694a74fe52647a310a8361ade46a2a04e23 $\n  * @since 4.2.0\n  */\n final class FirstCommentFound implements YamlLines {\n \n+    boolean enteredComments = false;\n\n     /**\n      * Lines where we look for the comment.\n      */\n@@ -115,12 +117,18 @@\n         final List<YamlLine> comment = new ArrayList<>();\n         while (iterator.hasNext()) {\n             final YamlLine line = iterator.next();\n-            if(!\"---\".equals(line.trimmed()) && !line.comment().isEmpty()) {\n-                if(line.trimmed().startsWith(\"#\")) {\n-                    comment.add(line);\n-                }\n-            } else {\n+            boolean hasComment = !line.comment().isEmpty();\n+            if (enteredComments && !hasComment) {\n                 break;\n+            } else {\n+                if (hasComment) {\n+                    enteredComments = true;\n+                    if (!\"---\".equals(line.trimmed())) {\n+                        if (line.trimmed().startsWith(\"#\")) {\n+                            comment.add(line);\n+                        }\n+                    }\n+                }\n             }\n         }\n         iterator = comment.iterator();",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-16",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "io.github.classgraph.issues.issue407.Issue407Test",
                "error": "java.lang.AssertionError",
                "message": ": \n\nExpecting:\n <[\"com.google.thirdparty.publicsuffix.PublicSuffixType\"]>\nto contain:\n <[\"com.google.thirdparty.publicsuffix.PublicSuffixPatterns\"]>\nbut could not find:\n <[\"com.google.thirdparty.publicsuffix.PublicSuffixPatterns\"]>",
                "methodName": "issue407Test"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 7,
            "linesMod": 1,
            "linesRem": 2,
            "methods": 1,
            "sizeInLines": 8
        },
        "program": "RegressionBug-16",
        "project": "RegressionBug-16",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "condBranRem",
            "loopAdd",
            "assignRem",
            "condBranIfAdd",
            "exThrowsAdd",
            "objInstAdd",
            "mcRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/nonapi/io/github/classgraph/fileslice/reader/ClassfileReader.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/nonapi/io/github/classgraph/fileslice/reader/ClassfileReader.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/nonapi/io/github/classgraph/fileslice/reader/ClassfileReader.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/nonapi/io/github/classgraph/fileslice/reader/ClassfileReader.java\n@@ -178,13 +178,17 @@\n                 maxArrLen);\n \n         // Double the size of the array if it's too small to contain the new chunk of bytes\n-        if (arr.length < maxNewArrUsed) {\n-            arr = Arrays.copyOf(arr, (int) Math.min(arr.length * 2L, maxArrLen));\n+        long newArrLength = arr.length;\n+        while (newArrLength < maxNewArrUsed) {\n+            newArrLength = Math.min(maxNewArrUsed, newArrLength * 2L);\n         }\n+        if (newArrLength > FileUtils.MAX_BUFFER_SIZE) {\n+            throw new IOException(\"Hit 2GB limit while trying to grow buffer array\");\n+        }\n+        arr = Arrays.copyOf(arr, (int) Math.min(newArrLength, maxArrLen));\n \n\n-        final int maxBytesToRead = Math.min(maxNewArrUsed - arrUsed, arr.length - arrUsed);\n+        final int maxBytesToRead = arr.length - arrUsed;\n \n         // Read a new chunk into the buffer, starting at position arrUsed\n         if (inflaterInputStream != null) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/io/github/classgraph/Classfile.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/io/github/classgraph/Classfile.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/io/github/classgraph/Classfile.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/io/github/classgraph/Classfile.java\n@@ -55,8 +55,8 @@\n  * sequence, to avoid re-allocating buffer memory.\n  */\n class Classfile {\n-    /** The InputStream or ByteBuffer for the current classfile. */\n-    private InputStreamOrByteBufferAdapter inputStreamOrByteBuffer;\n+    /** The {@link ClassfileReader} for the current classfile. */\n+    private ClassfileReader reader;\n \n     /** The classpath element that contains this classfile. */\n     private final ClasspathElement classpathElement;\n@@ -654,9 +654,15 @@\n     private String getConstantPoolString(final int cpIdx, final boolean replaceSlashWithDot,\n             final boolean stripLSemicolon) throws ClassfileFormatException, IOException {\n         final int constantPoolStringOffset = getConstantPoolStringOffset(cpIdx, /* subFieldIdx = */ 0);\n-        return constantPoolStringOffset == 0 ? null\n-                : intern(inputStreamOrByteBuffer.readString(constantPoolStringOffset, replaceSlashWithDot,\n-                        stripLSemicolon));\n+        if (constantPoolStringOffset == 0) {\n+            return null;\n+        }\n+        final int utfLen = reader.readUnsignedShort(constantPoolStringOffset);\n+        if (utfLen == 0) {\n+            return \"\";\n+        }\n+        return intern(\n+                reader.readString(constantPoolStringOffset + 2, utfLen, replaceSlashWithDot, stripLSemicolon));\n     }\n \n     /**\n@@ -676,9 +682,15 @@\n     private String getConstantPoolString(final int cpIdx, final int subFieldIdx)\n             throws ClassfileFormatException, IOException {\n         final int constantPoolStringOffset = getConstantPoolStringOffset(cpIdx, subFieldIdx);\n-        return constantPoolStringOffset == 0 ? null\n-                : intern(inputStreamOrByteBuffer.readString(constantPoolStringOffset,\n-                        /* replaceSlashWithDot = */ false, /* stripLSemicolon = */ false));\n+        if (constantPoolStringOffset == 0) {\n+            return null;\n+        }\n+        final int utfLen = reader.readUnsignedShort(constantPoolStringOffset);\n+        if (utfLen == 0) {\n+            return \"\";\n+        }\n+        return intern(reader.readString(constantPoolStringOffset + 2, utfLen, /* replaceSlashWithDot = */ false,\n+                /* stripLSemicolon = */ false));\n     }\n \n     /**\n@@ -765,22 +777,24 @@\n      * @throws IOException\n      *             If an IO exception occurs.\n      */\n-    private boolean constantPoolStringEquals(final int cpIdx, final String asciiString)\n+    private boolean constantPoolStringEquals(final int cpIdx, final String asciiStr)\n             throws ClassfileFormatException, IOException {\n-        final int strOffset = getConstantPoolStringOffset(cpIdx, /* subFieldIdx = */ 0);\n-        if (strOffset == 0) {\n-            return asciiString == null;\n-        } else if (asciiString == null) {\n+        final int cpStrOffset = getConstantPoolStringOffset(cpIdx, /* subFieldIdx = */ 0);\n+        if (cpStrOffset == 0) {\n+            return asciiStr == null;\n+        } else if (asciiStr == null) {\n             return false;\n         }\n-        final int strLen = inputStreamOrByteBuffer.readUnsignedShort(strOffset);\n-        final int otherLen = asciiString.length();\n-        if (strLen != otherLen) {\n+        final int cpStrLen = reader.readUnsignedShort(cpStrOffset);\n+        final int asciiStrLen = asciiStr.length();\n+        if (cpStrLen != asciiStrLen) {\n             return false;\n         }\n-        final int strStart = strOffset + 2;\n-        for (int i = 0; i < strLen; i++) {\n-            if ((char) (inputStreamOrByteBuffer.buf[strStart + i] & 0xff) != asciiString.charAt(i)) {\n+        final int cpStrStart = cpStrOffset + 2;\n+        reader.bufferTo(cpStrStart + cpStrLen);\n+        final byte[] buf = reader.buf();\n+        for (int i = 0; i < cpStrLen; i++) {\n+            if ((char) (buf[cpStrStart + i] & 0xff) != asciiStr.charAt(i)) {\n                 return false;\n             }\n         }\n@@ -1005,7 +1016,7 @@\n         }\n \n         // Read size of constant pool\n-        cpCount = inputStreamOrByteBuffer.readUnsignedShort();\n+        cpCount = reader.readUnsignedShort();\n \n         // Allocate storage for constant pool\n         entryOffset = new int[cpCount];\n@@ -1020,29 +1031,29 @@\n                 skipSlot = 0;\n                 continue;\n             }\n-            entryTag[i] = inputStreamOrByteBuffer.readUnsignedByte();\n-            entryOffset[i] = inputStreamOrByteBuffer.curr;\n+            entryTag[i] = reader.readUnsignedByte();\n+            entryOffset[i] = reader.currPos();\n             switch (entryTag[i]) {\n             case 0: // Impossible, probably buffer underflow\n                 throw new ClassfileFormatException(\"Unknown constant pool tag 0 in classfile \" + relativePath\n                         + \" (possible buffer underflow issue). Please report this at \"\n                         + \"https://github.com/classgraph/classgraph/issues\");\n             case 1: // Modified UTF8\n-                final int strLen = inputStreamOrByteBuffer.readUnsignedShort();\n-                inputStreamOrByteBuffer.skip(strLen);\n+                final int strLen = reader.readUnsignedShort();\n+                reader.skip(strLen);\n                 break;\n             case 3: // int, short, char, byte, boolean are all represented by Constant_INTEGER\n             case 4: // float\n-                inputStreamOrByteBuffer.skip(4);\n+                reader.skip(4);\n                 break;\n             case 5: // long\n             case 6: // double\n-                inputStreamOrByteBuffer.skip(8);\n+                reader.skip(8);\n                 skipSlot = 1; // double slot\n                 break;\n             case 7: // Class reference (format is e.g. \"java/lang/String\")\n                 // Forward or backward indirect reference to a modified UTF8 entry\n-                indirectStringRefs[i] = inputStreamOrByteBuffer.readUnsignedShort();\n+                indirectStringRefs[i] = reader.readUnsignedShort();\n                 if (classNameCpIdxs != null) {\n                     // If this is a class ref, and inter-class dependencies are enabled, record the dependency\n                     classNameCpIdxs.add(indirectStringRefs[i]);\n@@ -1050,44 +1061,44 @@\n                 break;\n             case 8: // String\n                 // Forward or backward indirect reference to a modified UTF8 entry\n-                indirectStringRefs[i] = inputStreamOrByteBuffer.readUnsignedShort();\n+                indirectStringRefs[i] = reader.readUnsignedShort();\n                 break;\n             case 9: // field ref\n                 // Refers to a class ref (case 7) and then a name and type (case 12)\n-                inputStreamOrByteBuffer.skip(4);\n+                reader.skip(4);\n                 break;\n             case 10: // method ref\n                 // Refers to a class ref (case 7) and then a name and type (case 12)\n-                inputStreamOrByteBuffer.skip(4);\n+                reader.skip(4);\n                 break;\n             case 11: // interface method ref\n                 // Refers to a class ref (case 7) and then a name and type (case 12)\n-                inputStreamOrByteBuffer.skip(4);\n+                reader.skip(4);\n                 break;\n             case 12: // name and type\n-                final int nameRef = inputStreamOrByteBuffer.readUnsignedShort();\n-                final int typeRef = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int nameRef = reader.readUnsignedShort();\n+                final int typeRef = reader.readUnsignedShort();\n                 if (typeSignatureIdxs != null) {\n                     typeSignatureIdxs.add(typeRef);\n                 }\n                 indirectStringRefs[i] = (nameRef << 16) | typeRef;\n                 break;\n             case 15: // method handle\n-                inputStreamOrByteBuffer.skip(3);\n+                reader.skip(3);\n                 break;\n             case 16: // method type\n-                inputStreamOrByteBuffer.skip(2);\n+                reader.skip(2);\n                 break;\n             case 18: // invoke dynamic\n-                inputStreamOrByteBuffer.skip(4);\n+                reader.skip(4);\n                 break;\n             case 19: // module (for module-info.class in JDK9+)\n                 // see https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\n-                indirectStringRefs[i] = inputStreamOrByteBuffer.readUnsignedShort();\n+                indirectStringRefs[i] = reader.readUnsignedShort();\n                 break;\n             case 20: // package (for module-info.class in JDK9+)\n                 // see https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\n-                inputStreamOrByteBuffer.skip(2);\n+                reader.skip(2);\n                 break;\n             default:\n                 throw new ClassfileFormatException(\"Unknown constant pool tag \" + entryTag[i]\n@@ -1166,13 +1177,13 @@\n      */\n     private void readBasicClassInfo() throws IOException, ClassfileFormatException, SkipClassException {\n         // Modifier flags\n-        classModifiers = inputStreamOrByteBuffer.readUnsignedShort();\n+        classModifiers = reader.readUnsignedShort();\n \n         isInterface = (classModifiers & 0x0200) != 0;\n         isAnnotation = (classModifiers & 0x2000) != 0;\n \n         // The fully-qualified class name of this class, with slashes replaced with dots\n-        final String classNamePath = getConstantPoolString(inputStreamOrByteBuffer.readUnsignedShort());\n+        final String classNamePath = getConstantPoolString(reader.readUnsignedShort());\n         if (classNamePath == null) {\n             throw new ClassfileFormatException(\"Class name is null\");\n         }\n@@ -1203,7 +1214,7 @@\n         }\n \n         // Superclass name, with slashes replaced with dots\n-        final int superclassNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+        final int superclassNameCpIdx = reader.readUnsignedShort();\n         if (superclassNameCpIdx > 0) {\n             superclassName = getConstantPoolClassName(superclassNameCpIdx);\n         }\n@@ -1219,9 +1230,9 @@\n      */\n     private void readInterfaces() throws IOException {\n         // Interfaces\n-        final int interfaceCount = inputStreamOrByteBuffer.readUnsignedShort();\n+        final int interfaceCount = reader.readUnsignedShort();\n         for (int i = 0; i < interfaceCount; i++) {\n-            final String interfaceName = getConstantPoolClassName(inputStreamOrByteBuffer.readUnsignedShort());\n+            final String interfaceName = getConstantPoolClassName(reader.readUnsignedShort());\n             if (implementedInterfaces == null) {\n                 implementedInterfaces = new ArrayList<>();\n             }\n@@ -1241,28 +1252,28 @@\n      */\n     private void readFields() throws IOException, ClassfileFormatException {\n         // Fields\n-        final int fieldCount = inputStreamOrByteBuffer.readUnsignedShort();\n+        final int fieldCount = reader.readUnsignedShort();\n         for (int i = 0; i < fieldCount; i++) {\n             // Info on modifier flags: http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.5\n-            final int fieldModifierFlags = inputStreamOrByteBuffer.readUnsignedShort();\n+            final int fieldModifierFlags = reader.readUnsignedShort();\n             final boolean isPublicField = ((fieldModifierFlags & 0x0001) == 0x0001);\n             final boolean fieldIsVisible = isPublicField || scanSpec.ignoreFieldVisibility;\n             final boolean getStaticFinalFieldConstValue = scanSpec.enableStaticFinalFieldConstantInitializerValues\n                     && fieldIsVisible;\n             if (!fieldIsVisible || (!scanSpec.enableFieldInfo && !getStaticFinalFieldConstValue)) {\n                 // Skip field\n-                inputStreamOrByteBuffer.readUnsignedShort(); // fieldNameCpIdx\n-                inputStreamOrByteBuffer.readUnsignedShort(); // fieldTypeDescriptorCpIdx\n-                final int attributesCount = inputStreamOrByteBuffer.readUnsignedShort();\n+                reader.readUnsignedShort(); // fieldNameCpIdx\n+                reader.readUnsignedShort(); // fieldTypeDescriptorCpIdx\n+                final int attributesCount = reader.readUnsignedShort();\n                 for (int j = 0; j < attributesCount; j++) {\n-                    inputStreamOrByteBuffer.readUnsignedShort(); // attributeNameCpIdx\n-                    final int attributeLength = inputStreamOrByteBuffer.readInt(); // == 2\n-                    inputStreamOrByteBuffer.skip(attributeLength);\n+                    reader.readUnsignedShort(); // attributeNameCpIdx\n+                    final int attributeLength = reader.readInt(); // == 2\n+                    reader.skip(attributeLength);\n                 }\n             } else {\n-                final int fieldNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int fieldNameCpIdx = reader.readUnsignedShort();\n                 final String fieldName = getConstantPoolString(fieldNameCpIdx);\n-                final int fieldTypeDescriptorCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int fieldTypeDescriptorCpIdx = reader.readUnsignedShort();\n                 final char fieldTypeDescriptorFirstChar = (char) getConstantPoolStringFirstByte(\n                         fieldTypeDescriptorCpIdx);\n                 String fieldTypeDescriptor;\n@@ -1271,16 +1282,16 @@\n \n                 Object fieldConstValue = null;\n                 AnnotationInfoList fieldAnnotationInfo = null;\n-                final int attributesCount = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int attributesCount = reader.readUnsignedShort();\n                 for (int j = 0; j < attributesCount; j++) {\n-                    final int attributeNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n-                    final int attributeLength = inputStreamOrByteBuffer.readInt(); // == 2\n+                    final int attributeNameCpIdx = reader.readUnsignedShort();\n+                    final int attributeLength = reader.readInt(); // == 2\n                     // See if field name matches one of the requested names for this class, and if it does,\n                     // check if it is initialized with a constant value\n                     if ((getStaticFinalFieldConstValue)\n                             && constantPoolStringEquals(attributeNameCpIdx, \"ConstantValue\")) {\n                         // http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.2\n-                        final int cpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                        final int cpIdx = reader.readUnsignedShort();\n                         if (cpIdx < 1 || cpIdx >= cpCount) {\n                             throw new ClassfileFormatException(\"Constant pool index \" + cpIdx\n                                     + \", should be in range [1, \" + (cpCount - 1)\n@@ -1290,13 +1301,13 @@\n                         fieldConstValue = getFieldConstantPoolValue(entryTag[cpIdx], fieldTypeDescriptorFirstChar,\n                                 cpIdx);\n                     } else if (fieldIsVisible && constantPoolStringEquals(attributeNameCpIdx, \"Signature\")) {\n-                        fieldTypeSignature = getConstantPoolString(inputStreamOrByteBuffer.readUnsignedShort());\n+                        fieldTypeSignature = getConstantPoolString(reader.readUnsignedShort());\n                     } else if (scanSpec.enableAnnotationInfo //\n                             && (constantPoolStringEquals(attributeNameCpIdx, \"RuntimeVisibleAnnotations\")\n                                     || (!scanSpec.disableRuntimeInvisibleAnnotations && constantPoolStringEquals(\n                                             attributeNameCpIdx, \"RuntimeInvisibleAnnotations\")))) {\n                         // Read annotation names\n-                        final int fieldAnnotationCount = inputStreamOrByteBuffer.readUnsignedShort();\n+                        final int fieldAnnotationCount = reader.readUnsignedShort();\n                         if (fieldAnnotationCount > 0) {\n                             if (fieldAnnotationInfo == null) {\n                                 fieldAnnotationInfo = new AnnotationInfoList(1);\n@@ -1308,7 +1319,7 @@\n                         }\n                     } else {\n                         // No match, just skip attribute\n-                        inputStreamOrByteBuffer.skip(attributeLength);\n+                        reader.skip(attributeLength);\n                     }\n                 }\n                 if (scanSpec.enableFieldInfo && fieldIsVisible) {\n@@ -1334,10 +1345,10 @@\n      */\n     private void readMethods() throws IOException, ClassfileFormatException {\n         // Methods\n-        final int methodCount = inputStreamOrByteBuffer.readUnsignedShort();\n+        final int methodCount = reader.readUnsignedShort();\n         for (int i = 0; i < methodCount; i++) {\n             // Info on modifier flags: http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6\n-            final int methodModifierFlags = inputStreamOrByteBuffer.readUnsignedShort();\n+            final int methodModifierFlags = reader.readUnsignedShort();\n             final boolean isPublicMethod = ((methodModifierFlags & 0x0001) == 0x0001);\n             final boolean methodIsVisible = isPublicMethod || scanSpec.ignoreMethodVisibility;\n \n@@ -1347,14 +1358,14 @@\n             // Always enable MethodInfo for annotations (this is how annotation constants are defined)\n             final boolean enableMethodInfo = scanSpec.enableMethodInfo || isAnnotation;\n             if (enableMethodInfo || isAnnotation) { // Annotations store defaults in method_info\n-                final int methodNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int methodNameCpIdx = reader.readUnsignedShort();\n                 methodName = getConstantPoolString(methodNameCpIdx);\n-                final int methodTypeDescriptorCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int methodTypeDescriptorCpIdx = reader.readUnsignedShort();\n                 methodTypeDescriptor = getConstantPoolString(methodTypeDescriptorCpIdx);\n             } else {\n-                inputStreamOrByteBuffer.skip(4); // name_index, descriptor_index\n+                reader.skip(4); // name_index, descriptor_index\n             }\n-            final int attributesCount = inputStreamOrByteBuffer.readUnsignedShort();\n+            final int attributesCount = reader.readUnsignedShort();\n             String[] methodParameterNames = null;\n             int[] methodParameterModifiers = null;\n             AnnotationInfo[][] methodParameterAnnotations = null;\n@@ -1363,20 +1374,20 @@\n             if (!methodIsVisible || (!enableMethodInfo && !isAnnotation)) {\n                 // Skip method attributes\n                 for (int j = 0; j < attributesCount; j++) {\n-                    inputStreamOrByteBuffer.skip(2); // attribute_name_index\n-                    final int attributeLength = inputStreamOrByteBuffer.readInt();\n-                    inputStreamOrByteBuffer.skip(attributeLength);\n+                    reader.skip(2); // attribute_name_index\n+                    final int attributeLength = reader.readInt();\n+                    reader.skip(attributeLength);\n                 }\n             } else {\n                 // Look for method annotations\n                 for (int j = 0; j < attributesCount; j++) {\n-                    final int attributeNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n-                    final int attributeLength = inputStreamOrByteBuffer.readInt();\n+                    final int attributeNameCpIdx = reader.readUnsignedShort();\n+                    final int attributeLength = reader.readInt();\n                     if (scanSpec.enableAnnotationInfo\n                             && (constantPoolStringEquals(attributeNameCpIdx, \"RuntimeVisibleAnnotations\")\n                                     || (!scanSpec.disableRuntimeInvisibleAnnotations && constantPoolStringEquals(\n                                             attributeNameCpIdx, \"RuntimeInvisibleAnnotations\")))) {\n-                        final int methodAnnotationCount = inputStreamOrByteBuffer.readUnsignedShort();\n+                        final int methodAnnotationCount = reader.readUnsignedShort();\n                         if (methodAnnotationCount > 0) {\n                             if (methodAnnotationInfo == null) {\n                                 methodAnnotationInfo = new AnnotationInfoList(1);\n@@ -1395,7 +1406,7 @@\n                         // annotations are given in separate attributes, so if both attributes are present,\n                         // have to make the parameter annotation arrays larger when the second attribute is\n                         // encountered).\n-                        final int numParams = inputStreamOrByteBuffer.readUnsignedByte();\n+                        final int numParams = reader.readUnsignedByte();\n                         if (methodParameterAnnotations == null) {\n                             methodParameterAnnotations = new AnnotationInfo[numParams][];\n                         } else if (methodParameterAnnotations.length != numParams) {\n@@ -1404,7 +1415,7 @@\n                                             + \"and RuntimeInvisibleParameterAnnotations\");\n                         }\n                         for (int paramIdx = 0; paramIdx < numParams; paramIdx++) {\n-                            final int numAnnotations = inputStreamOrByteBuffer.readUnsignedShort();\n+                            final int numAnnotations = reader.readUnsignedShort();\n                             if (numAnnotations > 0) {\n                                 int annStartIdx = 0;\n                                 if (methodParameterAnnotations[paramIdx] != null) {\n@@ -1424,18 +1435,18 @@\n                     } else if (constantPoolStringEquals(attributeNameCpIdx, \"MethodParameters\")) {\n                         // Read method parameters. For Java, these are only produced in JDK8+, and only if the\n                         // commandline switch `-parameters` is provided at compiletime.\n-                        final int paramCount = inputStreamOrByteBuffer.readUnsignedByte();\n+                        final int paramCount = reader.readUnsignedByte();\n                         methodParameterNames = new String[paramCount];\n                         methodParameterModifiers = new int[paramCount];\n                         for (int k = 0; k < paramCount; k++) {\n-                            final int cpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                            final int cpIdx = reader.readUnsignedShort();\n                             // If the constant pool index is zero, then the parameter is unnamed => use null\n                             methodParameterNames[k] = cpIdx == 0 ? null : getConstantPoolString(cpIdx);\n-                            methodParameterModifiers[k] = inputStreamOrByteBuffer.readUnsignedShort();\n+                            methodParameterModifiers[k] = reader.readUnsignedShort();\n                         }\n                     } else if (constantPoolStringEquals(attributeNameCpIdx, \"Signature\")) {\n                         // Add type params to method type signature\n-                        methodTypeSignature = getConstantPoolString(inputStreamOrByteBuffer.readUnsignedShort());\n+                        methodTypeSignature = getConstantPoolString(reader.readUnsignedShort());\n                     } else if (constantPoolStringEquals(attributeNameCpIdx, \"AnnotationDefault\")) {\n                         if (annotationParamDefaultValues == null) {\n                             annotationParamDefaultValues = new AnnotationParameterValueList();\n@@ -1445,9 +1456,9 @@\n                                 readAnnotationElementValue()));\n                     } else if (constantPoolStringEquals(attributeNameCpIdx, \"Code\")) {\n                         methodHasBody = true;\n-                        inputStreamOrByteBuffer.skip(attributeLength);\n+                        reader.skip(attributeLength);\n                     } else {\n-                        inputStreamOrByteBuffer.skip(attributeLength);\n+                        reader.skip(attributeLength);\n                     }\n                 }\n                 // Create MethodInfo\n@@ -1475,15 +1486,15 @@\n      */\n     private void readClassAttributes() throws IOException, ClassfileFormatException {\n         // Class attributes (including class annotations, class type variables, module info, etc.)\n-        final int attributesCount = inputStreamOrByteBuffer.readUnsignedShort();\n+        final int attributesCount = reader.readUnsignedShort();\n         for (int i = 0; i < attributesCount; i++) {\n-            final int attributeNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n-            final int attributeLength = inputStreamOrByteBuffer.readInt();\n+            final int attributeNameCpIdx = reader.readUnsignedShort();\n+            final int attributeLength = reader.readInt();\n             if (scanSpec.enableAnnotationInfo //\n                     && (constantPoolStringEquals(attributeNameCpIdx, \"RuntimeVisibleAnnotations\")\n                             || (!scanSpec.disableRuntimeInvisibleAnnotations && constantPoolStringEquals(\n                                     attributeNameCpIdx, \"RuntimeInvisibleAnnotations\")))) {\n-                final int annotationCount = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int annotationCount = reader.readUnsignedShort();\n                 if (annotationCount > 0) {\n                     if (classAnnotations == null) {\n                         classAnnotations = new AnnotationInfoList();\n@@ -1493,12 +1504,12 @@\n                     }\n                 }\n             } else if (constantPoolStringEquals(attributeNameCpIdx, \"InnerClasses\")) {\n-                final int numInnerClasses = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int numInnerClasses = reader.readUnsignedShort();\n                 for (int j = 0; j < numInnerClasses; j++) {\n-                    final int innerClassInfoCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n-                    final int outerClassInfoCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n-                    inputStreamOrByteBuffer.skip(2); // inner_name_idx\n-                    final int innerClassAccessFlags = inputStreamOrByteBuffer.readUnsignedShort();\n+                    final int innerClassInfoCpIdx = reader.readUnsignedShort();\n+                    final int outerClassInfoCpIdx = reader.readUnsignedShort();\n+                    reader.skip(2); // inner_name_idx\n+                    final int innerClassAccessFlags = reader.readUnsignedShort();\n                     if (innerClassInfoCpIdx != 0 && outerClassInfoCpIdx != 0) {\n                         final String innerClassName = getConstantPoolClassName(innerClassInfoCpIdx);\n                         final String outerClassName = getConstantPoolClassName(outerClassInfoCpIdx);\n@@ -1511,11 +1522,10 @@\n                 }\n             } else if (constantPoolStringEquals(attributeNameCpIdx, \"Signature\")) {\n                 // Get class type signature, including type variables\n-                typeSignature = getConstantPoolString(inputStreamOrByteBuffer.readUnsignedShort());\n+                typeSignature = getConstantPoolString(reader.readUnsignedShort());\n             } else if (constantPoolStringEquals(attributeNameCpIdx, \"EnclosingMethod\")) {\n-                final String innermostEnclosingClassName = getConstantPoolClassName(\n-                        inputStreamOrByteBuffer.readUnsignedShort());\n-                final int enclosingMethodCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                final String innermostEnclosingClassName = getConstantPoolClassName(reader.readUnsignedShort());\n+                final int enclosingMethodCpIdx = reader.readUnsignedShort();\n                 String definingMethodName;\n                 if (enclosingMethodCpIdx == 0) {\n                     // A cpIdx of 0 (which is an invalid value) is used for anonymous inner classes declared in\n@@ -1535,13 +1545,13 @@\n                 // class\n                 this.fullyQualifiedDefiningMethodName = innermostEnclosingClassName + \".\" + definingMethodName;\n             } else if (constantPoolStringEquals(attributeNameCpIdx, \"Module\")) {\n-                final int moduleNameCpIdx = inputStreamOrByteBuffer.readUnsignedShort();\n+                final int moduleNameCpIdx = reader.readUnsignedShort();\n                 classpathElement.moduleNameFromModuleDescriptor = getConstantPoolString(moduleNameCpIdx);\n                 // (Future work): parse the rest of the module descriptor fields, and add to ModuleInfo:\n                 // https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25\n-                inputStreamOrByteBuffer.skip(attributeLength - 2);\n+                reader.skip(attributeLength - 2);\n             } else {\n-                inputStreamOrByteBuffer.skip(attributeLength);\n+                reader.skip(attributeLength);\n             }\n         }\n     }\n@@ -1602,19 +1612,17 @@\n         this.scanSpec = scanSpec;\n \n         try {\n-            // Open classfile as a ByteBuffer or InputStream\n-            inputStreamOrByteBuffer = classfileResource.openOrRead();\n+            // Open a BufferedSequentialReader for the classfile\n+            reader = classfileResource.openClassfile();\n \n             // Check magic number\n-            if (inputStreamOrByteBuffer.readInt() != 0xCAFEBABE) {\n+            if (reader.readInt() != 0xCAFEBABE) {\n                 throw new ClassfileFormatException(\"Classfile does not have correct magic number\");\n             }\n \n-            // Read classfile minor version\n-            inputStreamOrByteBuffer.readUnsignedShort();\n-\n-            // Read classfile major version\n-            inputStreamOrByteBuffer.readUnsignedShort();\n+            // Read classfile minor and major version\n+            reader.readUnsignedShort();\n+            reader.readUnsignedShort();\n \n             // Read the constant pool\n             readConstantPoolEntries();\n@@ -1635,9 +1643,9 @@\n             readClassAttributes();\n \n         } finally {\n-            // Close ByteBuffer or InputStream\n+            // Close BufferedSequentialReader\n             classfileResource.close();\n-            inputStreamOrByteBuffer = null;\n+            reader = null;\n         }\n \n         // Write class info to log \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/io/github/classgraph/ClasspathElementZip.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/io/github/classgraph/ClasspathElementZip.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/io/github/classgraph/ClasspathElementZip.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/io/github/classgraph/ClasspathElementZip.java\n@@ -46,16 +46,15 @@\n import nonapi.io.github.classgraph.classpath.ClasspathOrder.ClasspathElementAndClassLoader;\n import nonapi.io.github.classgraph.concurrency.SingletonMap.NullSingletonException;\n import nonapi.io.github.classgraph.concurrency.WorkQueue;\n-import nonapi.io.github.classgraph.fastzipfilereader.ByteBufferWrapper;\n import nonapi.io.github.classgraph.fastzipfilereader.FastZipEntry;\n import nonapi.io.github.classgraph.fastzipfilereader.LogicalZipFile;\n import nonapi.io.github.classgraph.fastzipfilereader.NestedJarHandler;\n import nonapi.io.github.classgraph.fastzipfilereader.ZipFileSlice;\n+import nonapi.io.github.classgraph.fileslice.reader.ClassfileReader;\n import nonapi.io.github.classgraph.scanspec.ScanSpec;\n import nonapi.io.github.classgraph.scanspec.ScanSpec.ScanSpecPathMatch;\n import nonapi.io.github.classgraph.utils.FastPathResolver;\n import nonapi.io.github.classgraph.utils.FileUtils;\n-import nonapi.io.github.classgraph.utils.InputStreamOrByteBufferAdapter;\n import nonapi.io.github.classgraph.utils.JarUtils;\n import nonapi.io.github.classgraph.utils.LogNode;\n import nonapi.io.github.classgraph.utils.URLPathEncoder;\n@@ -291,9 +290,6 @@\n      */\n     private Resource newResource(final FastZipEntry zipEntry, final String pathRelativeToPackageRoot) {\n         return new Resource(this, zipEntry.uncompressedSize) {\n-            /** The {@link ByteBufferWrapper}, or null. */\n-            protected ByteBufferWrapper byteBufferWrapper;\n-\n             /**\n              * Path with package root prefix and/or any Spring Boot prefix (\"BOOT-INF/classes/\" or\n              * \"WEB-INF/classes/\") removed.*/\n@@ -360,92 +356,62 @@\n                 }\n                 markAsOpen();\n                 try {\n-                    inputStream = new InputStreamResourceCloser(this, zipEntry.open());\n+                    inputStream = zipEntry.getSlice().open();\n                     length = zipEntry.uncompressedSize;\n                     return inputStream;\n \n                 } catch (final IOException e) {\n                     close();\n                     throw e;\n-                } catch (final InterruptedException e) {\n-                    close();\n-                    nestedJarHandler.interruptionChecker.interrupt();\n-                    throw new IOException(e);\n                 }\n             }\n \n             @Override\n-            synchronized InputStreamOrByteBufferAdapter openOrRead() throws IOException {\n-                return new InputStreamOrByteBufferAdapter(open());\n+            synchronized ClassfileReader openClassfile() throws IOException {\n+                if (skipClasspathElement) {\n+                    // Shouldn't happen\n+                    throw new IOException(\"Jarfile could not be opened\");\n+                }\n+                return new ClassfileReader(open());\n             }\n \n             @Override\n             public synchronized ByteBuffer read() throws IOException {\n+                if (skipClasspathElement) {\n+                    // Shouldn't happen\n+                    throw new IOException(\"Jarfile could not be opened\");\n+                }\n                 try {\n-                    if (zipEntry.canGetAsSlice()) {\n-                        try {\n-                            // For STORED entries that do not span multiple 2GB chunks, can create a\n-                            // ByteBuffer slice directly from the entry\n-                            markAsOpen();\n-                            // compressedSize should have the same value as uncompressedSize for STORED\n-                            // entries, but compressedSize is more reliable (uncompressedSize may be -1)\n-                            length = zipEntry.compressedSize;\n-                            byteBufferWrapper = zipEntry.getAsSlice();\n-                            byteBuffer = byteBufferWrapper.getByteBuffer();\n-                            if (byteBuffer == null) {\n-                                throw new IOException(\n-                                        \"Could not read resource as a ByteBuffer, because memory mapping \"\n-                                                + \"of files was disabled, or an OutOfMemoryError occurred while attempting to \"\n-                                                + \"map files\");\n-                            }\n-                            return byteBuffer;\n-\n-                        } catch (final IOException e) {\n-                            close();\n-                            throw e;\n-                        } catch (final InterruptedException e) {\n-                            close();\n-                            nestedJarHandler.interruptionChecker.interrupt();\n-                            throw new IOException(e);\n-                        }\n-\n-                    } else {\n-                        // Otherwise, decompress or extract the entry into a byte[] array,\n-                        // then wrap in a ByteBuffer\n-                        open();\n-                        return inputStreamToByteBuffer();\n-                    }\n+                    byteBuffer = zipEntry.getSlice().read();\n+                    length = byteBuffer.remaining();\n+                    return byteBuffer;\n                 } catch (final IOException e) {\n                     close();\n                     throw e;\n-                } catch (final InterruptedException e) {\n-                    close();\n-                    nestedJarHandler.interruptionChecker.interrupt();\n-                    throw new IOException(e);\n                 }\n             }\n \n             @Override\n             public synchronized byte[] load() throws IOException {\n+                if (skipClasspathElement) {\n+                    // Shouldn't happen\n+                    throw new IOException(\"Jarfile could not be opened\");\n+                }\n                 try {\n-                    open();\n-                    final byte[] byteArray = inputStreamToByteArray();\n+                    final byte[] byteArray = zipEntry.getSlice().load();\n                     length = byteArray.length;\n                     return byteArray;\n-                } finally {\n+                } catch (final IOException e) {\n                     close();\n+                    throw e;\n                 }\n             }\n \n             @Override\n             public synchronized void close() {\n                 super.close(); // Close inputStream\n-                if (byteBufferWrapper != null) {\n-                    byteBufferWrapper.close(/* log = */ null);\n-                    byteBufferWrapper = null;\n-                    byteBuffer = null;\n-                }\n                 if (byteBuffer != null) {\n+                    // All ByteBuffers should wrap arrays, so they don't need to be cleaned\n                     byteBuffer = null;\n                 }\n                 markAsClosed();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/io/github/classgraph/Resource.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/io/github/classgraph/Resource.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/io/github/classgraph/Resource.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/io/github/classgraph/Resource.java\n@@ -42,8 +42,7 @@\n import java.util.Set;\n import java.util.zip.ZipEntry;\n \n-import nonapi.io.github.classgraph.utils.FileUtils;\n-import nonapi.io.github.classgraph.utils.InputStreamOrByteBufferAdapter;\n+import nonapi.io.github.classgraph.fileslice.reader.ClassfileReader;\n import nonapi.io.github.classgraph.utils.LogNode;\n import nonapi.io.github.classgraph.utils.URLPathEncoder;\n \n@@ -94,202 +93,6 @@\n     // -------------------------------------------------------------------------------------------------------------\n \n     /**\n-     * Create an {@link InputStream} from a {@link ByteBuffer}.\n-     *\n-     * @return the input stream\n-     */\n-    protected InputStream byteBufferToInputStream() {\n-        return inputStream == null ? inputStream = FileUtils.byteBufferToInputStream(byteBuffer) : inputStream;\n-    }\n-\n-    /**\n-     * Create a {@link ByteBuffer} from an {@link InputStream}.\n-     *\n-     * @return the byte buffer\n-     * @throws IOException\n-     *             if an I/O exception occurs.\n-     */\n-    protected ByteBuffer inputStreamToByteBuffer() throws IOException {\n-        return byteBuffer == null ? byteBuffer = ByteBuffer.wrap(inputStreamToByteArray()) : byteBuffer;\n-    }\n-\n-    /**\n-     * Read all bytes from an {@link InputStream} and return as a byte array.\n-     *\n-     * @return the contents of the {@link InputStream}.\n-     * @throws IOException\n-     *             if an I/O exception occurs.\n-     */\n-    protected byte[] inputStreamToByteArray() throws IOException {\n-        return FileUtils.readAllBytesAsArray(inputStream, length);\n-    }\n-\n-    /**\n-     * Read/copy contents of a {@link ByteBuffer} as a byte array.\n-     *\n-     * @return the contents of the {@link ByteBuffer} as a byte array.\n-     */\n-    protected byte[] byteBufferToByteArray() {\n-        if (byteBuffer.hasArray()) {\n-            return byteBuffer.array();\n-        } else {\n-            final byte[] byteArray = new byte[byteBuffer.remaining()];\n-            byteBuffer.get(byteArray);\n-            return byteArray;\n-        }\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n-     * Class for closing the parent {@link Resource} when an {@link InputStream} opened on the resource is closed.\n-     */\n-    protected class InputStreamResourceCloser extends InputStream {\n-\n-        /** The input stream. */\n-        private InputStream inputStream;\n-\n-        /** The parent resource. */\n-        private Resource parentResource;\n-\n-        /**\n-         * Constructor.\n-         *\n-         * @param parentResource\n-         *            the parent resource\n-         * @param inputStream\n-         *            the input stream\n-         * @throws IOException\n-         *             if an I/O exception occurs.\n-         */\n-        protected InputStreamResourceCloser(final Resource parentResource, final InputStream inputStream)\n-                throws IOException {\n-            super();\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream cannot be null\");\n-            }\n-            this.inputStream = inputStream;\n-            this.parentResource = parentResource;\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#read()\n-         */\n-        @Override\n-        public int read() throws IOException {\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream is not open\");\n-            }\n-            return inputStream.read();\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#read(byte[], int, int)\n-         */\n-        @Override\n-        public int read(final byte[] b, final int off, final int len) throws IOException {\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream is not open\");\n-            }\n-            return inputStream.read(b, off, len);\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#read(byte[])\n-         */\n-        @Override\n-        public int read(final byte[] b) throws IOException {\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream is not open\");\n-            }\n-            return inputStream.read(b);\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#available()\n-         */\n-        @Override\n-        public int available() throws IOException {\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream is not open\");\n-            }\n-            return inputStream.available();\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#skip(long)\n-         */\n-        @Override\n-        public long skip(final long n) throws IOException {\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream is not open\");\n-            }\n-            return inputStream.skip(n);\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#markSupported()\n-         */\n-        @Override\n-        public boolean markSupported() {\n-            return inputStream.markSupported();\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#mark(int)\n-         */\n-        @Override\n-        public synchronized void mark(final int readlimit) {\n-            inputStream.mark(readlimit);\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.io.InputStream#reset()\n-         */\n-        @Override\n-        public synchronized void reset() throws IOException {\n-            if (inputStream == null) {\n-                throw new IOException(\"InputStream is not open\");\n-            }\n-            inputStream.reset();\n-        }\n-\n-        /**\n-         * Close the wrapped InputStream, but don't close parent resource.\n-         *\n-         * @throws IOException\n-         *             if an I/O exception occurs.\n-         */\n-        void closeInputStream() throws IOException {\n-            if (inputStream != null) {\n-                try {\n-                    inputStream.close();\n-                } catch (final IOException e) {\n-                    // Ignore\n-                }\n-                inputStream = null;\n-            }\n-        }\n-\n-        /**\n-         * Close the parent resource by calling {@link Resource#close()}, which will call\n-         * {@link #closeInputStream()}.\n-         *\n-         * @throws IOException\n-         *             if an I/O exception occurs.\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (parentResource != null) {\n-                parentResource.close();\n-                parentResource = null;\n-            }\n-        }\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n      * Mark the resource as open.\n      *\n      * @throws IOException\n@@ -490,14 +293,13 @@\n     public abstract byte[] load() throws IOException;\n \n     /**\n-     * Open a {@link ByteBuffer}, if there is an efficient underlying mechanism for opening one, otherwise open an\n-     * {@link InputStream}.\n+     * Open a {@link ClassfileReader} on the resource (for reading classfiles).\n      *\n-     * @return the {@link InputStreamOrByteBufferAdapter}\n+     * @return the {@link ClassfileReader}.\n      * @throws IOException\n      *             if an I/O exception occurs.\n      */\n-    abstract InputStreamOrByteBufferAdapter openOrRead() throws IOException;\n+    abstract ClassfileReader openClassfile() throws IOException;\n \n     /**\n      * Get the length of the resource.*/\n@@ -591,11 +393,7 @@\n         // Override in subclasses, and call super.close(), then at end, markAsClosed()\n         if (inputStream != null) {\n             try {\n-                if (inputStream instanceof InputStreamResourceCloser) {\n-                    ((InputStreamResourceCloser) inputStream).closeInputStream();\n-                } else {\n-                    inputStream.close();\n-                }\n+                inputStream.close();\n             } catch (final IOException e) {\n                 // Ignore\n             }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/classpath/ClasspathOrder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/classpath/ClasspathOrder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/classpath/ClasspathOrder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/classpath/ClasspathOrder.java\n@@ -36,6 +36,7 @@\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n \n import io.github.classgraph.ClassGraph.ClasspathElementFilter;\n@@ -78,6 +79,23 @@\n             this.classpathElement = classpathElement;\n             this.classLoader = classLoader;\n         }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(classpathElement, classLoader);\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            } else if (!(obj instanceof ClasspathElementAndClassLoader)) {\n+                return false;\n+            }\n+            final ClasspathElementAndClassLoader other = (ClasspathElementAndClassLoader) obj;\n+            return Objects.equals(this.classpathElement, other.classpathElement)\n+                    && Objects.equals(this.classLoader, other.classLoader);\n+        }\n     }\n \n     /**\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader: ByteBufferWrapper.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/FastZipEntry.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/FastZipEntry.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/FastZipEntry.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/FastZipEntry.java\n@@ -28,19 +28,12 @@\n  */\n package nonapi.io.github.classgraph.fastzipfilereader;\n \n-import java.io.EOFException;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.BufferUnderflowException;\n import java.util.Calendar;\n import java.util.TimeZone;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Inflater;\n-import java.util.zip.ZipException;\n \n-import nonapi.io.github.classgraph.recycler.RecycleOnClose;\n-import nonapi.io.github.classgraph.utils.FileUtils;\n+import nonapi.io.github.classgraph.fileslice.Slice;\n+import nonapi.io.github.classgraph.fileslice.reader.RandomAccessReader;\n import nonapi.io.github.classgraph.utils.VersionFinder;\n \n /** A zip entry within a {@link LogicalZipFile}. */\n@@ -51,9 +44,6 @@\n     /** The offset of the entry's local header, as an offset relative to the parent logical zipfile. */\n     private final long locHeaderPos;\n \n-    /** The start offset of the entry's compressed data, as an absolute offset within the physical zipfile. */\n-    private long entryDataStartOffsetWithinPhysicalZipFile = -1L;\n-\n     /** The zip entry path. */\n     public final String entryName;\n \n@@ -78,6 +68,9 @@\n     /** The file attributes for this resource, or 0 if unknown */\n     public final int fileAttributes;\n \n+    /** The {@link Slice} for the zip entry's raw data (which can be either stored or deflated). */\n+    private Slice slice;\n+\n     /**\n      * The version code (&gt;= 9), or 8 for the base layer or a non-versioned jar (whether JDK 7 or 8 compatible).\n      */\n@@ -88,12 +81,6 @@\n      */\n     public final String entryNameUnversioned;\n \n-    /** The nested jar handler. */\n-    private final NestedJarHandler nestedJarHandler;\n-\n-    /** The {@link RecyclableInflater} instance wrapping recyclable {@link Inflater} instances. */\n-    private RecyclableInflater recyclableInflaterInstance;\n-\n     // -------------------------------------------------------------------------------------------------------------\n \n     /**\n@@ -111,8 +98,6 @@\n      *            The compressed size of the entry.\n      * @param uncompressedSize\n      *            The uncompressed size of the entry.\n-     * @param nestedJarHandler\n-     *            The {@link NestedJarHandler}.\n      * @param lastModifiedTimeMillis\n      *            The last modified date/time in millis since the epoch, or 0L if unknown (in which case, the MSDOS\n      *            time and date fields will be provided).\n@@ -125,15 +110,14 @@\n      */\n     FastZipEntry(final LogicalZipFile parentLogicalZipFile, final long locHeaderPos, final String entryName,\n             final boolean isDeflated, final long compressedSize, final long uncompressedSize,\n-            final NestedJarHandler nestedJarHandler, final long lastModifiedTimeMillis,\n-            final int lastModifiedTimeMSDOS, final int lastModifiedDateMSDOS, final int fileAttributes) {\n+            final long lastModifiedTimeMillis, final int lastModifiedTimeMSDOS, final int lastModifiedDateMSDOS,\n+            final int fileAttributes) {\n         this.parentLogicalZipFile = parentLogicalZipFile;\n         this.locHeaderPos = locHeaderPos;\n         this.entryName = entryName;\n         this.isDeflated = isDeflated;\n         this.compressedSize = compressedSize;\n         this.uncompressedSize = !isDeflated && uncompressedSize < 0 ? compressedSize : uncompressedSize;\n-        this.nestedJarHandler = nestedJarHandler;\n         this.lastModifiedTimeMillis = lastModifiedTimeMillis;\n         this.lastModifiedTimeMSDOS = lastModifiedTimeMSDOS;\n         this.lastModifiedDateMSDOS = lastModifiedDateMSDOS;\n@@ -195,430 +179,31 @@\n     // -------------------------------------------------------------------------------------------------------------\n \n     /**\n-     * Lazily find zip entry data start offset -- this is deferred until zip entry data needs to be read, in order\n-     * to avoid randomly seeking within zipfile for every entry as the central directory is read.\n+     * Lazily get zip entry slice -- this is deferred until zip entry data needs to be read, in order to avoid\n+     * randomly seeking within zipfile for every entry as the central directory is read.\n      *\n      * @return the offset within the physical zip file of the entry's start offset.\n      * @throws IOException\n      *             If an I/O exception occurs.\n-     * @throws InterruptedException\n-     *             If the thread was interrupted.\n      */\n-    long getEntryDataStartOffsetWithinPhysicalZipFile() throws IOException, InterruptedException {\n-        if (entryDataStartOffsetWithinPhysicalZipFile == -1L) {\n-            // Create zipfile slice reader for zip entry\n-            try (RecycleOnClose<ZipFileSliceReader, RuntimeException> zipFileSliceReaderRecycleOnClose = //\n-                    parentLogicalZipFile.zipFileSliceReaderRecycler.acquireRecycleOnClose()) {\n-                final ZipFileSliceReader headerReader = zipFileSliceReaderRecycleOnClose.get();\n-                // Check header magic\n-                if (headerReader.getInt(locHeaderPos) != 0x04034b50) {\n-                    throw new IOException(\"Zip entry has bad LOC header: \" + entryName);\n-                }\n-                final long dataStartPos = locHeaderPos + 30 + headerReader.getShort(locHeaderPos + 26)\n-                        + headerReader.getShort(locHeaderPos + 28);\n-                if (dataStartPos > parentLogicalZipFile.len) {\n-                    throw new IOException(\"Unexpected EOF when trying to read zip entry data: \" + entryName);\n-                }\n-                entryDataStartOffsetWithinPhysicalZipFile = parentLogicalZipFile.startOffsetWithinPhysicalZipFile\n-                        + dataStartPos;\n-            }\n-        }\n-        return entryDataStartOffsetWithinPhysicalZipFile;\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n-     * True if the entire zip entry can be opened as a single ByteBuffer slice.\n-     *\n-     * @return true if the entire zip entry can be opened as a single ByteBuffer slice -- the entry must be STORED,\n-     *         and span only one 2GB buffer chunk.\n-     * @throws IOException\n-     *             If an I/O exception occurs.\n-     * @throws InterruptedException\n-     *             If the thread was interrupted.\n-     */\n-    public boolean canGetAsSlice() throws IOException, InterruptedException {\n-        final long dataStartOffsetWithinPhysicalZipFile = getEntryDataStartOffsetWithinPhysicalZipFile();\n-        return !isDeflated //\n-                && dataStartOffsetWithinPhysicalZipFile / FileUtils.MAX_BUFFER_SIZE //\n-                        == (dataStartOffsetWithinPhysicalZipFile + uncompressedSize) / FileUtils.MAX_BUFFER_SIZE;\n-    }\n-\n-    /**\n-     * Open the ZipEntry as a ByteBuffer slice. Only call this method if {@link #canGetAsSlice()} returned true.\n-     *\n-     * @return the ZipEntry as a ByteBuffer.\n-     * @throws IOException\n-     *             If an I/O exception occurs.\n-     * @throws InterruptedException\n-     *             If the thread was interrupted.\n-     */\n-    public ByteBufferWrapper getAsSlice() throws IOException, InterruptedException {\n-        // Check the file is STORED and resides in only one chunk\n-        if (!canGetAsSlice()) {\n-            throw new IllegalArgumentException(\"Cannot open zip entry as a slice\");\n-        }\n-        final int sliceLength = (int) uncompressedSize;\n-\n-        // Fetch the ByteBuffer for the applicable chunk\n-        final long dataStartOffsetWithinPhysicalZipFile = getEntryDataStartOffsetWithinPhysicalZipFile();\n-        final int chunkIdx = (int) (dataStartOffsetWithinPhysicalZipFile / FileUtils.MAX_BUFFER_SIZE);\n-        final long chunkStart = chunkIdx * (long) FileUtils.MAX_BUFFER_SIZE;\n-        final int sliceStart = (int) (dataStartOffsetWithinPhysicalZipFile - chunkStart);\n-\n-        // Duplicate and slice the ByteBuffer\n-        return parentLogicalZipFile.physicalZipFile.getByteBuffer(chunkIdx).slice(sliceStart, sliceLength);\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n-     * Open the data of the zip entry as an {@link InputStream}, inflating the data if the entry is deflated.\n-     *\n-     * @return the input stream\n-     * @throws IOException\n-     *             If an I/O exception occurs.\n-     * @throws InterruptedException\n-     *             if the thread was interrupted.\n-     */\n-    public InputStream open() throws IOException, InterruptedException {\n-        if (recyclableInflaterInstance != null) {\n-            throw new IOException(\"Zip entry already open\");\n-        }\n-        if (isDeflated) {\n-            recyclableInflaterInstance = nestedJarHandler.inflaterRecycler.acquire();\n-        }\n-        return new InputStream() {\n-            /** The data start offset within the physical zip file. */\n-            private final long dataStartOffsetWithinPhysicalZipFile = getEntryDataStartOffsetWithinPhysicalZipFile();\n-\n-            /** A scratch buffer. */\n-            private final byte[] scratch = new byte[8 * 1024];\n-\n-            /** The current 2GB chunk of the zip entry. */\n-            private ByteBufferWrapper currChunkByteBuf;\n-\n-            /** True if the current 2GB chunk is the last chunk in the zip entry. */\n-            private boolean isLastChunk;\n-\n-            /** The index of the current 2GB chunk. */\n-            private int currChunkIdx;\n-\n-            /** True if the end of the zip entry has been reached. */\n-            private boolean eof;\n-\n-            /** The {@link Inflater} instance, or null if the entry is stored rather than deflated. */\n-            private final Inflater inflater = isDeflated ? recyclableInflaterInstance.getInflater() : null;\n-\n-            /** True if this {@link InputStream} has been closed. */\n-            private final AtomicBoolean closed = new AtomicBoolean(false);\n-\n-            /** The size of the {@link Inflate} buffer to use. */\n-            private static final int INFLATE_BUF_SIZE = 8 * 1024;\n-\n-            // Open the first 2GB chunk.\n-            {\n-                // Calculate the chunk index for the first chunk\n-                currChunkIdx = (int) (dataStartOffsetWithinPhysicalZipFile / FileUtils.MAX_BUFFER_SIZE);\n-\n-                // Calculate the start position within the first chunk, and set the position of the slice.\n-                // N.B. the cast to Buffer is necessary, see:\n-                // https://github.com/plasma-umass/doppio/issues/497#issuecomment-334740243\n-                // https://github.com/classgraph/classgraph/issues/284#issuecomment-443612800\n-                final int chunkPos = (int) (dataStartOffsetWithinPhysicalZipFile\n-                        - (((long) currChunkIdx) * (long) FileUtils.MAX_BUFFER_SIZE));\n-\n-                // Calculate end pos for the first chunk, and truncate it if it overflows 2GB\n-                final int chunkLength = (int) Math.min(FileUtils.MAX_BUFFER_SIZE, compressedSize);\n-                // True if there's only one chunk (first chunk is also last chunk)\n-                isLastChunk = chunkLength == compressedSize;\n-\n-                // Get the MappedByteBuffer for the 2GB chunk, duplicate it and slice it\n-                currChunkByteBuf = parentLogicalZipFile.physicalZipFile.getByteBuffer(currChunkIdx).slice(chunkPos,\n-                        chunkLength);\n-            }\n-\n-            /** Advance to the next 2GB chunk. */\n-            private boolean readNextChunk() throws IOException, InterruptedException {\n-                currChunkIdx++;\n-                isLastChunk = currChunkIdx >= parentLogicalZipFile.physicalZipFile.numChunks() - 1;\n-                if (currChunkIdx >= parentLogicalZipFile.physicalZipFile.numChunks()) {\n-                    // Ran out of chunks\n-                    return false;\n-                }\n-\n-                // Get the MappedByteBuffer for the next 2GB chunk, and duplicate it\n-                currChunkByteBuf = parentLogicalZipFile.physicalZipFile.getByteBuffer(currChunkIdx).duplicate();\n-                return true;\n-            }\n-\n-            /**\n-             * Inflate deflated data.\n-             *\n-             * @param buf\n-             *            the buffer to inflate into.\n-             * @param off\n-             *            the offset within buf to start writing.\n-             * @param len\n-             *            the number of bytes of uncompressed data to read.\n-             * @return the number of bytes read.\n-             * @throws IOException\n-             *             if an I/O exception occurred.\n-             * @throws InterruptedException\n-             *             if the thread was interrupted.\n-             */\n-            private int readDeflated(final byte[] buf, final int off, final int len)\n-                    throws IOException, InterruptedException {\n-                try {\n-                    final byte[] inflateBuf = new byte[INFLATE_BUF_SIZE];\n-                    int numInflatedBytes;\n-                    while ((numInflatedBytes = inflater.inflate(buf, off, len)) == 0) {\n-                        if (inflater.finished() || inflater.needsDictionary()) {\n-                            eof = true;\n-                            return -1;\n-                        }\n-                        if (inflater.needsInput()) {\n-                            // Check if there's still data left in the current chunk\n-                            if (!currChunkByteBuf.hasRemaining()\n-                                    // No more bytes in current chunk -- get next chunk, and then make sure\n-                                    // that currChunkByteBuf.hasRemaining() subsequently returns true\n-                                    && !(readNextChunk() && currChunkByteBuf.hasRemaining())) {\n-                                // Ran out of data in the current chunk, and could not read a new chunk\n-                                throw new IOException(\"Unexpected EOF in deflated data\");\n-                            }\n-                            // Set inflater input for the current chunk\n-\n-                            // In JDK11+: simply use the following instead of all the lines below:\n-                            //     inflater.setInput(currChunkByteBuf);\n-                            // N.B. the ByteBuffer version of setInput doesn't seem to need the extra\n-                            // padding byte at the end when using the \"nowrap\" Inflater option.\n-\n-                            // Copy from the ByteBuffer into a temporary byte[] array (needed for JDK<11).\n-                            try {\n-                                final int remaining = currChunkByteBuf.remaining();\n-                                if (isLastChunk && remaining < inflateBuf.length) {\n-                                    // An extra dummy byte is needed at the end of the input stream when\n-                                    // using the \"nowrap\" Inflater option.\n-                                    // See: ZipFile.ZipFileInputStream.fill()\n-                                    currChunkByteBuf.get(inflateBuf, 0, remaining);\n-                                    inflateBuf[remaining] = (byte) 0;\n-                                    inflater.setInput(inflateBuf, 0, remaining + 1);\n-                                } else if (isLastChunk && remaining == inflateBuf.length) {\n-                                    // If this is the last chunk to read, and the number of remaining\n-                                    // bytes is exactly the size of the buffer, read one byte fewer than\n-                                    // the number of remaining bytes, to cause the last byte to be read\n-                                    // in an extra pass.\n-                                    currChunkByteBuf.get(inflateBuf, 0, remaining - 1);\n-                                    inflater.setInput(inflateBuf, 0, remaining - 1);\n-                                } else {\n-                                    // There are more than inflateBuf.length bytes remaining to be read,\n-                                    // or this is not the last chunk (i.e. read all remaining bytes in\n-                                    // this chunk, which will trigger the next chunk to be read on the\n-                                    // next loop iteration)\n-                                    final int bytesToRead = Math.min(inflateBuf.length, remaining);\n-                                    currChunkByteBuf.get(inflateBuf, 0, bytesToRead);\n-                                    inflater.setInput(inflateBuf, 0, bytesToRead);\n-                                }\n-                            } catch (final BufferUnderflowException e) {\n-                                // Should not happen\n-                                throw new IOException(\"Unexpected EOF in deflated data\");\n-                            }\n-                        }\n-                    }\n-                    return numInflatedBytes;\n-                } catch (final DataFormatException e) {\n-                    throw new ZipException(\n-                            e.getMessage() != null ? e.getMessage() : \"Invalid deflated zip entry data\");\n-                }\n-            }\n-\n-            /**\n-             * Copy stored (non-deflated) data from ByteBuffer to target buffer.\n-             *\n-             * @param buf\n-             *            the buffer to copy the stored entry into.\n-             * @param off\n-             *            the offset within buf to start writing.\n-             * @param len\n-             *            the number of bytes to read.\n-             * @return the number of bytes read.\n-             * @throws IOException\n-             *             if an I/O exception occurred.\n-             * @throws InterruptedException\n-             *             if the thread was interrupted.\n-             */\n-            private int readStored(final byte[] buf, final int off, final int len)\n-                    throws IOException, InterruptedException {\n-                int read = 0;\n-                while (read < len) {\n-                    if (!currChunkByteBuf.hasRemaining() && !readNextChunk()) {\n-                        return read == 0 ? -1 : read;\n-                    }\n-                    final int remainingToRead = len - read;\n-                    final int remainingInBuf = currChunkByteBuf.remaining();\n-                    final int numBytesRead = Math.min(remainingToRead, remainingInBuf);\n-                    currChunkByteBuf.get(buf, off + read, numBytesRead);\n-                    read += numBytesRead;\n-                }\n-                return read;\n-            }\n-\n-            /**\n-             * Skip stored (non-deflated) data in ByteBuffer.\n-             *\n-             * @param n\n-             *            the number of bytes to skip.\n-             * @throws IOException\n-             *             if an I/O exception occurred or the thread was interrupted.\n-             */\n-            private void skipStored(final long n) throws IOException {\n-                try {\n-                    long skipped = 0;\n-                    while (skipped < n) {\n-                        if (!currChunkByteBuf.hasRemaining() && !readNextChunk()) {\n-                            throw new EOFException(\"Unexpected EOF while skipping (non-deflated) zip entry data\");\n-                        }\n-                        final long remainingToSkip = n - skipped;\n-                        final int remainingInBuf = currChunkByteBuf.remaining();\n-                        final int numBytesToSkip = (int) Math.min(FileUtils.MAX_BUFFER_SIZE,\n-                                Math.min(remainingToSkip, remainingInBuf));\n-                        currChunkByteBuf.skip(numBytesToSkip);\n-                        skipped += numBytesToSkip;\n-                    }\n-                } catch (final InterruptedException e) {\n-                    nestedJarHandler.interruptionChecker.interrupt();\n-                    throw new IOException(\"Thread was interrupted\");\n-                }\n-            }\n-\n-            @Override\n-            public int read(final byte[] buf, final int off, final int len) throws IOException {\n-                if (closed.get()) {\n-                    throw new IOException(\"Stream closed\");\n-                }\n-                if (buf == null) {\n-                    throw new NullPointerException();\n-                } else if (off < 0 || len < 0 || len > buf.length - off) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n-                    return 0;\n-                } else if (parentLogicalZipFile.physicalZipFile.length() == 0) {\n-                    return -1;\n-                }\n-                try {\n-                    if (isDeflated) {\n-                        return readDeflated(buf, off, len);\n-                    } else {\n-                        return readStored(buf, off, len);\n-                    }\n-                } catch (final InterruptedException e) {\n-                    nestedJarHandler.interruptionChecker.interrupt();\n-                    throw new IOException(\"Thread was interrupted\");\n-                }\n-            }\n-\n-            @Override\n-            public int read() throws IOException {\n-                if (closed.get()) {\n-                    throw new IOException(\"Stream closed\");\n-                }\n-                return read(scratch, 0, 1) == -1 ? -1 : scratch[0] & 0xff;\n-            }\n+    public Slice getSlice() throws IOException {\n+        if (slice == null) {\n+            final RandomAccessReader randomAccessReader = parentLogicalZipFile.slice.randomAccessReader();\n \n-            @Override\n-            public int available() throws IOException {\n-                if (closed.get()) {\n-                    throw new IOException(\"Stream closed\");\n-                }\n-                if (inflater.finished()) {\n-                    eof = true;\n-                }\n-                return eof ? 0 : 1;\n+            // Check header magic\n+            if (randomAccessReader.readInt(locHeaderPos) != 0x04034b50) {\n+                throw new IOException(\"Zip entry has bad LOC header: \" + entryName);\n             }\n-\n-            @Override\n-            public long skip(final long n) throws IOException {\n-                if (closed.get()) {\n-                    throw new IOException(\"Stream closed\");\n-                }\n-                if (n < 0) {\n-                    throw new IllegalArgumentException(\"Invalid skip value\");\n-                }\n-                if (isDeflated) {\n-                    long total = 0;\n-                    while (total < n) {\n-                        final int bytesToSkip = (int) Math.min(n - total, scratch.length);\n-                        final int numSkipped = read(scratch, 0, bytesToSkip);\n-                        if (numSkipped == -1) {\n-                            eof = true;\n-                            break;\n-                        }\n-                        total += numSkipped;\n-                    }\n-                } else {\n-                    skipStored(n);\n-                }\n-                return n;\n+            final long dataStartPos = locHeaderPos + 30 + randomAccessReader.readShort(locHeaderPos + 26)\n+                    + randomAccessReader.readShort(locHeaderPos + 28);\n+            if (dataStartPos > parentLogicalZipFile.slice.sliceLength) {\n+                throw new IOException(\"Unexpected EOF when trying to read zip entry data: \" + entryName);\n             }\n \n-            @Override\n-            public boolean markSupported() {\n-                return false;\n-            }\n-\n-            @Override\n-            public synchronized void mark(final int readlimit) {\n-                throw new IllegalArgumentException(\"Not supported\");\n-            }\n-\n-            @Override\n-            public synchronized void reset() throws IOException {\n-                throw new IllegalArgumentException(\"Not supported\");\n-            }\n-\n-            @Override\n-            public void close() throws IOException {\n-                if (!closed.getAndSet(true)) {\n-                    currChunkByteBuf = null;\n-                    if (recyclableInflaterInstance != null) {\n-                        // Reset and recycle the Inflater\n-                        nestedJarHandler.inflaterRecycler.recycle(recyclableInflaterInstance);\n-                        recyclableInflaterInstance = null;\n-                    }\n-                }\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Load the content of the zip entry, and return it as a byte array.\n-     *\n-     * @return the entry as a byte[] array\n-     * @throws IOException\n-     *             If an I/O exception occurs.\n-     * @throws InterruptedException\n-     *             If the thread was interrupted.\n-     */\n-    public byte[] load() throws IOException, InterruptedException {\n-        try (InputStream is = open()) {\n-            return FileUtils.readAllBytesAsArray(is, uncompressedSize);\n-        }\n-    }\n-\n-    /**\n-     * Load the content of the zip entry, and return it as a String (converting from UTF-8 byte format).\n-     *\n-     * @return the entry as a String\n-     * @throws IOException\n-     *             If an I/O exception occurs.\n-     * @throws InterruptedException\n-     *             If the thread was interrupted.\n-     */\n-    public String loadAsString() throws IOException, InterruptedException {\n-        try (InputStream is = open()) {\n-            return FileUtils.readAllBytesAsString(is, uncompressedSize);\n+            // Create a new Slice that wraps just the data of the zip entry, and mark whether it is deflated\n+            slice = parentLogicalZipFile.slice.slice(dataStartPos, compressedSize, isDeflated, uncompressedSize);\n         }\n+        return slice;\n     }\n \n     // -------------------------------------------------------------------------------------------------------------\n@@ -662,14 +247,6 @@\n         return lastModifiedTimeMillis;\n     }\n \n-    /* (non-Javadoc)\n-     * @see java.lang.Object#toString()\n-     */\n-    @Override\n-    public String toString() {\n-        return \"jar:file:\" + getPath();\n-    }\n-\n     /**\n      * Sort in decreasing order of version number, then lexicographically increasing order of unversioned entry\n      * path.\n@@ -699,6 +276,14 @@\n     }\n \n     /* (non-Javadoc)\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        return parentLogicalZipFile.hashCode() ^ version ^ entryName.hashCode() ^ (int) locHeaderPos;\n+    }\n+\n+    /* (non-Javadoc)\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n     @Override\n@@ -713,10 +298,10 @@\n     }\n \n     /* (non-Javadoc)\n-     * @see java.lang.Object#hashCode()\n+     * @see java.lang.Object#toString()\n      */\n     @Override\n-    public int hashCode() {\n-        return parentLogicalZipFile.hashCode() ^ version ^ entryName.hashCode() ^ (int) locHeaderPos;\n+    public String toString() {\n+        return \"jar:file:\" + getPath();\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/LogicalZipFile.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/LogicalZipFile.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/LogicalZipFile.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/LogicalZipFile.java\n@@ -32,10 +32,6 @@\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.CharsetDecoder;\n-import java.nio.charset.CodingErrorAction;\n import java.nio.charset.StandardCharsets;\n import java.util.AbstractMap.SimpleEntry;\n import java.util.ArrayList;\n@@ -49,7 +45,8 @@\n import java.util.concurrent.ConcurrentHashMap;\n \n import io.github.classgraph.ClassGraphException;\n-import nonapi.io.github.classgraph.recycler.RecycleOnClose;\n+import nonapi.io.github.classgraph.fileslice.ArraySlice;\n+import nonapi.io.github.classgraph.fileslice.reader.RandomAccessReader;\n import nonapi.io.github.classgraph.utils.CollectionUtils;\n import nonapi.io.github.classgraph.utils.FileUtils;\n import nonapi.io.github.classgraph.utils.Join;\n@@ -59,7 +56,7 @@\n /**\n  * A logical zipfile, which represents a zipfile contained within a ZipFileSlice of a PhysicalZipFile.\n  */\n-public class LogicalZipFile extends ZipFileSlice implements AutoCloseable {\n+public class LogicalZipFile extends ZipFileSlice {\n     /** The zipfile entries. */\n     public List<FastZipEntry> entries;\n \n@@ -152,10 +149,7 @@\n      */\n     LogicalZipFile(final ZipFileSlice zipFileSlice, final LogNode log) throws IOException, InterruptedException {\n         super(zipFileSlice);\n-        try (RecycleOnClose<ZipFileSliceReader, RuntimeException> zipFileSliceReaderRecycleOnClose = //\n-                zipFileSliceReaderRecycler.acquireRecycleOnClose()) {\n-            readCentralDirectory(zipFileSliceReaderRecycleOnClose.get(), log);\n-        }\n+        readCentralDirectory(log);\n     }\n \n     // -------------------------------------------------------------------------------------------------------------\n@@ -288,7 +282,7 @@\n     private void parseManifest(final FastZipEntry manifestZipEntry, final LogNode log)\n             throws IOException, InterruptedException {\n         // Load contents of manifest entry as a byte array\n-        final byte[] manifest = manifestZipEntry.load();\n+        final byte[] manifest = manifestZipEntry.getSlice().load();\n \n         // Find field keys (separated by newlines)\n         for (int i = 0; i < manifest.length;) {\n@@ -428,8 +422,6 @@\n     /**\n      * Read the central directory of the zipfile.\n      *\n-     * @param zipFileSliceReader\n-     *            the zipfile slice reader\n      * @param log\n      *            the log\n      * @throws IOException\n@@ -437,47 +429,68 @@\n      * @throws InterruptedException\n      *             if the thread was interrupted.\n      */\n-    private void readCentralDirectory(final ZipFileSliceReader zipFileSliceReader, final LogNode log)\n-            throws IOException, InterruptedException {\n-        // Scan for End Of Central Directory (EOCD) signature\n+    private void readCentralDirectory(final LogNode log) throws IOException, InterruptedException {\n+        final RandomAccessReader reader = slice.randomAccessReader();\n+\n+        // Scan for End Of Central Directory (EOCD) signature. Final comment can be up to 64kB in length,\n+        // so need to scan back that far to determine if this is a valid zipfile. However for speed,\n+        // initially just try reading back a maximum of 32 characters.\n         long eocdPos = -1;\n-        for (long i = len - 22; i >= 0; --i) {\n-            if (zipFileSliceReader.getInt(i) == 0x06054b50) {\n+        for (long i = slice.sliceLength - 22, iMin = slice.sliceLength - 22 - 32; i >= iMin; --i) {\n+            if (reader.readInt(i) == 0x06054b50) {\n                 eocdPos = i;\n                 break;\n             }\n         }\n         if (eocdPos < 0) {\n+            // If EOCD signature was not found, read the last 64kB of file to RAM in a single chunk\n+            // so that we can scan back through it at higher speed to locate the EOCD signature\n+            final int bytesToRead = (int) Math.min(slice.sliceLength, 22 + (1 << 16));\n+            final byte[] eocdBytes = new byte[bytesToRead];\n+            final long readStartOff = slice.sliceLength - bytesToRead;\n+            if (reader.read(readStartOff, eocdBytes, 0, bytesToRead) < bytesToRead) {\n+                // Should not happen\n+                throw new IOException(\"Zipfile is truncated\");\n+            }\n+            final RandomAccessReader eocdReader = new ArraySlice(eocdBytes, /* isDeflatedZipEntry = */ false,\n+                    /* inflatedLengthHint = */ 0L, physicalZipFile.nestedJarHandler).randomAccessReader();\n+            for (long i = eocdBytes.length - 22; i >= 0; --i) {\n+                if (eocdReader.readInt(i) == 0x06054b50) {\n+                    eocdPos = i + readStartOff;\n+                    break;\n+                }\n+            }\n+        }\n+        if (eocdPos < 0) {\n             throw new IOException(\"Jarfile central directory signature not found: \" + getPath());\n         }\n-        long numEnt = zipFileSliceReader.getShort(eocdPos + 8);\n-        if (zipFileSliceReader.getShort(eocdPos + 4) > 0 || zipFileSliceReader.getShort(eocdPos + 6) > 0\n-                || numEnt != zipFileSliceReader.getShort(eocdPos + 10)) {\n+        long numEnt = reader.readUnsignedShort(eocdPos + 8);\n+        if (reader.readUnsignedShort(eocdPos + 4) > 0 || reader.readUnsignedShort(eocdPos + 6) > 0\n+                || numEnt != reader.readUnsignedShort(eocdPos + 10)) {\n             throw new IOException(\"Multi-disk jarfiles not supported: \" + getPath());\n         }\n-        long cenSize = zipFileSliceReader.getInt(eocdPos + 12) & 0xffffffffL;\n+        long cenSize = reader.readUnsignedInt(eocdPos + 12);\n         if (cenSize > eocdPos) {\n             throw new IOException(\n                     \"Central directory size out of range: \" + cenSize + \" vs. \" + eocdPos + \": \" + getPath());\n         }\n-        long cenOff = zipFileSliceReader.getInt(eocdPos + 16) & 0xffffffffL;\n+        long cenOff = reader.readUnsignedInt(eocdPos + 16);\n         long cenPos = eocdPos - cenSize;\n \n         // Check for Zip64 End Of Central Directory Locator record\n         final long zip64cdLocIdx = eocdPos - 20;\n-        if (zip64cdLocIdx >= 0 && zipFileSliceReader.getInt(zip64cdLocIdx) == 0x07064b50) {\n-            if (zipFileSliceReader.getInt(zip64cdLocIdx + 4) > 0\n-                    || zipFileSliceReader.getInt(zip64cdLocIdx + 16) > 1) {\n+        if (zip64cdLocIdx >= 0 && reader.readInt(zip64cdLocIdx) == 0x07064b50) {\n+            if (reader.readInt(zip64cdLocIdx + 4) > 0 || reader.readInt(zip64cdLocIdx + 16) > 1) {\n                 throw new IOException(\"Multi-disk jarfiles not supported: \" + getPath());\n             }\n-            final long eocdPos64 = zipFileSliceReader.getLong(zip64cdLocIdx + 8);\n-            if (zipFileSliceReader.getInt(eocdPos64) != 0x06064b50) {\n+            final long eocdPos64 = reader.readLong(zip64cdLocIdx + 8);\n+            if (reader.readInt(eocdPos64) != 0x06064b50) {\n                 throw new IOException(\"Zip64 central directory at location \" + eocdPos64\n                         + \" does not have Zip64 central directory header: \" + getPath());\n             }\n-            final long numEnt64 = zipFileSliceReader.getLong(eocdPos64 + 24);\n-            if (zipFileSliceReader.getInt(eocdPos64 + 16) > 0 || zipFileSliceReader.getInt(eocdPos64 + 20) > 0\n-                    || numEnt64 != zipFileSliceReader.getLong(eocdPos64 + 32)) {\n+            final long numEnt64 = reader.readLong(eocdPos64 + 24);\n+            if (reader.readInt(eocdPos64 + 16) > 0 || reader.readInt(eocdPos64 + 20) > 0\n+                    || numEnt64 != reader.readLong(eocdPos64 + 32)) {\n                 throw new IOException(\"Multi-disk jarfiles not supported: \" + getPath());\n             }\n             if (numEnt == 0xffff) {\n@@ -487,7 +500,7 @@\n                 numEnt = -1L;\n             }\n \n-            final long cenSize64 = zipFileSliceReader.getLong(eocdPos64 + 40);\n+            final long cenSize64 = reader.readLong(eocdPos64 + 40);\n             if (cenSize == 0xffffffffL) {\n                 cenSize = cenSize64;\n             } else if (cenSize != cenSize64) {\n@@ -498,7 +511,7 @@\n             // Recalculate the central directory position\n             cenPos = eocdPos64 - cenSize;\n \n-            final long cenOff64 = zipFileSliceReader.getLong(eocdPos64 + 48);\n+            final long cenOff64 = reader.readLong(eocdPos64 + 48);\n             if (cenOff == 0xffffffffL) {\n                 cenOff = cenOff64;\n             } else if (cenOff != cenOff64) {\n@@ -515,27 +528,39 @@\n \n         // Read entries into a byte array, if central directory is smaller than 2GB. If central directory\n         // is larger than 2GB, need to read each entry field from the file directly using ZipFileSliceReader.\n-        final byte[] entryBytes = cenSize > FileUtils.MAX_BUFFER_SIZE ? null : new byte[(int) cenSize];\n-        if (entryBytes != null) {\n-            zipFileSliceReader.read(cenPos, entryBytes, 0, (int) cenSize);\n+        RandomAccessReader cenReader;\n+        if (cenSize > FileUtils.MAX_BUFFER_SIZE) {\n+            // Create a slice that covers the central directory (this allows a central directory larger than\n+            // 2GB to be accessed using the slower FileSlice API, which reads the file directly, but also\n+            // the slice can be accessed without adding cenPos to each read offset, so that this slice or\n+            // the slice in the \"else\" clause below are accessed with the same index, which is the offset\n+            // from the start of the central directory).\n+            cenReader = slice.slice(cenPos, cenSize, /* isDeflatedZipEntry = */ false, /* inflatedSizeHint = */ 0L)\n+                    .randomAccessReader();\n+        } else {\n+            // Read the central directory into RAM for speed, then wrap it in an ArraySlice\n+            // (random access is faster for ArraySlice than for FileSlice)\n+            final byte[] entryBytes = new byte[(int) cenSize];\n+            if (reader.read(cenPos, entryBytes, 0, (int) cenSize) < cenSize) {\n+                // Should not happen\n+                throw new IOException(\"Zipfile is truncated\");\n+            }\n+            cenReader = new ArraySlice(entryBytes, /* isDeflatedZipEntry = */ false, /* inflatedSizeHint = */ 0L,\n+                    physicalZipFile.nestedJarHandler).randomAccessReader();\n         }\n \n         if (numEnt == -1L) {\n             // numEnt and numEnt64 were inconsistent -- manually count entries\n             numEnt = 0;\n             for (long entOff = 0; entOff + 46 <= cenSize;) {\n-                final int sig = entryBytes != null ? ZipFileSliceReader.getInt(entryBytes, entOff)\n-                        : zipFileSliceReader.getInt(cenPos + entOff);\n+                final int sig = cenReader.readInt(entOff);\n                 if (sig != 0x02014b50) {\n                     throw new IOException(\"Invalid central directory signature: 0x\" + Integer.toString(sig, 16)\n                             + \": \" + getPath());\n                 }\n-                final int filenameLen = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 28)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 28);\n-                final int extraFieldLen = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 30)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 30);\n-                final int commentLen = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 32)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 32);\n+                final int filenameLen = cenReader.readUnsignedShort(entOff + 28);\n+                final int extraFieldLen = cenReader.readUnsignedShort(entOff + 30);\n+                final int commentLen = cenReader.readUnsignedShort(entOff + 32);\n                 entOff += 46 + filenameLen + extraFieldLen + commentLen;\n                 numEnt++;\n             }\n@@ -548,31 +573,26 @@\n         }\n \n         // Make sure there's no DoS attack vector by using a fake number of entries\n-        if (entryBytes != null && numEnt > entryBytes.length / 46) {\n+        if (numEnt > cenSize / 46) {\n             // The smallest directory entry is 46 bytes in size\n-            throw new IOException(\"Too many zipfile entries: \" + numEnt + \" (expected a max of \"\n-                    + entryBytes.length / 46 + \" based on central directory size)\");\n+            throw new IOException(\"Too many zipfile entries: \" + numEnt + \" (expected a max of \" + cenSize / 46\n+                    + \" based on central directory size)\");\n         }\n \n         // Enumerate entries\n         entries = new ArrayList<>((int) numEnt);\n         FastZipEntry manifestZipEntry = null;\n-        CharsetDecoder decoder = null;\n         try {\n             int entSize = 0;\n             for (long entOff = 0; entOff + 46 <= cenSize; entOff += entSize) {\n-                final int sig = entryBytes != null ? ZipFileSliceReader.getInt(entryBytes, entOff)\n-                        : zipFileSliceReader.getInt(cenPos + entOff);\n+                final int sig = cenReader.readInt(entOff);\n                 if (sig != 0x02014b50) {\n                     throw new IOException(\"Invalid central directory signature: 0x\" + Integer.toString(sig, 16)\n                             + \": \" + getPath());\n                 }\n-                final int filenameLen = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 28)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 28);\n-                final int extraFieldLen = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 30)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 30);\n-                final int commentLen = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 32)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 32);\n+                final int filenameLen = cenReader.readUnsignedShort(entOff + 28);\n+                final int extraFieldLen = cenReader.readUnsignedShort(entOff + 30);\n+                final int commentLen = cenReader.readUnsignedShort(entOff + 32);\n                 entSize = 46 + filenameLen + extraFieldLen + commentLen;\n \n                 // Get and sanitize entry name\n@@ -584,9 +604,7 @@\n                     }\n                     break;\n                 }\n-                final String entryName = entryBytes != null\n-                        ? ZipFileSliceReader.getString(entryBytes, filenameStartOff, filenameLen)\n-                        : zipFileSliceReader.getString(cenPos + filenameStartOff, filenameLen);\n+                final String entryName = cenReader.readString(filenameStartOff, filenameLen);\n                 String entryNameSanitized = FileUtils.sanitizeEntryPath(entryName, /* removeInitialSlash = */ true);\n                 if (entryNameSanitized.isEmpty() || entryName.endsWith(\"/\")) {\n                     // Skip directory entries\n@@ -594,8 +612,7 @@\n                 }\n \n                 // Check entry flag bits\n-                final int flags = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 8)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 8);\n+                final int flags = cenReader.readUnsignedShort(entOff + 8);\n                 if ((flags & 1) != 0) {\n                     if (log != null) {\n                         log.log(\"Skipping encrypted zip entry: \" + entryNameSanitized);\n@@ -604,9 +621,7 @@\n                 }\n \n                 // Check compression method\n-                final int compressionMethod = entryBytes != null\n-                        ? ZipFileSliceReader.getShort(entryBytes, entOff + 10)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 10);\n+                final int compressionMethod = cenReader.readUnsignedShort(entOff + 10);\n                 if (compressionMethod != /* stored */ 0 && compressionMethod != /* deflated */ 8) {\n                     if (log != null) {\n                         log.log(\"Skipping zip entry with invalid compression method \" + compressionMethod + \": \"\n@@ -617,17 +632,13 @@\n                 final boolean isDeflated = compressionMethod == /* deflated */ 8;\n \n                 // Get compressed and uncompressed size\n-                long compressedSize = (entryBytes != null ? ZipFileSliceReader.getInt(entryBytes, entOff + 20)\n-                        : zipFileSliceReader.getInt(cenPos + entOff + 20)) & 0xffffffffL;\n-                long uncompressedSize = (entryBytes != null ? ZipFileSliceReader.getInt(entryBytes, entOff + 24)\n-                        : zipFileSliceReader.getInt(cenPos + entOff + 24)) & 0xffffffffL;\n+                long compressedSize = (cenReader.readUnsignedInt(entOff + 20));\n+                long uncompressedSize = (cenReader.readUnsignedInt(entOff + 24));\n \n                 // Get external file attributes\n-                final int fileAttributes = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, entOff + 40)\n-                        : zipFileSliceReader.getShort(cenPos + entOff + 40);\n+                final int fileAttributes = cenReader.readUnsignedShort(entOff + 40);\n \n-                long pos = entryBytes != null ? ZipFileSliceReader.getInt(entryBytes, entOff + 42)\n-                        : zipFileSliceReader.getInt(cenPos + entOff + 42);\n+                long pos = cenReader.readInt(entOff + 42);\n \n                 // Check for Zip64 header in extra fields\n                 // See:\n@@ -637,10 +648,8 @@\n                 if (extraFieldLen > 0) {\n                     for (int extraFieldOff = 0; extraFieldOff + 4 < extraFieldLen;) {\n                         final long tagOff = filenameEndOff + extraFieldOff;\n-                        final int tag = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, tagOff)\n-                                : zipFileSliceReader.getShort(cenPos + tagOff);\n-                        final int size = entryBytes != null ? ZipFileSliceReader.getShort(entryBytes, tagOff + 2)\n-                                : zipFileSliceReader.getShort(cenPos + tagOff + 2);\n+                        final int tag = cenReader.readUnsignedShort(tagOff);\n+                        final int size = cenReader.readUnsignedShort(tagOff + 2);\n                         if (extraFieldOff + 4 + size > extraFieldLen) {\n                             // Invalid size\n                             if (log != null) {\n@@ -650,18 +659,14 @@\n                         }\n                         if (tag == 1 && size >= 20) {\n                             // Zip64 extended information extra field\n-                            final long uncompressedSize64 = entryBytes != null\n-                                    ? ZipFileSliceReader.getLong(entryBytes, tagOff + 4 + 0)\n-                                    : zipFileSliceReader.getLong(cenPos + tagOff + 4 + 0);\n+                            final long uncompressedSize64 = cenReader.readLong(tagOff + 4 + 0);\n                             if (uncompressedSize == 0xffffffffL) {\n                                 uncompressedSize = uncompressedSize64;\n                             } else if (uncompressedSize != uncompressedSize64) {\n                                 throw new IOException(\"Mismatch in uncompressed size: \" + uncompressedSize + \" vs. \"\n                                         + uncompressedSize64 + \": \" + entryNameSanitized);\n                             }\n-                            final long compressedSize64 = entryBytes != null\n-                                    ? ZipFileSliceReader.getLong(entryBytes, tagOff + 4 + 8)\n-                                    : zipFileSliceReader.getLong(cenPos + tagOff + 4 + 8);\n+                            final long compressedSize64 = cenReader.readLong(tagOff + 4 + 8);\n                             if (compressedSize == 0xffffffffL) {\n                                 compressedSize = compressedSize64;\n                             } else if (compressedSize != compressedSize64) {\n@@ -670,9 +675,7 @@\n                             }\n                             // Only compressed size and uncompressed size are required fields\n                             if (size >= 28) {\n-                                final long pos64 = entryBytes != null\n-                                        ? ZipFileSliceReader.getLong(entryBytes, tagOff + 4 + 16)\n-                                        : zipFileSliceReader.getLong(cenPos + tagOff + 4 + 16);\n+                                final long pos64 = cenReader.readLong(tagOff + 4 + 16);\n                                 if (pos == 0xffffffffL) {\n                                     pos = pos64;\n                                 } else if (pos != pos64) {\n@@ -684,20 +687,14 @@\n \n                         } else if (tag == 0x5455 && size >= 5) {\n                             // Extended Unix timestamp\n-                            final byte bits = entryBytes != null\n-                                    ? ZipFileSliceReader.getByte(entryBytes, tagOff + 4 + 0)\n-                                    : zipFileSliceReader.getByte(cenPos + tagOff + 4 + 0);\n+                            final byte bits = cenReader.readByte(tagOff + 4 + 0);\n                             if ((bits & 1) == 1 && size >= 5 + 8) {\n-                                lastModifiedMillis = (entryBytes != null\n-                                        ? ZipFileSliceReader.getLong(entryBytes, tagOff + 4 + 1)\n-                                        : zipFileSliceReader.getLong(cenPos + tagOff + 4 + 1)) * 1000L;\n+                                lastModifiedMillis = cenReader.readLong(tagOff + 4 + 1) * 1000L;\n                             }\n \n                         } else if (tag == 0x5855 && size >= 20) {\n                             // Unix extra field (deprecated)\n-                            lastModifiedMillis = (entryBytes != null\n-                                    ? ZipFileSliceReader.getLong(entryBytes, tagOff + 4 + 8)\n-                                    : zipFileSliceReader.getLong(cenPos + tagOff + 4 + 8)) * 1000L;\n+                            lastModifiedMillis = cenReader.readLong(tagOff + 4 + 8) * 1000L;\n                             // There are also optional UID and GID fields in this extra field (currently ignored)\n \n                         } else if (tag == 0x7855) {\n@@ -705,26 +702,17 @@\n \n                         } else if (tag == 0x7075) {\n                             // Info-ZIP Unicode path extra field\n-                            final byte version = entryBytes != null\n-                                    ? ZipFileSliceReader.getByte(entryBytes, tagOff + 4 + 0)\n-                                    : zipFileSliceReader.getByte(cenPos + tagOff + 4 + 0);\n+                            final byte version = cenReader.readByte(tagOff + 4 + 0);\n                             if (version != 1) {\n                                 throw new IOException(\"Unknown Unicode entry name format \" + version\n                                         + \" in extra field: \" + entryNameSanitized);\n                             } else if (size > 9) {\n-                                final byte[] utf8Bytes = (entryBytes != null\n-                                        ? ZipFileSliceReader.getBytes(entryBytes, tagOff + 9, size - 9)\n-                                        : zipFileSliceReader.getBytes(cenPos + tagOff + 9, size - 9));\n-                                if (decoder == null) {\n-                                    decoder = StandardCharsets.UTF_8.newDecoder();\n-                                    decoder.onMalformedInput(CodingErrorAction.REPORT)\n-                                            .onUnmappableCharacter(CodingErrorAction.REPORT);\n-                                }\n+                                // Replace non-Unicode entry name with Unicode version\n                                 try {\n-                                    // Replace non-Unicode entry name with Unicode version\n-                                    entryNameSanitized = decoder.decode(ByteBuffer.wrap(utf8Bytes)).toString();\n-                                } catch (final CharacterCodingException e) {\n-                                    throw new IOException(\"Malformed Unicode entry name: \" + entryNameSanitized);\n+                                    entryNameSanitized = cenReader.readString(tagOff + 9, size - 9);\n+                                } catch (final IllegalArgumentException e) {\n+                                    throw new IOException(\"Malformed extended Unicode entry name for entry: \"\n+                                            + entryNameSanitized);\n                                 }\n                             }\n                         }\n@@ -736,13 +724,8 @@\n                 int lastModifiedDateMSDOS = 0;\n                 if (lastModifiedMillis == 0L) {\n                     // If Unix timestamp was not provided, convert zip entry timestamp from MS-DOS format\n-                    lastModifiedTimeMSDOS = entryBytes != null\n-                            ? ZipFileSliceReader.getShort(entryBytes, entOff + 12)\n-                            : zipFileSliceReader.getShort(cenPos + entOff + 12);\n-\n-                    lastModifiedDateMSDOS = entryBytes != null\n-                            ? ZipFileSliceReader.getShort(entryBytes, entOff + 14)\n-                            : zipFileSliceReader.getShort(cenPos + entOff + 14);\n+                    lastModifiedTimeMSDOS = cenReader.readUnsignedShort(entOff + 12);\n+                    lastModifiedDateMSDOS = cenReader.readUnsignedShort(entOff + 14);\n                 }\n \n                 if (compressedSize < 0 || pos < 0) {\n@@ -756,7 +739,7 @@\n                     }\n                     continue;\n                 }\n-                if (locHeaderPos + 4 >= len) {\n+                if (locHeaderPos + 4 >= slice.sliceLength) {\n                     if (log != null) {\n                         log.log(\"Unexpected EOF when trying to read LOC header: \" + entryNameSanitized);\n                     }\n@@ -765,8 +748,8 @@\n \n                 // Add zip entry\n                 final FastZipEntry entry = new FastZipEntry(this, locHeaderPos, entryNameSanitized, isDeflated,\n-                        compressedSize, uncompressedSize, physicalZipFile.nestedJarHandler, lastModifiedMillis,\n-                        lastModifiedTimeMSDOS, lastModifiedDateMSDOS, fileAttributes);\n+                        compressedSize, uncompressedSize, lastModifiedMillis, lastModifiedTimeMSDOS,\n+                        lastModifiedDateMSDOS, fileAttributes);\n                 entries.add(entry);\n \n                 // Record manifest entry\n@@ -837,40 +820,10 @@\n     // -------------------------------------------------------------------------------------------------------------\n \n     /* (non-Javadoc)\n-     * @see nonapi.io.github.classgraph.fastzipfilereader.ZipFileSlice#equals(java.lang.Object)\n-     */\n-    @Override\n-    public boolean equals(final Object o) {\n-        return super.equals(o);\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see nonapi.io.github.classgraph.fastzipfilereader.ZipFileSlice#hashCode()\n-     */\n-    @Override\n-    public int hashCode() {\n-        return super.hashCode();\n-    }\n-\n-    /* (non-Javadoc)\n      * @see nonapi.io.github.classgraph.fastzipfilereader.ZipFileSlice#toString()\n      */\n     @Override\n     public String toString() {\n         return getPath();\n     }\n-\n-    /* (non-Javadoc)\n-     * @see java.lang.AutoCloseable#close()\n-     */\n-    @Override\n-    public void close() {\n-        if (zipFileSliceReaderRecycler != null) {\n-            zipFileSliceReaderRecycler.close();\n-        }\n-        if (entries != null) {\n-            entries.clear();\n-            entries = null;\n-        }\n-    }\n }\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader: MappedByteBufferResources.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/NestedJarHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/NestedJarHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/NestedJarHandler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/NestedJarHandler.java\n@@ -28,36 +28,43 @@\n  */\n package nonapi.io.github.classgraph.fastzipfilereader;\n \n+import java.io.BufferedOutputStream;\n import java.io.File;\n+import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n import java.io.RandomAccessFile;\n+import java.net.HttpURLConnection;\n import java.net.MalformedURLException;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n+import java.net.URLConnection;\n import java.nio.ByteBuffer;\n-import java.nio.MappedByteBuffer;\n import java.nio.channels.FileChannel;\n import java.nio.file.Files;\n import java.util.AbstractMap.SimpleEntry;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Map.Entry;\n-import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.zip.DataFormatException;\n import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import java.util.zip.ZipException;\n \n-import io.github.classgraph.ClassGraphException;\n import io.github.classgraph.ModuleReaderProxy;\n import io.github.classgraph.ModuleRef;\n import io.github.classgraph.ScanResult;\n import nonapi.io.github.classgraph.concurrency.InterruptionChecker;\n import nonapi.io.github.classgraph.concurrency.SingletonMap;\n-import nonapi.io.github.classgraph.json.ReferenceEqualityKey;\n+import nonapi.io.github.classgraph.fileslice.ArraySlice;\n+import nonapi.io.github.classgraph.fileslice.FileSlice;\n+import nonapi.io.github.classgraph.fileslice.Slice;\n import nonapi.io.github.classgraph.recycler.Recycler;\n import nonapi.io.github.classgraph.scanspec.ScanSpec;\n import nonapi.io.github.classgraph.utils.FastPathResolver;\n@@ -68,7 +75,7 @@\n /** Open and read jarfiles, which may be nested within other jarfiles. */\n public class NestedJarHandler {\n     /** The {@link ScanSpec}. */\n-    final ScanSpec scanSpec;\n+    public final ScanSpec scanSpec;\n \n     /**\n      * A singleton map from a zipfile's {@link File} to the {@link PhysicalZipFile} for that file, used to ensure*/\n@@ -78,23 +85,10 @@\n     canonicalFileToPhysicalZipFileMap = new SingletonMap<File, PhysicalZipFile, IOException>() {\n         @Override\n         public PhysicalZipFile newInstance(final File canonicalFile, final LogNode log) throws IOException {\n-            if (closed.get()) {\n-                throw ClassGraphException\n-                        .newClassGraphException(NestedJarHandler.class.getSimpleName() + \" already closed\");\n-            }\n-            final PhysicalZipFile physicalZipFile = new PhysicalZipFile(canonicalFile, NestedJarHandler.this, log);\n-            allocatedPhysicalZipFiles.add(physicalZipFile);\n-\n-            return physicalZipFile;\n+            return new PhysicalZipFile(canonicalFile, NestedJarHandler.this, log);\n         }\n     };\n \n-    /** The allocated {@link PhysicalZipFile} instances. */\n-    private Queue<PhysicalZipFile> allocatedPhysicalZipFiles = new ConcurrentLinkedQueue<>();\n-\n-    /** The allocated {@link LogicalZipFile} instances. */\n-    private final Queue<LogicalZipFile> allocatedLogicalZipFiles = new ConcurrentLinkedQueue<>();\n-\n     /**\n      * A singleton map from a {@link FastZipEntry} to the {@link ZipFileSlice} wrapping either the zip entry data,\n      * if the entry is stored, or a ByteBuffer, if the zip entry was inflated to memory, or a physical file on disk*/\n@@ -107,9 +101,8 @@\n                 throws IOException, InterruptedException {\n             ZipFileSlice childZipEntrySlice;\n             if (!childZipEntry.isDeflated) {\n-                // Wrap the child entry (a stored nested zipfile) in a new ZipFileSlice -- there is\n-                // nothing else to do. (Most nested zipfiles are stored, not deflated, so this fast\n-                // path will be followed most often.)\n+                // The child zip entry is a stored nested zipfile -- wrap it in a new ZipFileSlice.\n+                // Hopefully nested zipfiles are stored, not deflated, as this is the fast path.\n                 childZipEntrySlice = new ZipFileSlice(childZipEntry);\n \n             } else {\n@@ -122,13 +115,12 @@\n                 }\n \n                 // Read the InputStream for the child zip entry to a RAM buffer, or spill to disk if it's too large \n-                final PhysicalZipFile physicalZipFile = new PhysicalZipFile(childZipEntry.open(),\n-                        childZipEntry.uncompressedSize > 0L\n-                                && childZipEntry.uncompressedSize < FileUtils.MAX_BUFFER_SIZE\n+                final PhysicalZipFile physicalZipFile = new PhysicalZipFile(childZipEntry.getSlice().open(),\n+                        childZipEntry.uncompressedSize >= 0L\n+                                && childZipEntry.uncompressedSize <= FileUtils.MAX_BUFFER_SIZE\n                                         ? (int) childZipEntry.uncompressedSize\n                                         : -1,\n                         childZipEntry.entryName, NestedJarHandler.this, log);\n-                allocatedPhysicalZipFiles.add(physicalZipFile);\n \n                 // Create a new logical slice of the extracted inner zipfile\n                 childZipEntrySlice = new ZipFileSlice(physicalZipFile, childZipEntry);\n@@ -143,14 +135,8 @@\n         @Override\n         public LogicalZipFile newInstance(final ZipFileSlice zipFileSlice, final LogNode log)\n                 throws IOException, InterruptedException {\n-            if (closed.get()) {\n-                throw ClassGraphException\n-                        .newClassGraphException(NestedJarHandler.class.getSimpleName() + \" already closed\");\n-            }\n-            // Read the central directory for the logical zipfile slice\n-            final LogicalZipFile logicalZipFile = new LogicalZipFile(zipFileSlice, log);\n-            allocatedLogicalZipFiles.add(logicalZipFile);\n-            return logicalZipFile;\n+            // Read the central directory for the zipfile\n+            return new LogicalZipFile(zipFileSlice, log);\n         }\n     };\n \n@@ -164,10 +150,6 @@\n                 @Override\n                 public Entry<LogicalZipFile, String> newInstance(final String nestedJarPathRaw, final LogNode log)\n                         throws IOException, InterruptedException {\n-                    if (closed.get()) {\n-                        throw ClassGraphException\n-                                .newClassGraphException(NestedJarHandler.class.getSimpleName() + \" already closed\");\n-                    }\n                     final String nestedJarPath = FastPathResolver.resolve(nestedJarPathRaw);\n                     final int lastPlingIdx = nestedJarPath.lastIndexOf('!');\n                     if (lastPlingIdx < 0) {\n@@ -259,7 +241,13 @@\n                         if (!isDirectory) {\n                             // If child path doesn't end with a slash, see if there's a non-directory entry\n                             // with a name matching the child path (LogicalZipFile discards directory entries\n-                            // ending with a slash when reading the central directory of a zipfile)\n+                            // ending with a slash when reading the central directory of a zipfile).\n+                            // N.B. We perform an O(N) search here because we assume the number of classpath\n+                            // elements containing \"!\" sections is relatively small compared to the total number\n+                            // of entries in all jarfiles (i.e. building a HashMap of entry path to entry for\n+                            // every jarfile would generally be more expensive than performing this linear\n+                            // search, and unless the classpath is enormous, the overall time performance\n+                            // will not tend towards O(N^2).\n                             for (final FastZipEntry entry : parentLogicalZipFile.entries) {\n                                 if (entry.entryName.equals(childPath)) {\n                                     childZipEntry = entry;\n@@ -352,10 +340,6 @@\n                     return new Recycler<ModuleReaderProxy, IOException>() {\n                         @Override\n                         public ModuleReaderProxy newInstance() throws IOException {\n-                            if (closed.get()) {\n-                                throw ClassGraphException.newClassGraphException(\n-                                        NestedJarHandler.class.getSimpleName() + \" already closed\");\n-                            }\n                             return moduleRef.open();\n                         }\n                     };\n@@ -363,28 +347,17 @@\n             };\n \n     /** A recycler for {@link Inflater} instances. */\n-    Recycler<RecyclableInflater, RuntimeException> //\n+    private Recycler<RecyclableInflater, RuntimeException> //\n     inflaterRecycler = new Recycler<RecyclableInflater, RuntimeException>() {\n         @Override\n         public RecyclableInflater newInstance() throws RuntimeException {\n-            if (closed.get()) {\n-                throw ClassGraphException\n-                        .newClassGraphException(NestedJarHandler.class.getSimpleName() + \" already closed\");\n-            }\n             return new RecyclableInflater();\n         }\n     };\n \n-    /**\n-     * {@link MappedByteBuffer} instances that are currently mapped. (Use {@link ReferenceEqualityKey} so that the\n-     * entire contents of the buffers are not compared by {@link ByteBuffer#equals(Object)}).\n-     */\n-    private Set<ReferenceEqualityKey<ByteBufferWrapper>> mappedByteBuffers = Collections\n-            .newSetFromMap(new ConcurrentHashMap<ReferenceEqualityKey<ByteBufferWrapper>, Boolean>());\n-\n-    /** {@link MappedByteBufferResources} instances that were allocated for downloading jars from URLs. */\n-    private Set<MappedByteBufferResources> mappedByteBufferResources = Collections\n-            .newSetFromMap(new ConcurrentHashMap<MappedByteBufferResources, Boolean>());\n+    /** {@link RandomAccessFile} instances that are currently open (typically one per classpath element). */\n+    private Set<RandomAccessFile> openFiles = Collections\n+            .newSetFromMap(new ConcurrentHashMap<RandomAccessFile, Boolean>());\n \n     /** Any temporary files created while scanning. */\n     private Set<File> tempFiles = Collections.newSetFromMap(new ConcurrentHashMap<File, Boolean>());\n@@ -398,6 +371,12 @@\n     /** The interruption checker. */\n     public InterruptionChecker interruptionChecker;\n \n+    /** The default size of a file buffer. */\n+    private static final int DEFAULT_BUFFER_SIZE = 16384;\n+\n+    /** The maximum initial buffer size. */\n+    private static final int MAX_INITIAL_BUFFER_SIZE = 16 * 1024 * 1024;\n+\n     // -------------------------------------------------------------------------------------------------------------\n \n     /**\n@@ -416,32 +395,6 @@\n     // -------------------------------------------------------------------------------------------------------------\n \n     /**\n-     * Record that a {@link FileChannel} was mapped to a {@link MappedByteBuffer}.\n-     *\n-     * @param byteBuffer\n-     *            the byte buffer\n-     */\n-    public void addMappedByteBuffer(final ByteBufferWrapper byteBuffer) {\n-        mappedByteBuffers.add(new ReferenceEqualityKey<ByteBufferWrapper>(byteBuffer));\n-    }\n-\n-    /**\n-     * Unmap a possibly previously-mapped {@link ByteBuffer} (wrapped in a {@link ByteBufferWrapper}).\n-     *\n-     * @param byteBuffer\n-     *            the {@link ByteBufferWrapper}.\n-     * @param log\n-     *            the log.\n-     */\n-    public void unmapByteBuffer(final ByteBufferWrapper byteBuffer, final LogNode log) {\n-        if (mappedByteBuffers.remove(new ReferenceEqualityKey<ByteBufferWrapper>(byteBuffer))) {\n-            byteBuffer.close(log);\n-        }\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n      * Get the leafname of a path.\n      *\n      * @param path\n@@ -475,7 +428,7 @@\n      * @throws IOException\n      *             If the temporary file could not be created.\n      */\n-    File makeTempFile(final String filePathBase, final boolean onlyUseLeafname) throws IOException {\n+    public File makeTempFile(final String filePathBase, final boolean onlyUseLeafname) throws IOException {\n         final File tempFile = File.createTempFile(\"ClassGraph--\", TEMP_FILENAME_LEAF_SEPARATOR\n                 + sanitizeFilename(onlyUseLeafname ? leafname(filePathBase) : filePathBase));\n         tempFile.deleteOnExit();\n@@ -506,6 +459,38 @@\n     }\n \n     /**\n+     * Open a file as a {@link RandomAccessFile}.\n+     * \n+     * @param file\n+     *            the file to open.\n+     */\n+    public RandomAccessFile openFile(final File file) throws IOException {\n+        try {\n+            final RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n+            openFiles.add(raf);\n+            return raf;\n+        } catch (final SecurityException e) {\n+            throw new IOException(\"Could not open file \" + file + \" : \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Close an open {@link RandomAccessFile}, and remove it from the list of files to close when\n+     * {@link #close(LogNode)} is called.\n+     * \n+     * @param raf\n+     *            the {@link RandomAccessFile} to close.\n+     */\n+    public void closeOpenFile(final RandomAccessFile raf) {\n+        openFiles.remove(raf);\n+        try {\n+            raf.close();\n+        } catch (final IOException e) {\n+            // Ignore\n+        }\n+    }\n+\n+    /**\n      * Download a jar from a URL to a temporary file, or to a ByteBuffer if the temporary directory is not writeable\n      * or full. The downloaded jar is returned wrapped in a {@link PhysicalZipFile} instance.\n      */\n@@ -534,27 +519,382 @@\n                 throw new IOException(\"Could not parse URL: \" + jarURL);\n             }\n         }\n-        try (InputStream inputStream = url.openStream()) {\n-            // Fetch the jar contents from the URL's InputStream. If it doesn't fit in RAM, spill over to disk.\n-            final PhysicalZipFile physicalZipFile = new PhysicalZipFile(inputStream, /* length unknown */ -1,\n-                    jarURL, this, log);\n-            allocatedPhysicalZipFiles.add(physicalZipFile);\n-            return physicalZipFile;\n \n-        } catch (final MalformedURLException e) {\n-            throw new IOException(\"Malformed URL: \" + jarURL);\n+        final URLConnection conn = url.openConnection();\n+        HttpURLConnection httpConn = null;\n+        try {\n+            long contentLengthHint = -1L;\n+            if (conn instanceof HttpURLConnection) {\n+                // Get content length from HTTP headers, if available\n+                httpConn = (HttpURLConnection) url.openConnection();\n+                contentLengthHint = httpConn.getContentLengthLong();\n+                if (contentLengthHint < -1L) {\n+                    contentLengthHint = -1L;\n+                }\n+            } else if (conn.getURL().getProtocol().equalsIgnoreCase(\"file\")) {\n+                // We ended up with a \"file:\" URL, which can happen as a result of a custom URL scheme that\n+                // rewrites its URLs into \"file:\" URLs (see Issue400.java).\n+                try {\n+                    // If this is a \"file:\" URL, get the file from the URL and return it as a new PhysicalZipFile\n+                    // (this avoids going through an InputStream). Throws IOException if the file cannot be read.\n+                    final File file = new File(conn.getURL().toURI());\n+                    return new PhysicalZipFile(file, this, log);\n+\n+                } catch (final URISyntaxException e) {\n+                    // Fall through to open URL as InputStream below\n+                }\n+            }\n+\n+            // Fetch content from URL\n+            try (InputStream inputStream = conn.getInputStream()) {\n+                // Fetch the jar contents from the URL's InputStream. If it doesn't fit in RAM, spill over to disk.\n+                final PhysicalZipFile physicalZipFile = new PhysicalZipFile(inputStream, contentLengthHint, jarURL,\n+                        this, log);\n+                if (log != null) {\n+                    log.addElapsedTime();\n+                    log.log(\"***** Note that it is time-consuming to scan jars at non-\\\"file:\\\" URLs, \"\n+                            + \"the URL must be opened (possibly after an http(s) fetch) for every scan, \"\n+                            + \"and the same URL must also be separately opened by the ClassLoader *****\");\n+                }\n+                return physicalZipFile;\n+\n+            } catch (final MalformedURLException e) {\n+                throw new IOException(\"Malformed URL: \" + jarURL);\n+            }\n         } finally {\n-            if (log != null) {\n-                log.addElapsedTime();\n-                log.log(\"***** Note that it is time-consuming to scan jars at non-\\\"file:\\\" URLs, \"\n-                        + \"the URL must be opened (possibly after an http(s) fetch) for every scan, \"\n-                        + \"and the same URL must also be separately opened by the ClassLoader *****\");\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n             }\n         }\n     }\n \n     // -------------------------------------------------------------------------------------------------------------\n \n+    /** Wrap an {@link InputStream} with an {@link InflaterInputStream}, recycling the {@link Inflater} instance. */\n+    public InputStream openInflaterInputStream(final InputStream rawInputStream) throws IOException {\n+        return new InputStream() {\n+            // Gen Inflater instance with nowrap set to true (needed by zip entries)\n+            private final RecyclableInflater recyclableInflater = inflaterRecycler.acquire();\n+            private final Inflater inflater = recyclableInflater.getInflater();\n+            private final AtomicBoolean closed = new AtomicBoolean();\n+            private final byte[] buf = new byte[INFLATE_BUF_SIZE];\n+            private static final int INFLATE_BUF_SIZE = 8192;\n+\n+            @Override\n+            public int read() throws IOException {\n+                if (closed.get()) {\n+                    throw new IOException(\"Already closed\");\n+                } else if (inflater.finished()) {\n+                    return -1;\n+                }\n+                final int numDeflatedBytesRead = read(buf, 0, 1);\n+                if (numDeflatedBytesRead < 0) {\n+                    return -1;\n+                } else {\n+                    return buf[0] & 0xff;\n+                }\n+            }\n+\n+            @Override\n+            public int read(final byte outBuf[], final int off, final int len) throws IOException {\n+                if (closed.get()) {\n+                    throw new IOException(\"Already closed\");\n+                } else if (len < 0) {\n+                    throw new IllegalArgumentException(\"len cannot be negative\");\n+                } else if (len == 0) {\n+                    return 0;\n+                }\n+                try {\n+                    // Keep fetching data from rawInputStream until \n+                    int totInflatedBytes = 0;\n+                    while (!inflater.finished() && totInflatedBytes < len) {\n+                        final int numInflatedBytes = inflater.inflate(outBuf, off + totInflatedBytes,\n+                                len - totInflatedBytes);\n+                        if (numInflatedBytes == 0) {\n+                            if (inflater.needsDictionary()) {\n+                                // Should not happen for jarfiles\n+                                throw new IOException(\"Inflater needs preset dictionary\");\n+                            } else if (inflater.needsInput()) {\n+                                // Read a chunk of data from the raw InputStream\n+                                final int numRawBytesRead = rawInputStream.read(buf, 0, buf.length);\n+                                if (numRawBytesRead == -1) {\n+                                    // An extra dummy byte is needed at the end of the input stream when\n+                                    // using the \"nowrap\" Inflater option.\n+                                    // See: ZipFile.ZipFileInflaterInputStream.fill()\n+                                    buf[0] = (byte) 0;\n+                                    inflater.setInput(buf, 0, 1);\n+                                } else {\n+                                    // Deflate the chunk of data\n+                                    inflater.setInput(buf, 0, numRawBytesRead);\n+                                }\n+                            }\n+                        } else {\n+                            totInflatedBytes += numInflatedBytes;\n+                        }\n+                    }\n+                    if (totInflatedBytes == 0) {\n+                        // If no bytes were inflated, return -1 as required by read() API contract\n+                        return -1;\n+                    }\n+                    return totInflatedBytes;\n+\n+                } catch (final DataFormatException e) {\n+                    throw new ZipException(\n+                            e.getMessage() != null ? e.getMessage() : \"Invalid deflated zip entry data\");\n+                }\n+            }\n+\n+            @Override\n+            public long skip(final long numToSkip) throws IOException {\n+                if (closed.get()) {\n+                    throw new IOException(\"Already closed\");\n+                } else if (numToSkip < 0) {\n+                    throw new IllegalArgumentException(\"numToSkip cannot be negative\");\n+                } else if (numToSkip == 0) {\n+                    return 0;\n+                } else if (inflater.finished()) {\n+                    return -1;\n+                }\n+                long totBytesSkipped = 0L;\n+                for (;;) {\n+                    final int readLen = (int) Math.min(numToSkip - totBytesSkipped, buf.length);\n+                    final int numBytesRead = read(buf, 0, readLen);\n+                    if (numBytesRead > 0) {\n+                        totBytesSkipped -= numBytesRead;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                return totBytesSkipped;\n+            }\n+\n+            @Override\n+            public int available() throws IOException {\n+                if (closed.get()) {\n+                    throw new IOException(\"Already closed\");\n+                }\n+                // We don't know how many bytes are available, but have to return greater than\n+                // zero if there is still input, according to the API contract. Hopefully nothing\n+                // relies on this and ends up reading just one byte at a time.\n+                return inflater.finished() ? 0 : 1;\n+            }\n+\n+            @Override\n+            public void mark(final int readlimit) {\n+                throw new IllegalArgumentException(\"Not supported\");\n+            }\n+\n+            @Override\n+            public void reset() throws IOException {\n+                throw new IllegalArgumentException(\"Not supported\");\n+            }\n+\n+            @Override\n+            public boolean markSupported() {\n+                return false;\n+            }\n+\n+            @Override\n+            public void close() {\n+                if (!closed.getAndSet(true)) {\n+                    try {\n+                        rawInputStream.close();\n+                    } catch (final IOException e) {\n+                        // Ignore\n+                    } finally {\n+                        // Reset and recycle inflater instance\n+                        inflaterRecycler.recycle(recyclableInflater);\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Read all the bytes in an {@link InputStream}, with spillover to a temporary file on disk if a maximum buffer\n+     * size is exceeded.\n+     *\n+     * @param inputStream\n+     *            the {@link InputStream} to read from.\n+     * @param tempFileBaseName\n+     *            the source URL or zip entry that inputStream was opened from (used to name temporary file, if\n+     *            needed).\n+     * @param inputStreamLengthHint\n+     *            the length of inputStream if known, else -1L.\n+     * @param log\n+     *            the log.\n+     * @return if the {@link InputStream} could be read into a byte array, an {@link ArraySlice} will be returned.\n+     *         If this fails and the {@link InputStream} is spilled over to disk, a {@link FileSlice} will be\n+     *         returned.\n+     * \n+     * @throws IOException\n+     *             If the contents could not be read.\n+     */\n+    public Slice readAllBytesWithSpilloverToDisk(final InputStream inputStream, final String tempFileBaseName,\n+            final long inputStreamLengthHint, final LogNode log) throws IOException {\n+        // Open an InflaterInputStream on the slice\n+        try (InputStream inptStream = inputStream) {\n+            if (inputStreamLengthHint <= scanSpec.maxBufferedJarRAMSize) {\n+                // inputStreamLengthHint is unknown (-1) or shorter than scanSpec.maxBufferedJarRAMSize,\n+                // so try reading from the InputStream into an array of size scanSpec.maxBufferedJarRAMSize\n+                // or inputStreamLengthHint respectively. Also if inputStreamLengthHint == 0, which may or\n+                // may not be valid, use a buffer size of 16kB to avoid spilling to disk in case this is\n+                // wrong but the file is still small.\n+                final int bufSize = inputStreamLengthHint == -1L ? scanSpec.maxBufferedJarRAMSize\n+                        : inputStreamLengthHint == 0L ? 16384\n+                                : Math.min((int) inputStreamLengthHint, scanSpec.maxBufferedJarRAMSize);\n+                byte[] buf = new byte[bufSize];\n+                final int bufLength = buf.length;\n+\n+                int bufBytesUsed = 0;\n+                int bytesRead = 0;\n+                while ((bytesRead = inptStream.read(buf, bufBytesUsed, bufLength - bufBytesUsed)) > 0) {\n+                    // Fill buffer until nothing more can be read\n+                    bufBytesUsed += bytesRead;\n+                }\n+                if (bytesRead == 0) {\n+                    // If bytesRead was zero rather than -1, we need to probe the InputStream (by reading\n+                    // one more byte) to see if inputStreamHint underestimated the actual length of the stream\n+                    final byte[] overflowBuf = new byte[1];\n+                    final int overflowBufBytesUsed = inptStream.read(overflowBuf, 0, 1);\n+                    if (overflowBufBytesUsed == 1) {\n+                        // We were able to read one more byte, so we're still not at the end of the stream,\n+                        // and we need to spill to disk, because buf is full\n+                        return spillToDisk(inptStream, tempFileBaseName, buf, overflowBuf, log);\n+                    }\n+                    // else (overflowBufBytesUsed == -1), so reached the end of the stream => don't spill to disk\n+                }\n+                // Successfully reached end of stream\n+                if (bufBytesUsed < buf.length) {\n+                    // Trim array if needed (this is needed if inputStreamLengthHint was -1, or overestimated\n+                    // the length of the InputStream)\n+                    buf = Arrays.copyOf(buf, bufBytesUsed);\n+                }\n+                // Return buf as new ArraySlice\n+                return new ArraySlice(buf, /* isDeflatedZipEntry = */ false, /* inflatedSizeHint = */\n+                        0L, this);\n+\n+            }\n+            // inputStreamLengthHint is longer than scanSpec.maxJarRamSize, so immediately spill to disk\n+            return spillToDisk(inptStream, tempFileBaseName, /* buf = */ null, /* overflowBuf = */ null, log);\n+        }\n+    }\n+\n+    /**\n+     * Spill an {@link InputStream} to disk if the stream is too large to fit in RAM.\n+     * \n+     * @param inputStream\n+     *            The {@link InputStream}.\n+     * @param tempFileBaseName\n+     *            The stem to base the temporary filename on.\n+     * @param buf\n+     *            The first buffer to write to the beginning of the file, or null if none.\n+     * @param overflowBuf\n+     *            The second buffer to write to the beginning of the file, or null if none. (Should have same\n+     *            nullity as buf.)\n+     * @param log\n+     *            The log.\n+     * @throws IOException\n+     *             If anything went wrong creating or writing to the temp file.\n+     */\n+    private FileSlice spillToDisk(final InputStream inputStream, final String tempFileBaseName, final byte[] buf,\n+            final byte[] overflowBuf, final LogNode log) throws IOException {\n+        // Create temp file\n+        File tempFile;\n+        try {\n+            tempFile = makeTempFile(tempFileBaseName, /* onlyUseLeafname = */ true);\n+        } catch (final IOException e) {\n+            throw new IOException(\"Could not create temporary file: \" + e.getMessage());\n+        }\n+        if (log != null) {\n+            log.log(\"Could not fit InputStream content into max RAM buffer size, saving to temporary file: \"\n+                    + tempFileBaseName + \" -> \" + tempFile);\n+        }\n+\n+        // Copy everything read so far and the rest of the InputStream to the temporary file\n+        try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(tempFile))) {\n+            // Write already-read buffered bytes to temp file, if anything was read\n+            if (buf != null) {\n+                outputStream.write(buf);\n+                outputStream.write(overflowBuf);\n+            }\n+            // Copy the rest of the InputStream to the file\n+            final byte[] copyBuf = new byte[8192];\n+            for (int bytesRead; (bytesRead = inputStream.read(copyBuf, 0, copyBuf.length)) > 0;) {\n+                outputStream.write(copyBuf, 0, bytesRead);\n+            }\n+        }\n+\n+        // Return a new FileSlice for the temporary file\n+        return new FileSlice(tempFile, this);\n+    }\n+\n+    /**\n+     * Read all the bytes in an {@link InputStream}.\n+     * \n+     * @param inputStream\n+     *            The {@link InputStream}.\n+     * @param uncompressedLengthHint\n+     *            The length of the data once inflated from the {@link InputStream}, if known, otherwise -1L.\n+     * @return The contents of the {@link InputStream} as a byte array.\n+     * @throws IOException\n+     *             If the contents could not be read.\n+     */\n+    public static byte[] readAllBytesAsArray(final InputStream inputStream, final long uncompressedLengthHint)\n+            throws IOException {\n+        try (InputStream inptStream = inputStream) {\n+            if (uncompressedLengthHint > FileUtils.MAX_BUFFER_SIZE) {\n+                throw new IOException(\"InputStream is too large to read\");\n+            }\n+            final int bufferSize = uncompressedLengthHint < 1L\n+                    // If fileSizeHint is zero or unknown, use default buffer size \n+                    ? DEFAULT_BUFFER_SIZE\n+                    // fileSizeHint is just a hint -- limit the max allocated buffer size, so that invalid ZipEntry\n+                    // lengths do not become a memory allocation attack vector\n+                    : Math.min((int) uncompressedLengthHint, MAX_INITIAL_BUFFER_SIZE);\n+            byte[] buf = new byte[bufferSize];\n+            int totBytesRead = 0;\n+            for (int bytesRead;;) {\n+                while ((bytesRead = inptStream.read(buf, totBytesRead, buf.length - totBytesRead)) > 0) {\n+                    // Fill buffer until nothing more can be read\n+                    totBytesRead += bytesRead;\n+                }\n+                if (bytesRead < 0) {\n+                    // Reached end of stream without filling buf\n+                    break;\n+                }\n+\n+                // Reached end of stream, and buf is full\n+                final int extraByte;\n+                try {\n+                    // bytesRead == 0: either the buffer was the correct size and the end of the stream has been\n+                    // reached, or the buffer was too small. Need to try reading one more byte to see which is\n+                    // the case.\n+                    extraByte = inptStream.read();\n+                    if (extraByte == -1) {\n+                        // Reached end of stream\n+                        break;\n+                    }\n+                } catch (final ZipException e) {\n+                    // FIXME temp\n+                    throw new RuntimeException(e);\n+                }\n+\n+                // Haven't reached end of stream yet. Need to grow the buffer (double its size), and append\n+                // the extra byte that was just read.\n+                if (buf.length == FileUtils.MAX_BUFFER_SIZE) {\n+                    throw new IOException(\"InputStream too large to read into array\");\n+                }\n+                buf = Arrays.copyOf(buf, (int) Math.min(buf.length * 2L, FileUtils.MAX_BUFFER_SIZE));\n+                buf[totBytesRead++] = (byte) extraByte;\n+            }\n+            // Return buffer and number of bytes read\n+            return totBytesRead == buf.length ? buf : Arrays.copyOf(buf, totBytesRead);\n+        }\n+    }\n+\n+    // -------------------------------------------------------------------------------------------------------------\n+\n     /**\n      * Close zipfiles, modules, and recyclers, and delete temporary files. Called by {@link ScanResult#close()}.*/ \n@@ -564,10 +904,6 @@\n     public void close(final LogNode log) {\n         if (!closed.getAndSet(true)) {\n             boolean interrupted = false;\n-            if (inflaterRecycler != null) {\n-                inflaterRecycler.forceClose();\n-                inflaterRecycler = null;\n-            }\n             if (moduleRefToModuleReaderProxyRecyclerMap != null) {\n                 boolean completedWithoutInterruption = false;\n                 while (!completedWithoutInterruption) {\n@@ -593,54 +929,31 @@\n                 nestedPathToLogicalZipFileAndPackageRootMap.clear();\n                 nestedPathToLogicalZipFileAndPackageRootMap = null;\n             }\n-            for (LogicalZipFile logicalZipFile; (logicalZipFile = allocatedLogicalZipFiles.poll()) != null;) {\n-                logicalZipFile.close();\n-            }\n             if (canonicalFileToPhysicalZipFileMap != null) {\n-                while (!canonicalFileToPhysicalZipFileMap.isEmpty()) {\n-                    try {\n-                        for (final Entry<File, PhysicalZipFile> ent : new ArrayList<>(\n-                                canonicalFileToPhysicalZipFileMap.entries())) {\n-                            final PhysicalZipFile physicalZipFile = ent.getValue();\n-                            physicalZipFile.close();\n-                            canonicalFileToPhysicalZipFileMap.remove(ent.getKey());\n-                        }\n-                    } catch (final InterruptedException e) {\n-                        // If thread was interrupted, canonicalFileToPhysicalZipFileMap.entries() is interrupted\n-                        // above, so canonicalFileToPhysicalZipFileMap.remove(ent.getKey()) is never called,\n-                        // which causes the while loop to loop forever if we re-interrupt here (#400). Therefore\n-                        // delay re-interruption until the end of this method.\n-                        interrupted = false;\n-                    }\n-                }\n+                canonicalFileToPhysicalZipFileMap.clear();\n                 canonicalFileToPhysicalZipFileMap = null;\n             }\n-            if (allocatedPhysicalZipFiles != null) {\n-                for (PhysicalZipFile physicalZipFile; (physicalZipFile = allocatedPhysicalZipFiles\n-                        .poll()) != null;) {\n-                    physicalZipFile.close();\n-                }\n-                allocatedPhysicalZipFiles.clear();\n-                allocatedPhysicalZipFiles = null;\n-            }\n             if (fastZipEntryToZipFileSliceMap != null) {\n                 fastZipEntryToZipFileSliceMap.clear();\n                 fastZipEntryToZipFileSliceMap = null;\n             }\n-            if (mappedByteBufferResources != null) {\n-                for (final MappedByteBufferResources bufRes : mappedByteBufferResources) {\n-                    bufRes.close(log);\n-                }\n-                mappedByteBufferResources = null;\n-            }\n-            if (mappedByteBuffers != null) {\n-                while (!mappedByteBuffers.isEmpty()) {\n-                    for (final ReferenceEqualityKey<ByteBufferWrapper> byteBufferRef : new ArrayList<>(\n-                            mappedByteBuffers)) {\n-                        unmapByteBuffer(byteBufferRef.get(), log);\n+            if (openFiles != null) {\n+                while (!openFiles.isEmpty()) {\n+                    for (final RandomAccessFile openFile : new ArrayList<>(openFiles)) {\n+                        try {\n+                            openFile.close();\n+                        } catch (final IOException e) {\n+                            // Ignore\n+                        }\n+                        openFiles.remove(openFile);\n                     }\n                 }\n-                mappedByteBuffers = null;\n+                openFiles.clear();\n+                openFiles = null;\n+            }\n+            if (inflaterRecycler != null) {\n+                inflaterRecycler.forceClose();\n+                inflaterRecycler = null;\n             }\n             // Temp files have to be deleted last, after all PhysicalZipFiles are closed and files are unmapped\n             if (tempFiles != null) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/PhysicalZipFile.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/PhysicalZipFile.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/PhysicalZipFile.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/PhysicalZipFile.java\n@@ -28,39 +28,35 @@\n  */\n package nonapi.io.github.classgraph.fastzipfilereader;\n \n-import java.io.Closeable;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.MappedByteBuffer;\n import java.nio.channels.FileChannel;\n import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n+import nonapi.io.github.classgraph.fileslice.ArraySlice;\n+import nonapi.io.github.classgraph.fileslice.FileSlice;\n+import nonapi.io.github.classgraph.fileslice.Slice;\n import nonapi.io.github.classgraph.utils.FastPathResolver;\n import nonapi.io.github.classgraph.utils.FileUtils;\n import nonapi.io.github.classgraph.utils.LogNode;\n \n /** A physical zipfile, which is mmap'd using a {@link FileChannel}. */\n-class PhysicalZipFile implements Closeable {\n+class PhysicalZipFile {\n     /** The {@link File} backing this {@link PhysicalZipFile}, if any. */\n     private final File file;\n \n     /** The path to the zipfile. */\n     private final String path;\n \n-    /** The byte buffer resources. */\n-    private MappedByteBufferResources byteBufferResources;\n+    /** The {@link Slice} for the zipfile. */\n+    Slice slice;\n \n     /** The nested jar handler. */\n     NestedJarHandler nestedJarHandler;\n \n-    /** True if the zipfile was deflated to RAM, rather than mapped from disk. */\n-    boolean isDeflatedToRam;\n-\n-    /** Set to true once {@link #close()} has been called. */\n-    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    /** The cached hashCode. */\n+    private int hashCode;\n \n     /**\n      * Construct a {@link PhysicalZipFile} from a file on disk.\n@@ -82,16 +78,14 @@\n         this.file = file;\n         this.nestedJarHandler = nestedJarHandler;\n         this.path = FastPathResolver.resolve(FileUtils.CURR_DIR_PATH, file.getPath());\n-\n-        // Map the file to a ByteBuffer\n-        this.byteBufferResources = new MappedByteBufferResources(file, nestedJarHandler, log);\n+        this.slice = new FileSlice(file, nestedJarHandler);\n     }\n \n     /**\n-     * Construct a {@link PhysicalZipFile} from a ByteBuffer in memory.\n+     * Construct a {@link PhysicalZipFile} from a byte array.\n      *\n-     * @param byteBuffer\n-     *            the byte buffer\n+     * @param arr\n+     *            the array containing the zipfile.\n      * @param outermostFile\n      *            the outermost file\n      * @param path\n@@ -101,23 +95,18 @@\n      * @throws IOException\n      *             if an I/O exception occurs.\n      */\n-    PhysicalZipFile(final ByteBuffer byteBuffer, final File outermostFile, final String path,\n+    PhysicalZipFile(final byte[] arr, final File outermostFile, final String path,\n             final NestedJarHandler nestedJarHandler) throws IOException {\n         this.file = outermostFile;\n         this.path = path;\n         this.nestedJarHandler = nestedJarHandler;\n-        this.isDeflatedToRam = true;\n-\n-        // Wrap the ByteBuffer\n-        this.byteBufferResources = new MappedByteBufferResources(byteBuffer, nestedJarHandler);\n-        if (this.byteBufferResources.length() == 0L) {\n-            throw new IOException(\"Zipfile is empty: \" + path);\n-        }\n+        this.slice = new ArraySlice(arr, /* isDeflatedZipEntry = */ false, /* inflatedSizeHint = */ 0L,\n+                nestedJarHandler);\n     }\n \n     /**\n-     * Construct a {@link PhysicalZipFile} from an InputStream, which is downloaded to a {@link ByteBuffer} in RAM,\n-     * or spilled to disk if the content of the InputStream is too large.\n+     * Construct a {@link PhysicalZipFile} by reading from the {@link InputStream} to an array in RAM, or spill to\n+     * disk if the {@link InputStream} is too long.\n      *\n      * @param inputStream\n      *            the input stream\n@@ -133,36 +122,15 @@\n      * @throws IOException\n      *             if an I/O exception occurs.\n      */\n-    PhysicalZipFile(final InputStream inputStream, final int inputStreamLengthHint, final String path,\n-            final NestedJarHandler nestedJarHandler, final LogNode log)\n-            throws IOException {\n+    PhysicalZipFile(final InputStream inputStream, final long inputStreamLengthHint, final String path,\n+            final NestedJarHandler nestedJarHandler, final LogNode log) throws IOException {\n         this.nestedJarHandler = nestedJarHandler;\n         this.path = path;\n-        this.isDeflatedToRam = true;\n-\n-        // Wrap the ByteBuffer\n-        this.byteBufferResources = new MappedByteBufferResources(inputStream, inputStreamLengthHint, path,\n-                nestedJarHandler, log);\n-        if (this.byteBufferResources.length() == 0L) {\n-            throw new IOException(\"Zipfile is empty: \" + path);\n-        }\n-        this.file = byteBufferResources.getMappedFile();\n-    }\n-\n-    /**\n-     * Get a chunk of the file, where chunkIdx denotes which 2GB chunk of the file to return (0 for the first 2GB of\n-     * the file, or for files smaller than 2GB; 1 for the 2-4GB chunk, etc.).\n-     * \n-     * @param chunkIdx\n-     *            The index of the 2GB chunk to read\n-     * @return The {@link MappedByteBuffer} for the requested file chunk, up to 2GB in size.\n-     * @throws IOException\n-     *             If the chunk could not be mmap'd.\n-     * @throws InterruptedException\n-     *             If the thread was interrupted.\n-     */\n-    ByteBufferWrapper getByteBuffer(final int chunkIdx) throws IOException, InterruptedException {\n-        return byteBufferResources.getByteBuffer(chunkIdx);\n+        // Try downloading the InputStream to a byte array. If this succeeds, this will result in an ArraySlice.\n+        // If it fails, the InputStream will be spilled to disk, resulting in a FileSlice.\n+        this.slice = nestedJarHandler.readAllBytesWithSpilloverToDisk(inputStream, /* tempFileBaseName = */ path,\n+                inputStreamLengthHint, log);\n+        this.file = this.slice instanceof FileSlice ? ((FileSlice) this.slice).file : null;\n     }\n \n     /**\n@@ -191,22 +159,7 @@\n      * wrapped.\n      */\n     public long length() {\n-        return byteBufferResources.length();\n-    }\n-\n-    /**\n-     * Get the number of 2GB chunks that are available in this PhysicalZipFile.\n-     */\n-    public int numChunks() {\n-        return byteBufferResources.numChunks();\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see java.lang.Object#toString()\n-     */\n-    @Override\n-    public String toString() {\n-        return path;\n+        return slice.sliceLength;\n     }\n \n     /* (non-Javadoc)\n@@ -214,33 +167,34 @@\n      */\n     @Override\n     public int hashCode() {\n-        return file == null ? 0 : file.hashCode();\n+        if (hashCode == 0) {\n+            hashCode = (file == null ? 0 : file.hashCode());\n+            if (hashCode == 0) {\n+                hashCode = 1;\n+            }\n+        }\n+        return hashCode;\n     }\n \n     /* (non-Javadoc)\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n     @Override\n-    public boolean equals(final Object obj) {\n-        if (obj == this) {\n+    public boolean equals(final Object o) {\n+        if (o == this) {\n             return true;\n-        } else if (!(obj instanceof PhysicalZipFile)) {\n+        } else if (!(o instanceof PhysicalZipFile)) {\n             return false;\n         }\n-        return Objects.equals(file, ((PhysicalZipFile) obj).file);\n+        final PhysicalZipFile other = (PhysicalZipFile) o;\n+        return Objects.equals(file, other.file);\n     }\n \n     /* (non-Javadoc)\n-     * @see java.io.Closeable#close()\n+     * @see java.lang.Object#toString()\n      */\n     @Override\n-    public void close() {\n-        if (!closed.getAndSet(true)) {\n-            if (byteBufferResources != null) {\n-                byteBufferResources.close(/* log = */ null);\n-            }\n-            byteBufferResources = null;\n-            nestedJarHandler = null;\n-        }\n+    public String toString() {\n+        return path;\n     }\n }\n\\ No newline at end of file\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/RecyclableInflater.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/RecyclableInflater.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/RecyclableInflater.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/RecyclableInflater.java\n@@ -37,7 +37,7 @@\n-class RecyclableInflater implements Resettable, AutoCloseable {\n+public class RecyclableInflater implements Resettable, AutoCloseable {\n     /** Create a new {@link Inflater} instance with the \"nowrap\" option (which is needed for zipfile entries). */\n     private final Inflater inflater = new Inflater(/* nowrap = */ true);\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/ZipFileSlice.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/ZipFileSlice.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/ZipFileSlice.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/fastzipfilereader/ZipFileSlice.java\n@@ -30,8 +30,9 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.util.Objects;\n \n-import nonapi.io.github.classgraph.recycler.Recycler;\n+import nonapi.io.github.classgraph.fileslice.Slice;\n import nonapi.io.github.classgraph.scanspec.WhiteBlackList.WhiteBlackListLeafname;\n \n /** A zipfile slice (a sub-range of bytes within a PhysicalZipFile. */\n@@ -40,32 +41,10 @@\n     private final ZipFileSlice parentZipFileSlice;\n     /** The underlying physical zipfile. */\n     public final PhysicalZipFile physicalZipFile;\n-    /** The start offset of the slice within the physical zipfile. */\n-    final long startOffsetWithinPhysicalZipFile;\n-    /** The compressed or stored size of the zipfile slice or entry. */\n-    final long len;\n     /** For the toplevel zipfile slice, the zipfile path; For nested slices, the name/path of the zipfile entry. */\n     private final String pathWithinParentZipFileSlice;\n-    /** A {@link Recycler} for {@link ZipFileSliceReader} instances. */\n-    final Recycler<ZipFileSliceReader, RuntimeException> zipFileSliceReaderRecycler;\n-    // N.B. if any fields are added, make sure the clone constructor below is updated\n-\n-    /**\n-     * Create a new {@link Recycler} for {@link ZipFileSliceReader} instances.\n-     *\n-     * @return A new {@link Recycler} for {@link ZipFileSliceReader} instances.\n-     */\n-    private Recycler<ZipFileSliceReader, RuntimeException> newZipFileSliceReaderRecycler() {\n-        return new Recycler<ZipFileSliceReader, RuntimeException>() {\n-            /* (non-Javadoc)\n-             * @see nonapi.io.github.classgraph.concurrency.LazyReference#newInstance()\n-             */\n-            @Override\n-            public ZipFileSliceReader newInstance() throws RuntimeException {\n-                return new ZipFileSliceReader(ZipFileSlice.this);\n-            }\n-        };\n-    }\n+    /** The {@link Slice} containing the zipfile. */\n+    public Slice slice;\n@@ -76,14 +55,13 @@\n     ZipFileSlice(final PhysicalZipFile physicalZipFile) {\n         this.parentZipFileSlice = null;\n         this.physicalZipFile = physicalZipFile;\n-        this.startOffsetWithinPhysicalZipFile = 0;\n-        this.len = physicalZipFile.length();\n+        this.slice = physicalZipFile.slice;\n         this.pathWithinParentZipFileSlice = physicalZipFile.getPath();\n-        this.zipFileSliceReaderRecycler = newZipFileSliceReaderRecycler();\n     }\n \n@@ -93,14 +71,12 @@\n     ZipFileSlice(final PhysicalZipFile physicalZipFile, final FastZipEntry zipEntry) {\n         this.parentZipFileSlice = zipEntry.parentLogicalZipFile;\n         this.physicalZipFile = physicalZipFile;\n-        this.startOffsetWithinPhysicalZipFile = 0;\n-        this.len = physicalZipFile.length();\n+        this.slice = physicalZipFile.slice;\n         this.pathWithinParentZipFileSlice = zipEntry.entryName;\n-        this.zipFileSliceReaderRecycler = newZipFileSliceReaderRecycler();\n     }\n@@ -112,10 +88,8 @@\n     ZipFileSlice(final FastZipEntry zipEntry) throws IOException, InterruptedException {\n         this.parentZipFileSlice = zipEntry.parentLogicalZipFile;\n         this.physicalZipFile = zipEntry.parentLogicalZipFile.physicalZipFile;\n-        this.startOffsetWithinPhysicalZipFile = zipEntry.getEntryDataStartOffsetWithinPhysicalZipFile();\n-        this.len = zipEntry.compressedSize;\n+        this.slice = zipEntry.getSlice();\n         this.pathWithinParentZipFileSlice = zipEntry.entryName;\n-        this.zipFileSliceReaderRecycler = newZipFileSliceReaderRecycler();\n     }\n\n@@ -127,11 +101,8 @@\n     ZipFileSlice(final ZipFileSlice other) {\n         this.parentZipFileSlice = other.parentZipFileSlice;\n         this.physicalZipFile = other.physicalZipFile;\n-        this.startOffsetWithinPhysicalZipFile = other.startOffsetWithinPhysicalZipFile;\n-        this.len = other.len;\n+        this.slice = other.slice;\n         this.pathWithinParentZipFileSlice = other.pathWithinParentZipFileSlice;\n-        // Reuse the recycler for clones\n-        this.zipFileSliceReaderRecycler = other.zipFileSliceReaderRecycler;\n     }\n \n     /**\n@@ -207,26 +178,27 @@\n     }\n \n     /* (non-Javadoc)\n-     * @see java.lang.Object#hashCode()\n+     * @see nonapi.io.github.classgraph.fastzipfilereader.ZipFileSlice#equals(java.lang.Object)\n      */\n     @Override\n-    public int hashCode() {\n-        return physicalZipFile.getPath().hashCode() ^ (int) startOffsetWithinPhysicalZipFile ^ (int) len;\n+    public boolean equals(final Object o) {\n+        if (o == this) {\n+            return true;\n+        } else if (!(o instanceof ZipFileSlice)) {\n+            return false;\n+        } else {\n+            final ZipFileSlice other = (ZipFileSlice) o;\n+            return Objects.equals(physicalZipFile, other.physicalZipFile) && Objects.equals(slice, other.slice)\n+                    && Objects.equals(pathWithinParentZipFileSlice, other.pathWithinParentZipFileSlice);\n+        }\n     }\n \n     /* (non-Javadoc)\n-     * @see java.lang.Object#equals(java.lang.Object)\n+     * @see nonapi.io.github.classgraph.fastzipfilereader.ZipFileSlice#hashCode()\n      */\n     @Override\n-    public boolean equals(final Object obj) {\n-        if (obj == this) {\n-            return true;\n-        } else if (!(obj instanceof ZipFileSlice)) {\n-            return false;\n-        }\n-        final ZipFileSlice other = (ZipFileSlice) obj;\n-        return startOffsetWithinPhysicalZipFile == other.startOffsetWithinPhysicalZipFile && len == other.len\n-                && this.physicalZipFile.equals(other.physicalZipFile);\n+    public int hashCode() {\n+        return Objects.hash(physicalZipFile, slice, pathWithinParentZipFileSlice);\n     }\n \n     /* (non-Javadoc)\n@@ -234,11 +206,10 @@\n      */\n     @Override\n     public String toString() {\n-        return \"[\"\n-                + (physicalZipFile.isDeflatedToRam ? \"ByteBuffer deflated to RAM from \" + getPath()\n-                        : physicalZipFile.getFile() == null ? \"ByteBuffer downloaded to RAM from \" + getPath()\n-                                : physicalZipFile.getFile())\n-                + \" ; byte range: \" + startOffsetWithinPhysicalZipFile + \"..\"\n-                + (startOffsetWithinPhysicalZipFile + len) + \" / \" + physicalZipFile.length() + \"]\";\n+        final String path = getPath();\n+        final String fileStr = physicalZipFile.getFile() == null ? null : physicalZipFile.getFile().toString();\n+        return \"[\" + (fileStr == null || !fileStr.equals(path) ? path + \" -> \" + fileStr : path) + \" ; byte range: \"\n+                + slice.sliceStartPos + \"..\" + (slice.sliceStartPos + slice.sliceLength) + \" / \"\n+                + physicalZipFile.length() + \"]\";\n     }\n }\n\\ No newline at end of file\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/fastzipfilereader: ZipFileSliceReader.java\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph: fileslice\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/recycler/Recycler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/recycler/Recycler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/recycler/Recycler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/recycler/Recycler.java\n@@ -112,11 +112,15 @@\n      */\n     public final void recycle(final T instance) {\n         if (instance != null) {\n-            usedInstances.remove(instance);\n+            if (!usedInstances.remove(instance)) {\n+                throw new IllegalArgumentException(\"Tried to recycle an instance that was not in use\");\n+            }\n             if (instance instanceof Resettable) {\n                 ((Resettable) instance).reset();\n             }\n-            unusedInstances.add(instance);\n+            if (!unusedInstances.add(instance)) {\n+                throw new IllegalArgumentException(\"Tried to recycle an instance twice\");\n+            }\n         }\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/utils/FileUtils.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/utils/FileUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/utils/FileUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/utils/FileUtils.java\n@@ -31,19 +31,16 @@\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n-import java.io.InputStream;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.nio.ByteBuffer;\n import java.nio.MappedByteBuffer;\n-import java.nio.charset.StandardCharsets;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n \n import io.github.classgraph.ClassGraphException;\n@@ -63,32 +60,17 @@\n     private static Object theUnsafe;\n \n     /**\n-     * The minimum filesize at which it becomes more efficient to read a file with a memory-mapped file channel\n-     * rather than an InputStream. Based on benchmark testing using the following benchmark, averaged over three\n-     * separate runs, then plotted as a speedup curve for 1, 2, 4 and 8 concurrent threads:\n-     * \n-     * https://github.com/lukehutch/FileReadingBenchmark\n-     */\n-    public static final int FILECHANNEL_FILE_SIZE_THRESHOLD;\n-\n-    /**\n      * The current directory path (only reads the current directory once, the first time this field is accessed, so\n      * will not reflect subsequent changes to the current directory).\n      */\n     public static final String CURR_DIR_PATH;\n \n-    /** The default size of a file buffer. */\n-    private static final int DEFAULT_BUFFER_SIZE = 16384;\n-\n     /**\n      * The maximum size of a file buffer array. Eight bytes smaller than {@link Integer#MAX_VALUE}, since some VMs\n      * reserve header words in arrays.\n      */\n     public static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n \n-    /** The maximum initial buffer size. */\n-    private static final int MAX_INITIAL_BUFFER_SIZE = 16 * 1024 * 1024;\n-\n     // -------------------------------------------------------------------------------------------------------------\n\n@@ -119,182 +101,6 @@\n     }\n \n     // -------------------------------------------------------------------------------------------------------------\n-\n-    static {\n-        switch (VersionFinder.OS) {\n-        case Linux:\n-            // On Linux, FileChannel is more efficient once file sizes are larger than 16kb,\n-            // and the speedup increases superlinearly, reaching 1.5-3x for a filesize of 1MB\n-            // (and the performance increase does not level off at 1MB either -- that is as\n-            // far as this was benchmarked).\n-        case MacOSX:\n-            // On older/slower Mac OS X machines, FileChannel is always 10-20% slower than InputStream,\n-            // except for very large files (>1MB), and only for single-threaded reading.\n-            // But on newer/faster Mac OS X machines, you get a 10-20% speedup between 16kB and 128kB,\n-            // then a much larger speedup for files larger than 128kb (topping out at about 2.5x speedup).\n-            // It's probably worth setting the threshold to 16kB to get the 10-20% speedup for files\n-            // larger than 16kB in size on modern machines.\n-        case Solaris:\n-        case BSD:\n-        case Unix:\n-            // No testing has been performed yet on the other unices, so just pick the same val as MacOSX and Linux\n-            FILECHANNEL_FILE_SIZE_THRESHOLD = 16384;\n-            break;\n-\n-        case Windows:\n-            // Windows is always 10-20% faster with FileChannel than with InputStream, even for small files.\n-            FILECHANNEL_FILE_SIZE_THRESHOLD = -1;\n-            break;\n-\n-        case Unknown:\n-            // For any other operating system\n-        default:\n-            FILECHANNEL_FILE_SIZE_THRESHOLD = 16384;\n-            break;\n-        }\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n-     * Read all the bytes in an {@link InputStream}.\n-     * \n-     * @param inputStream\n-     *            The {@link InputStream}.\n-     * @param fileSizeHint\n-     *            The file size, if known, otherwise -1L.\n-     * @return The contents of the {@link InputStream} as a byte array.\n-     * @throws IOException\n-     *             If the contents could not be read.\n-     */\n-    private static byte[] readAllBytes(final InputStream inputStream, final long fileSizeHint) throws IOException {\n-        if (fileSizeHint > MAX_BUFFER_SIZE) {\n-            throw new IOException(\"InputStream is too large to read\");\n-        }\n-        final int bufferSize = fileSizeHint < 1L\n-                // If fileSizeHint is zero or unknown, use default buffer size \n-                ? DEFAULT_BUFFER_SIZE\n-                // fileSizeHint is just a hint -- limit the max allocated buffer size, so that invalid ZipEntry\n-                // lengths do not become a memory allocation attack vector\n-                : Math.min((int) fileSizeHint, MAX_INITIAL_BUFFER_SIZE);\n-        byte[] buf = new byte[bufferSize];\n-        int totBytesRead = 0;\n-        for (int bytesRead;;) {\n-            while ((bytesRead = inputStream.read(buf, totBytesRead, buf.length - totBytesRead)) > 0) {\n-                // Fill buffer until nothing more can be read\n-                totBytesRead += bytesRead;\n-            }\n-            if (bytesRead < 0) {\n-                // Reached end of stream\n-                break;\n-            }\n-            // bytesRead == 0 => grow buffer (avoid integer overflow in next line)\n-            if (buf.length <= MAX_BUFFER_SIZE - buf.length) {\n-                buf = Arrays.copyOf(buf, buf.length * 2);\n-            } else {\n-                if (buf.length == MAX_BUFFER_SIZE) {\n-                    // Try reading one more byte, just in case the stream is exactly MAX_BUFFER_SIZE in length\n-                    if (inputStream.read() == -1) {\n-                        break;\n-                    } else {\n-                        throw new IOException(\"InputStream too large to read into array\");\n-                    }\n-                }\n-                // Can't double the size of the buffer, but increase it to max size\n-                buf = Arrays.copyOf(buf, MAX_BUFFER_SIZE);\n-            }\n-        }\n-        // Return buffer and number of bytes read\n-        return totBytesRead == buf.length ? buf : Arrays.copyOf(buf, totBytesRead);\n-    }\n-\n-    /**\n-     * Read all the bytes in an {@link InputStream} as a byte array.\n-     * \n-     * @param inputStream\n-     *            The {@link InputStream}.\n-     * @param fileSizeHint\n-     *            The file size, if known, otherwise -1L.\n-     * @return The contents of the {@link InputStream} as a byte array.\n-     * @throws IOException\n-     *             If the contents could not be read.\n-     */\n-    public static byte[] readAllBytesAsArray(final InputStream inputStream, final long fileSizeHint)\n-            throws IOException {\n-        return readAllBytes(inputStream, fileSizeHint);\n-    }\n-\n-    /**\n-     * Read all the bytes in an {@link InputStream} as a {@link ByteBuffer}.\n-     * \n-     * @param inputStream\n-     *            The {@link InputStream}.\n-     * @param fileSizeHint\n-     *            The file size, if known, otherwise -1L.\n-     * @return The contents of the {@link InputStream} as a {@link ByteBuffer}.\n-     * @throws IOException\n-     *             If the contents could not be read.\n-     */\n-    public static ByteBuffer readAllBytesAsByteBuffer(final InputStream inputStream, final long fileSizeHint)\n-            throws IOException {\n-        final byte[] buf = readAllBytes(inputStream, fileSizeHint);\n-        return ByteBuffer.wrap(buf, 0, buf.length);\n-    }\n-\n-    /**\n-     * Read all the bytes in an {@link InputStream} as a String.\n-     * \n-     * @param inputStream\n-     *            The {@link InputStream}.\n-     * @param fileSizeHint\n-     *            The file size, if known, otherwise -1L.\n-     * @return The contents of the {@link InputStream} as a String.\n-     * @throws IOException\n-     *             If the contents could not be read.\n-     */\n-    public static String readAllBytesAsString(final InputStream inputStream, final long fileSizeHint)\n-            throws IOException {\n-        final byte[] buf = readAllBytes(inputStream, fileSizeHint);\n-        return new String(buf, 0, buf.length, StandardCharsets.UTF_8);\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n-\n-    /**\n-     * Produce an {@link InputStream} that is able to read from a {@link ByteBuffer}.\n-     * \n-     * @param byteBuffer\n-     *            The {@link ByteBuffer}.\n-     * @return An {@link InputStream} that reads from the {@link ByteBuffer}.\n-     */\n-    public static InputStream byteBufferToInputStream(final ByteBuffer byteBuffer) {\n-        // https://stackoverflow.com/questions/4332264/wrapping-a-bytebuffer-with-an-inputstream/6603018#6603018\n-        return new InputStream() {\n-            /** The intermediate buffer. */\n-            final ByteBuffer buf = byteBuffer;\n-\n-            @Override\n-            public int read() {\n-                if (!buf.hasRemaining()) {\n-                    return -1;\n-                }\n-                return buf.get() & 0xFF;\n-            }\n-\n-            @Override\n-            public int read(final byte[] bytes, final int off, final int len) {\n-                if (!buf.hasRemaining()) {\n-                    return -1;\n-                }\n-\n-                final int bytesRead = Math.min(len, buf.remaining());\n-                buf.get(bytes, off, bytesRead);\n-                return bytesRead;\n-            }\n-        };\n-    }\n-\n-    // -------------------------------------------------------------------------------------------------------------\n \n     /**\n      * Sanitize relative paths against \"zip slip\" vulnerability, by removing path segments if \"..\" is found in the\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/nonapi/io/github/classgraph/utils: InputStreamOrByteBufferAdapter.java\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/nonapi/io/github/classgraph/utils: StringUtils.java",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-17",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_3000.Issue3065",
                "error": "java.lang.UnsupportedOperationException",
                "message": "",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 3,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 3
        },
        "program": "RegressionBug-17",
        "project": "RegressionBug-17",
        "repairOperators": [
            "condBranIfAdd",
            "retBranchAdd"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSONPath.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSONPath.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSONPath.java\t2024-09-22 01:27:02.949360687 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSONPath.java\t2024-09-22 01:26:53.913275546 +1000\n@@ -3301,6 +3301,10 @@\n             return null;\n         }\n \n+        if (index == 0) {\n+            return currentObject;\n+        }\n\n         throw new UnsupportedOperationException();\n     }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/JSONPath.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/JSONPath.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/JSONPath.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/JSONPath.java\n@@ -2017,6 +2017,18 @@\n             return value;\n         }\n \n+        if (currentObject instanceof Collection) {\n+            Collection collection = (Collection) currentObject;\n+            int i = 0;\n+            for (Object item : collection) {\n+                if (i == index) {\n+                    return item;\n+                }\n+                i++;\n+            }\n+            return null;\n+        }\n\n         throw new UnsupportedOperationException();\n     }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n@@ -1446,10 +1446,21 @@\n                 object = task.ownerContext.object;\n             }\n \n-            Object refValue = ref.startsWith(\"$\")\n-                    ? getObject(ref)\n-                    : task.context.object;\n+            Object refValue;\n+            if (ref.startsWith(\"$\")) {\n+                refValue = getObject(ref);\n+                if (refValue == null) {\n+                    try {\n+                        refValue = JSONPath.eval(value, ref);\n+                    } catch (JSONPathException ex) {\n+                    }\n+                }\n+            } else {\n+                refValue = task.context.object;\n+            }\n\n             FieldDeserializer fieldDeser = task.fieldDeserializer;\n \n             if (fieldDeser != null) {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-18",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_2600.Issue2628",
                "error": "junit.framework.ComparisonFailure",
                "message": "expected:<[9423372036854775807]> but was:<[-9023372036854775809]>",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 8,
            "linesMod": 1,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 9
        },
        "program": "RegressionBug-18",
        "project": "RegressionBug-18",
        "repairOperators": [
            "assignAdd",
            "assignRem",
            "condBranIfAdd",
            "condExpExpand",
            "varAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n@@ -3810,10 +3810,17 @@\n         BigInteger value;\n         if (chLocal >= '0' && chLocal <= '9') {\n             long intVal = chLocal - '0';\n+            boolean overflow = false;\n+            long temp;\n             for (;;) {\n                 chLocal = charAt(bp + (offset++));\n                 if (chLocal >= '0' && chLocal <= '9') {\n-                    intVal = intVal * 10 + (chLocal - '0');\n+                    temp = intVal * 10 + (chLocal - '0');\n+                    if (temp < intVal) {\n+                        overflow = true;\n+                        break;\n+                    }\n+                    intVal = temp;\n                     continue;\n                 } else {\n                     break;\n@@ -3835,7 +3842,7 @@\n                 count = bp + offset - start - 1;\n             }\n \n-            if (count < 20 || (negative && count < 21)) {\n+            if (!overflow && (count < 20 || (negative && count < 21))) {\n                 value = BigInteger.valueOf(negative ? -intVal : intVal);\n             } else {\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -502,6 +503,15 @@\n \n                         if (lexer.matchStat > 0) {\n                             matchField = true;\n+                            valueParsed = true;\n+                        } else if (lexer.matchStat == JSONLexer.NOT_MATCH_NAME) {\n+                            continue;\n+                        }\n+                    } else if (fieldClass == BigInteger.class) {\n+                        fieldValue = lexer.scanFieldBigInteger(name_chars);\n+\n+                        if (lexer.matchStat > 0) {\n+                            matchField = true;\n                             valueParsed = true;\n                         } else if (lexer.matchStat == JSONLexer.NOT_MATCH_NAME) {\n                             continue;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n@@ -3432,6 +3424,138 @@\n+    public BigInteger scanFieldBigInteger(char[] fieldName) {\n+        matchStat = UNKNOWN;\n\n+        if (!charArrayCompare(fieldName)) {\n+            matchStat = NOT_MATCH_NAME;\n+            return null;\n+        }\n\n+        int offset = fieldName.length;\n+        char chLocal = charAt(bp + (offset++));\n+        final boolean quote = chLocal == '\"';\n+        if (quote) {\n+            chLocal = charAt(bp + (offset++));\n+        }\n\n+        boolean negative = chLocal == '-';\n+        if (negative) {\n+            chLocal = charAt(bp + (offset++));\n+        }\n\n+        BigInteger value;\n+        if (chLocal >= '0' && chLocal <= '9') {\n+            long intVal = chLocal - '0';\n+            for (;;) {\n+                chLocal = charAt(bp + (offset++));\n+                if (chLocal >= '0' && chLocal <= '9') {\n+                    intVal = intVal * 10 + (chLocal - '0');\n+                    continue;\n+                } else {\n+                    break;\n+                }\n+            }\n\n+            int start, count;\n+            if (quote) {\n+                if (chLocal != '\"') {\n+                    matchStat = NOT_MATCH;\n+                    return null;\n+                } else {\n+                    chLocal = charAt(bp + (offset++));\n+                }\n+                start = bp + fieldName.length + 1;\n+                count = bp + offset - start - 2;\n+            } else {\n+                start = bp + fieldName.length;\n+                count = bp + offset - start - 1;\n+            }\n\n+            if (count < 20 || (negative && count < 21)) {\n+                value = BigInteger.valueOf(negative ? -intVal : intVal);\n+            } else {\n+\n+                String strVal = this.subString(start, count);\n+                value = new BigInteger(strVal);\n+            }\n+        } else if (chLocal == 'n' && charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n+            matchStat = VALUE_NULL;\n+            value = null;\n             offset += 3;\n             chLocal = charAt(bp + offset++);\n ",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-19",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.actiontech.dble.parser.ServerParserTest",
                "error": "java.lang.AssertionError",
                "message": "expected:<6> but was:<154>",
                "methodName": "testIsRollback"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 32,
            "linesMod": 0,
            "linesRem": 2,
            "methods": 2,
            "sizeInLines": 34
        },
        "program": "RegressionBug-19",
        "project": "RegressionBug-19",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "loopAdd",
            "condBranIfAdd",
            "condBranIfElseAdd",
            "retBranchAdd",
            "mdAdd",
            "condBranRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/parser/ServerParse.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/parser/ServerParse.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/parser/ServerParse.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/parser/ServerParse.java\n@@ -1058,7 +1058,8 @@\n \n     // ROLLBACK\n     protected static int rollbackCheck(String stmt, int offset) {\n-        if (stmt.length() > offset + 6) {\n+        int len = stmt.length();\n+        if (len > offset + 6) {\n             char c1 = stmt.charAt(++offset);\n             char c2 = stmt.charAt(++offset);\n             char c3 = stmt.charAt(++offset);\n@@ -1068,10 +1069,41 @@\n             if ((c1 == 'L' || c1 == 'l') && (c2 == 'L' || c2 == 'l') &&\n                     (c3 == 'B' || c3 == 'b') && (c4 == 'A' || c4 == 'a') &&\n                     (c5 == 'C' || c5 == 'c') && (c6 == 'K' || c6 == 'k')) {\n+                char tmp;\n+                while (len > ++offset) {\n+                    tmp = stmt.charAt(offset);\n+                    if (ParseUtil.isSpace(tmp)) {\n+                        continue;\n+                    }\n+                    switch (tmp) {\n+                        case '/':\n+                            offset = ParseUtil.comment(stmt, offset);\n+                            break;\n+                        case 't':\n+                        case 'T':\n+                            return ROLLBACK_SAVEPOINT;\n+                        case 'w':\n+                        case 'W':\n+                            return rollbackWorkCheck(stmt, offset);\n+                        default:\n+                            break;\n+                    }\n+                }\n+                return ROLLBACK;\n+            }\n+        }\n+        return OTHER;\n+    }\n\n+    protected static int rollbackWorkCheck(String stmt, int offset) {\n+        if (stmt.length() > offset + 3) {\n+            char c1 = stmt.charAt(++offset);\n+            char c2 = stmt.charAt(++offset);\n+            char c3 = stmt.charAt(++offset);\n+            if ((c1 == 'O' || c1 == 'o') && (c2 == 'R' || c2 == 'r') &&\n+                    (c3 == 'K' || c3 == 'k')) {\n                 if (stmt.length() == ++offset || ParseUtil.isEOF(stmt, offset) || ParseUtil.isMultiEof(stmt, offset)) {\n                     return ROLLBACK;\n-                } else {\n-                    return ROLLBACK_SAVEPOINT;\n                 }\n             }\n         }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/BackendConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/BackendConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/BackendConnection.java\t2024-10-02 23:00:42.261994174 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/BackendConnection.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -49,7 +49,7 @@\n     void execute(RouteResultsetNode node, ServerConnection source,\n                  boolean autocommit);\n \n-    boolean syncAndExcute();\n+    boolean syncAndExecute();\n \n     void rollback();\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -29,7 +29,7 @@\n \n /**\n  * company where id=(select company_id from customer where id=3); the one which\n- * return data (id) is the datanode to store child table's records\n+ * return data (id) is the data node to store child table's records\n  *\n  * @author wuzhih, huqing.yan\n  */\n@@ -73,7 +73,7 @@\n             PhysicalDBNode mysqlDN = conf.getDataNodes().get(dn);\n             try {\n                 if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"execute in datanode \" + dn);\n+                    LOGGER.debug(\"execute in data_node \" + dn);\n                 }\n                 RouteResultsetNode node = new RouteResultsetNode(dn, ServerParse.SELECT, sql);\n                 node.setRunOnSlave(false); // get child node from master\n@@ -161,7 +161,7 @@\n         if (LOGGER.isDebugEnabled()) {\n             LOGGER.debug(\"okResponse \" + conn);\n         }\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             finished.incrementAndGet();\n             if (canReleaseConn()) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -73,7 +73,7 @@\n \n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             if (clearIfSessionClosed(session)) {\n                 return;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -56,7 +56,7 @@\n         }\n \n         if (LOGGER.isDebugEnabled()) {\n-            LOGGER.debug(\"execute mutinode query \" + rrs.getStatement());\n+            LOGGER.debug(\"execute multiNode query \" + rrs.getStatement());\n         }\n \n         this.rrs = RouteResultCopy.rrCopy(rrs, ServerParse.SELECT, STMT);\n@@ -138,7 +138,7 @@\n                 errConnection = new ArrayList<>();\n             }\n             errConnection.add(conn);\n-            if (!conn.syncAndExcute()) {\n+            if (!conn.syncAndExecute()) {\n                 return;\n             }\n             if (--nodeCount <= 0) {\n@@ -167,7 +167,7 @@\n                 errConnection = new ArrayList<>();\n             }\n             errConnection.add(conn);\n-            if (!conn.syncAndExcute()) {\n+            if (!conn.syncAndExecute()) {\n                 return;\n             }\n             if (--nodeCount <= 0) {\n@@ -196,7 +196,7 @@\n         try {\n             if (!isFail())\n                 setFail(err.toString());\n-            if (!conn.syncAndExcute()) {\n+            if (!conn.syncAndExecute()) {\n                 return;\n             }\n             if (--nodeCount > 0)\n@@ -210,7 +210,7 @@\n     /* arriving here is impossible */\n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n-        if (!conn.syncAndExcute()) {\n+        if (!conn.syncAndExecute()) {\n             LOGGER.debug(\"MultiNodeDdlHandler should not arrive here(okResponse) !\");\n         }\n     }\n@@ -218,10 +218,10 @@\n     @Override\n     public void rowEofResponse(final byte[] eof, boolean isLeft, BackendConnection conn) {\n         if (LOGGER.isDebugEnabled()) {\n-            LOGGER.debug(\"on row end reseponse \" + conn);\n+            LOGGER.debug(\"on row end response \" + conn);\n         }\n \n-        if (errorRepsponsed.get()) {\n+        if (errorResponsed.get()) {\n             return;\n         }\n \n@@ -262,14 +262,14 @@\n     }\n \n     @Override\n-    public void fieldEofResponse(byte[] header, List<byte[]> fields, List<FieldPacket> fieldPacketsnull, byte[] eof,\n+    public void fieldEofResponse(byte[] header, List<byte[]> fields, List<FieldPacket> fieldPacketsNull, byte[] eof,\n                                  boolean isLeft, BackendConnection conn) {\n     }\n \n     @Override\n-    public boolean rowResponse(final byte[] row, RowDataPacket rowPacketnull, boolean isLeft, BackendConnection conn) {\n+    public boolean rowResponse(final byte[] row, RowDataPacket rowPacketNull, boolean isLeft, BackendConnection conn) {\n         /* It is impossible arriving here, because we set limit to 0 */\n-        return errorRepsponsed.get();\n+        return errorResponsed.get();\n     }\n \n     @Override\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -26,7 +26,7 @@\n     private AtomicBoolean isFailed = new AtomicBoolean(false);\n     protected volatile String error;\n     protected byte packetId;\n-    protected final AtomicBoolean errorRepsponsed = new AtomicBoolean(false);\n+    protected final AtomicBoolean errorResponsed = new AtomicBoolean(false);\n \n     public MultiNodeHandler(NonBlockingSession session) {\n         if (session == null) {\n@@ -48,7 +48,7 @@\n \n \n     protected boolean canClose(BackendConnection conn, boolean tryErrorFinish) {\n-        // realse this connection if safe\n+        // release this connection if safe\n         session.releaseConnectionIfSafe(conn, false);\n         boolean allFinished = false;\n         if (tryErrorFinish) {\n@@ -69,9 +69,9 @@\n         session.releaseConnectionIfSafe(conn, false);\n         ErrorPacket err = new ErrorPacket();\n         err.read(data);\n-        String errmsg = new String(err.getMessage());\n-        this.setFail(errmsg);\n-        LOGGER.warn(\"error response from \" + conn + \" err \" + errmsg + \" code:\" + err.getErrno());\n+        String errMsg = new String(err.getMessage());\n+        this.setFail(errMsg);\n+        LOGGER.warn(\"error response from \" + conn + \" err \" + errMsg + \" code:\" + err.getErrno());\n         this.tryErrorFinished(this.decrementCountBy(1));\n     }\n \n@@ -109,7 +109,7 @@\n         packetId = 0;\n     }\n \n-    protected ErrorPacket createErrPkg(String errmgs) {\n+    protected ErrorPacket createErrPkg(String errMsg) {\n         ErrorPacket err = new ErrorPacket();\n         lock.lock();\n         try {\n@@ -118,13 +118,13 @@\n             lock.unlock();\n         }\n         err.setErrno(ErrorCode.ER_UNKNOWN_ERROR);\n-        err.setMessage(StringUtil.encode(errmgs, session.getSource().getCharset().getResults()));\n+        err.setMessage(StringUtil.encode(errMsg, session.getSource().getCharset().getResults()));\n         return err;\n     }\n \n     protected void tryErrorFinished(boolean allEnd) {\n         if (allEnd && !session.closed()) {\n-            if (errorRepsponsed.compareAndSet(false, true)) {\n+            if (errorResponsed.compareAndSet(false, true)) {\n                 createErrPkg(this.error).write(session.getSource());\n             }\n             // clear session resources,release all\n@@ -135,7 +135,7 @@\n                 session.closeAndClearResources(error);\n             } else {\n                 session.getSource().setTxInterrupt(this.error);\n-                // clear resouces\n+                // clear resources\n                 clearResources();\n             }\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -263,7 +263,7 @@\n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n         this.netOutBytes += data.length;\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (LOGGER.isDebugEnabled()) {\n             LOGGER.debug(\"received ok response ,executeResponse:\" + executeResponse + \" from \" + conn);\n         }\n@@ -321,7 +321,7 @@\n \n         this.netOutBytes += eof.length;\n \n-        if (errorRepsponsed.get()) {\n+        if (errorResponsed.get()) {\n             return;\n         }\n \n@@ -645,7 +645,7 @@\n     }\n \n     public void handleDataProcessException(Exception e) {\n-        if (!errorRepsponsed.get()) {\n+        if (!errorResponsed.get()) {\n             this.error = e.toString();\n             LOGGER.warn(\"caught exception \", e);\n             setFail(e.toString());\n@@ -656,7 +656,7 @@\n     @Override\n     public boolean rowResponse(final byte[] row, RowDataPacket rowPacketnull, boolean isLeft, BackendConnection conn) {\n \n-        if (errorRepsponsed.get()) {\n+        if (errorResponsed.get()) {\n             // the connection has been closed or set to \"txInterrupt\" properly\n             //in tryErrorFinished() method! If we close it here, it can\n             // lead to tx error such as blocking rollback tx for ever.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -81,7 +81,7 @@\n \n     @Override\n     public void okResponse(byte[] ok, BackendConnection conn) {\n-        conn.syncAndExcute();\n+        conn.syncAndExecute();\n     }\n \n     @Override\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler: ResetConnHandler.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -176,7 +176,7 @@\n         //\n         this.netOutBytes += data.length;\n \n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             session.handleSpecial(rrs, session.getSource().getSchema(), true);\n             ServerConnection source = session.getSource();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -84,7 +84,7 @@\n \n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             boolean isEndPack = decrementCountBy(1);\n             session.releaseConnection(conn);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java\t2024-10-02 23:00:42.149993027 +1000\n@@ -15,10 +15,12 @@\n import com.actiontech.dble.net.BackendAIOConnection;\n import com.actiontech.dble.net.mysql.*;\n import com.actiontech.dble.route.RouteResultsetNode;\n+import com.actiontech.dble.route.parser.util.Pair;\n import com.actiontech.dble.server.NonBlockingSession;\n import com.actiontech.dble.server.ServerConnection;\n import com.actiontech.dble.server.SystemVariables;\n import com.actiontech.dble.server.parser.ServerParse;\n+import com.actiontech.dble.util.StringUtil;\n import com.actiontech.dble.util.TimeUtil;\n import com.actiontech.dble.util.exception.UnknownTxIsolationException;\n import org.slf4j.Logger;\n@@ -27,6 +29,7 @@\n import java.io.UnsupportedEncodingException;\n import java.nio.channels.NetworkChannel;\n import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -44,7 +47,7 @@\n     private volatile boolean isDDL = false;\n     private volatile boolean isRunning;\n     private volatile StatusSync statusSync;\n-    private volatile boolean metaDataSyned = true;\n+    private volatile boolean metaDataSynced = true;\n     private volatile TxState xaStatus = TxState.TX_INITIALIZE_STATE;\n     private volatile int txIsolation;\n     private volatile boolean autocommit;\n@@ -137,8 +140,18 @@\n         *  it need to sync the status firstly for new idle connection*/\n         this.txIsolation = -1;\n         this.complexQuery = false;\n+        this.usrVariables = new LinkedHashMap<>();\n+        this.sysVariables = new LinkedHashMap<>();\n     }\n \n+    public void resetContextStatus() {\n+        this.txIsolation = -1;\n+        this.autocommit = true;\n+        //TODO:CHECK\n+        this.setCharacterSet(SystemVariables.getDefaultValue(\"character_set_server\"));\n+        this.usrVariables.clear();\n+        this.sysVariables.clear();\n+    }\n     public void setRunning(boolean running) {\n         isRunning = running;\n     }\n@@ -211,7 +224,7 @@\n         this.threadId = threadId;\n     }\n \n-    public void setAuthenticated(boolean authenticated) {\n+    void setAuthenticated(boolean authenticated) {\n         isAuthenticated = authenticated;\n     }\n \n@@ -219,7 +232,7 @@\n         return password;\n     }\n \n-    public void authenticate() {\n+    void authenticate() {\n         AuthPacket packet = new AuthPacket();\n         packet.setPacketId(1);\n         packet.setClientFlags(clientFlags);\n@@ -254,7 +267,7 @@\n         return isClosed() || isQuit.get();\n     }\n \n-    protected void sendQueryCmd(String query, CharsetNames clientCharset) {\n+    public void sendQueryCmd(String query, CharsetNames clientCharset) {\n         CommandPacket packet = new CommandPacket();\n         packet.setPacketId(0);\n         packet.setCommand(MySQLPacket.COM_QUERY);\n@@ -316,7 +329,7 @@\n         if (!sc.isAutocommit() && !sc.isTxstart() && modifiedSQLExecuted) {\n             sc.setTxstart(true);\n         }\n-        synAndDoExecute(xaTxId, rrn, sc.getCharset(), sc.getTxIsolation(), isAutoCommit);\n+        synAndDoExecute(xaTxId, rrn, sc.getCharset(), sc.getTxIsolation(), isAutoCommit, sc.getUsrVariables(), sc.getSysVariables());\n     }\n \n     public String getConnXID(NonBlockingSession session) {\n@@ -329,23 +342,26 @@\n     }\n \n     private void synAndDoExecute(String xaTxID, RouteResultsetNode rrn,\n-                                 CharsetNames clientCharset, int clientTxIsoLation,\n-                                 boolean expectAutocommit) {\n+                                 CharsetNames clientCharset, int clientTxIsolation,\n+                                 boolean expectAutocommit, Map<String, String> usrVariables, Map<String, String> sysVariables) {\n         String xaCmd = null;\n-        boolean conAutoComit = this.autocommit;\n+        boolean conAutoCommit = this.autocommit;\n         String conSchema = this.schema;\n         int xaSyn = 0;\n         if (!expectAutocommit && xaTxID != null && xaStatus == TxState.TX_INITIALIZE_STATE) {\n-            // clientTxIsoLation = Isolations.SERIALIZABLE;\n+            // clientTxIsolation = Isolation.SERIALIZABLE;TODO:NEEDED?\n             xaCmd = \"XA START \" + xaTxID + ';';\n             this.xaStatus = TxState.TX_STARTED_STATE;\n             xaSyn = 1;\n         }\n+        Set<String> toResetSys = new HashSet();\n+        String setSql = getSetSQL(usrVariables, sysVariables, toResetSys);\n+        int setSqlFlag = setSql == null ? 0 : 1;\n         int schemaSyn = conSchema.equals(oldSchema) ? 0 : 1;\n         int charsetSyn = (charsetName.equals(clientCharset)) ? 0 : 1;\n-        int txIsoLationSyn = (txIsolation == clientTxIsoLation) ? 0 : 1;\n-        int autoCommitSyn = (conAutoComit == expectAutocommit) ? 0 : 1;\n-        int synCount = schemaSyn + charsetSyn + txIsoLationSyn + autoCommitSyn + xaSyn;\n+        int txIsolationSyn = (txIsolation == clientTxIsolation) ? 0 : 1;\n+        int autoCommitSyn = (conAutoCommit == expectAutocommit) ? 0 : 1;\n+        int synCount = schemaSyn + charsetSyn + txIsolationSyn + autoCommitSyn + xaSyn + setSqlFlag;\n         if (synCount == 0) {\n             // not need syn connection\n             sendQueryCmd(rrn.getStatement(), clientCharset);\n@@ -355,18 +371,19 @@\n         StringBuilder sb = new StringBuilder();\n         if (schemaSyn == 1) {\n             schemaCmd = getChangeSchemaCommand(conSchema);\n-            // getChangeSchemaCommand(sb, conSchema);\n         }\n-\n         if (charsetSyn == 1) {\n             getCharsetCommand(sb, clientCharset);\n         }\n-        if (txIsoLationSyn == 1) {\n-            getTxIsolationCommand(sb, clientTxIsoLation);\n+        if (txIsolationSyn == 1) {\n+            getTxIsolationCommand(sb, clientTxIsolation);\n         }\n         if (autoCommitSyn == 1) {\n             getAutocommitCommand(sb, expectAutocommit);\n         }\n+        if (setSqlFlag == 1) {\n+            sb.append(setSql);\n+        }\n         if (xaCmd != null) {\n             sb.append(xaCmd);\n         }\n@@ -375,22 +392,73 @@\n                     \" commands \" + sb.toString() + \"schema change:\" +\n                     (schemaCmd != null) + \" con:\" + this);\n         }\n-        metaDataSyned = false;\n+        metaDataSynced = false;\n         statusSync = new StatusSync(conSchema,\n-                clientCharset, clientTxIsoLation, expectAutocommit,\n-                synCount);\n+                clientCharset, clientTxIsolation, expectAutocommit,\n+                synCount, usrVariables, sysVariables, toResetSys);\n         // syn schema\n         if (schemaCmd != null) {\n             schemaCmd.write(this);\n         }\n         // and our query sql to multi command at last\n-        sb.append(rrn.getStatement() + \";\");\n+        sb.append(rrn.getStatement()).append(\";\");\n         // syn and execute others\n         this.sendQueryCmd(sb.toString(), clientCharset);\n         // waiting syn result...\n \n     }\n \n+    private String getSetSQL(Map<String, String> usrVars, Map<String, String> sysVars, Set<String> toResetSys) {\n+        //new final var\n+        List<Pair<String, String>> setVars = new ArrayList<>();\n+        Map<String, String> tmpSysVars = new HashMap<>();\n+        //tmp add all backend sysVariables\n+        tmpSysVars.putAll(sysVariables);\n+        //for all front end sysVariables\n+        for (Map.Entry<String, String> entry : sysVars.entrySet()) {\n+            if (!tmpSysVars.containsKey(entry.getKey())) {\n+                setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+            } else {\n+                String value = tmpSysVars.remove(entry.getKey());\n+                //if backend is not equal frontend, need to reset\n+                if (!StringUtil.equalsIgnoreCase(entry.getValue(), value)) {\n+                    setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+                }\n+            }\n+        }\n+        //tmp now = backend -(backend &&frontend)\n+        for (Map.Entry<String, String> entry : tmpSysVars.entrySet()) {\n+            String value = SystemVariables.getDefaultValue(entry.getKey());\n+            setVars.add(new Pair<>(entry.getKey(), value));\n+            toResetSys.add(entry.getKey());\n+        }\n+\n+        for (Map.Entry<String, String> entry : usrVars.entrySet()) {\n+            if (!usrVariables.containsKey(entry.getKey())) {\n+                setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+            } else {\n+                if (!StringUtil.equalsIgnoreCase(entry.getValue(), usrVariables.get(entry.getKey()))) {\n+                    setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+                }\n+            }\n+        }\n+\n+        if (setVars.size() == 0)\n+            return null;\n+        StringBuilder sb = new StringBuilder(\"set \");\n+        int cnt = 0;\n+        for (Pair<String, String> var : setVars) {\n+            if (cnt > 0) {\n+                sb.append(\",\");\n+            }\n+            sb.append(var.getKey());\n+            sb.append(\"=\");\n+            sb.append(var.getValue());\n+            cnt++;\n+        }\n+        sb.append(\";\");\n+        return sb.toString();\n+    }\n     private static CommandPacket getChangeSchemaCommand(String schema) {\n         CommandPacket cmd = new CommandPacket();\n         cmd.setPacketId(0);\n@@ -402,14 +470,11 @@\n     /**\n      * by wuzh ,execute a query and ignore transaction settings for performance\n      *\n-     * @param query\n-     * @throws UnsupportedEncodingException\n      */\n-    public void query(String query) throws UnsupportedEncodingException {\n+    public void query(String query) {\n         RouteResultsetNode rrn = new RouteResultsetNode(\"default\",\n                 ServerParse.SELECT, query);\n-\n-        synAndDoExecute(null, rrn, this.charsetName, this.txIsolation, true);\n+        synAndDoExecute(null, rrn, this.charsetName, this.txIsolation, true, this.getUsrVariables(), this.getSysVariables());\n \n     }\n \n@@ -432,7 +497,7 @@\n     }\n \n \n-    public boolean isComplexQuery() {\n+    boolean isComplexQuery() {\n         return complexQuery;\n     }\n \n@@ -472,18 +537,23 @@\n     }\n \n     public void release() {\n-        if (!metaDataSyned) { // indicate connection not normalfinished\n+        if (!metaDataSynced) { // indicate connection not normal finished\n             // ,and\n             // we can't know it's syn status ,so\n             // close\n             // it\n             LOGGER.warn(\"can't sure connection syn result,so close it \" + this);\n             this.respHandler = null;\n-            this.close(\"syn status unkown \");\n+            this.close(\"syn status unknown \");\n+            return;\n+        }\n+        if (this.usrVariables.size() > 0) {\n+            this.respHandler = null;\n+            this.close(\"close for clear usrVariables\");\n             return;\n         }\n         complexQuery = false;\n-        metaDataSyned = true;\n+        metaDataSynced = true;\n         attachment = null;\n         statusSync = null;\n         modifiedSQLExecuted = false;\n@@ -541,12 +611,53 @@\n \n     @Override\n     public String toString() {\n-        return \"MySQLConnection [id=\" + id + \", lastTime=\" + lastTime + \", user=\" + user + \", schema=\" + schema +\n-                \", old shema=\" + oldSchema + \", borrowed=\" + borrowed + \", fromSlaveDB=\" + fromSlaveDB + \", threadId=\" +\n-                threadId + \",\" + charsetName.toString() + \", txIsolation=\" + txIsolation + \", autocommit=\" + autocommit +\n-                \", attachment=\" + attachment + \", respHandler=\" + respHandler + \", host=\" + host + \", port=\" + port +\n-                \", statusSync=\" + statusSync + \", writeQueue=\" + this.getWriteQueue().size() +\n-                \", modifiedSQLExecuted=\" + modifiedSQLExecuted + \"]\";\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"MySQLConnection [id=\");\n+        result.append(id);\n+        result.append(\", lastTime=\");\n+        result.append(lastTime);\n+        result.append(\", user=\");\n+        result.append(user);\n+        result.append(\", schema=\");\n+        result.append(schema);\n+        result.append(\", old schema=\");\n+        result.append(oldSchema);\n+        result.append(\", borrowed=\");\n+        result.append(borrowed);\n+        result.append(\", fromSlaveDB=\");\n+        result.append(fromSlaveDB);\n+        result.append(\", threadId=\");\n+        result.append(threadId);\n+        result.append(\",\");\n+        result.append(charsetName.toString());\n+        result.append(\", txIsolation=\");\n+        result.append(txIsolation);\n+        result.append(\", autocommit=\");\n+        result.append(autocommit);\n+        result.append(\", attachment=\");\n+        result.append(attachment);\n+        result.append(\", respHandler=\");\n+        result.append(respHandler);\n+        result.append(\", host=\");\n+        result.append(host);\n+        result.append(\", port=\");\n+        result.append(port);\n+        result.append(\", statusSync=\");\n+        result.append(statusSync);\n+        result.append(\", writeQueue=\");\n+        result.append(this.getWriteQueue().size());\n+        result.append(\", modifiedSQLExecuted=\");\n+        result.append(modifiedSQLExecuted);\n+        if (sysVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfSysVariables());\n+        }\n+        if (usrVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfUsrVariables());\n+        }\n+        result.append(\"]\");\n+        return result.toString();\n     }\n \n     public String compactInfo() {\n@@ -572,7 +683,7 @@\n      * @return if synchronization finished and execute-sql has already been sent\n      * before\n      */\n-    public boolean syncAndExcute() {\n+    public boolean syncAndExecute() {\n         StatusSync sync = this.statusSync;\n         if (sync == null) {\n             return true;\n@@ -592,23 +703,30 @@\n         private final Integer txtIsolation;\n         private final Boolean autocommit;\n         private final AtomicInteger synCmdCount;\n+        private final Map<String, String> usrVariables = new LinkedHashMap<>();\n+        private final Map<String, String> sysVariables = new LinkedHashMap<>();\n \n         StatusSync(String schema,\n                    CharsetNames clientCharset, Integer txtIsolation, Boolean autocommit,\n-                   int synCount) {\n+                   int synCount, Map<String, String> usrVariables, Map<String, String> sysVariables, Set<String> toResetSys) {\n             super();\n             this.schema = schema;\n             this.clientCharset = clientCharset;\n             this.txtIsolation = txtIsolation;\n             this.autocommit = autocommit;\n             this.synCmdCount = new AtomicInteger(synCount);\n+            this.usrVariables.putAll(usrVariables);\n+            this.sysVariables.putAll(sysVariables);\n+            for (String sysVariable : toResetSys) {\n+                this.sysVariables.remove(sysVariable);\n+            }\n         }\n \n-        public boolean synAndExecuted(MySQLConnection conn) {\n+        boolean synAndExecuted(MySQLConnection conn) {\n             int remains = synCmdCount.decrementAndGet();\n             if (remains == 0) { // syn command finished\n                 this.updateConnectionInfo(conn);\n-                conn.metaDataSyned = true;\n+                conn.metaDataSynced = true;\n                 return false;\n             } else if (remains < 0) {\n                 return true;\n@@ -630,7 +748,8 @@\n             if (autocommit != null) {\n                 conn.autocommit = autocommit;\n             }\n+            conn.sysVariables = sysVariables;\n+            conn.usrVariables = usrVariables;\n         }\n-\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/config/Versions.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/config/Versions.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/config/Versions.java\t2024-10-02 23:00:42.265994215 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/config/Versions.java\t2024-10-02 23:00:42.153993068 +1000\n@@ -12,7 +12,7 @@\n \n     public static final byte PROTOCOL_VERSION = 10;\n \n-    private static byte[] serverVersion = \"5.6.29-dble-2.17.08.0-20240827173309\".getBytes();\n+    private static byte[] serverVersion = \"5.6.29-dble-2.17.08.0-20240827174911\".getBytes();\n     public static final byte[] VERSION_COMMENT = \"dble Server (ActionTech)\".getBytes();\n     public static final String ANNOTATION_NAME = \"dble:\";\n     public static final String ROOT_PREFIX = \"dble\";\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java\t2024-10-02 23:00:42.269994256 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java\t2024-10-02 23:00:42.157993109 +1000\n@@ -32,7 +32,7 @@\n     private ShowBackend() {\n     }\n \n-    private static final int FIELD_COUNT = 18;\n+    private static final int FIELD_COUNT = 20;\n     private static final ResultSetHeaderPacket HEADER = PacketUtil.getHeader(FIELD_COUNT);\n     private static final FieldPacket[] FIELDS = new FieldPacket[FIELD_COUNT];\n     private static final EOFPacket EOF = new EOFPacket();\n@@ -41,8 +41,7 @@\n         int i = 0;\n         byte packetId = 0;\n         HEADER.setPacketId(++packetId);\n-        FIELDS[i] = PacketUtil.getField(\"processor\",\n-                Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"processor\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n         FIELDS[i] = PacketUtil.getField(\"ID\", Fields.FIELD_TYPE_LONG);\n         FIELDS[i++].setPacketId(++packetId);\n@@ -76,10 +75,15 @@\n         FIELDS[i++].setPacketId(++packetId);\n         FIELDS[i] = PacketUtil.getField(\"CHARACTER_SET_RESULTS\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n-        FIELDS[i] = PacketUtil.getField(\"TXLEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"TX_ISOLATION_LEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n         FIELDS[i] = PacketUtil.getField(\"AUTOCOMMIT\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+        FIELDS[i] = PacketUtil.getField(\"SYS_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+        FIELDS[i] = PacketUtil.getField(\"USER_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i].setPacketId(++packetId);\n+\n         EOF.setPacketId(++packetId);\n     }\n \n@@ -132,6 +136,8 @@\n         row.add(conn.getCharset().getResults().getBytes());\n         row.add((conn.getTxIsolation() + \"\").getBytes());\n         row.add((conn.isAutocommit() + \"\").getBytes());\n+        row.add(StringUtil.encode(conn.getStringOfSysVariables(), charset));\n+        row.add(StringUtil.encode(conn.getStringOfUsrVariables(), charset));\n         return row;\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java\t2024-10-02 23:00:42.269994256 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java\t2024-10-02 23:00:42.157993109 +1000\n@@ -33,7 +33,7 @@\n     private ShowConnection() {\n     }\n \n-    private static final int FIELD_COUNT = 17;\n+    private static final int FIELD_COUNT = 19;\n     private static final ResultSetHeaderPacket HEADER = PacketUtil.getHeader(FIELD_COUNT);\n     private static final FieldPacket[] FIELDS = new FieldPacket[FIELD_COUNT];\n     private static final EOFPacket EOF = new EOFPacket();\n@@ -80,8 +80,7 @@\n         FIELDS[i] = PacketUtil.getField(\"NET_OUT\", Fields.FIELD_TYPE_LONGLONG);\n         FIELDS[i++].setPacketId(++packetId);\n \n-        FIELDS[i] = PacketUtil.getField(\"ALIVE_TIME(S)\",\n-                Fields.FIELD_TYPE_LONGLONG);\n+        FIELDS[i] = PacketUtil.getField(\"ALIVE_TIME(S)\", Fields.FIELD_TYPE_LONGLONG);\n         FIELDS[i++].setPacketId(++packetId);\n \n         FIELDS[i] = PacketUtil.getField(\"RECV_BUFFER\", Fields.FIELD_TYPE_LONG);\n@@ -90,11 +89,16 @@\n         FIELDS[i] = PacketUtil.getField(\"SEND_QUEUE\", Fields.FIELD_TYPE_LONG);\n         FIELDS[i++].setPacketId(++packetId);\n \n-        FIELDS[i] = PacketUtil.getField(\"TXLEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"TX_ISOLATION_LEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n \n-        FIELDS[i] = PacketUtil.getField(\"AUTOCOMMIT\",\n-                Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"AUTOCOMMIT\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+\n+        FIELDS[i] = PacketUtil.getField(\"SYS_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+\n+        FIELDS[i] = PacketUtil.getField(\"USER_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i].setPacketId(++packetId);\n \n         EOF.setPacketId(++packetId);\n@@ -156,15 +160,16 @@\n         row.add(IntegerUtil.toBytes(c.getWriteQueue().size()));\n \n         String txLevel = \"\";\n-        String txAutommit = \"\";\n+        String autocommit = \"\";\n         if (c instanceof ServerConnection) {\n-            ServerConnection mysqlC = (ServerConnection) c;\n-            txLevel = mysqlC.getTxIsolation() + \"\";\n-            txAutommit = mysqlC.isAutocommit() + \"\";\n+            ServerConnection serverConn = (ServerConnection) c;\n+            txLevel = serverConn.getTxIsolation() + \"\";\n+            autocommit = serverConn.isAutocommit() + \"\";\n         }\n         row.add(txLevel.getBytes());\n-        row.add(txAutommit.getBytes());\n-\n+        row.add(autocommit.getBytes());\n+        row.add(StringUtil.encode(c.getStringOfSysVariables(), charset));\n+        row.add(StringUtil.encode(c.getStringOfUsrVariables(), charset));\n         return row;\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java\t2024-10-02 23:00:42.269994256 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java\t2024-10-02 23:00:42.157993109 +1000\n@@ -18,7 +18,6 @@\n import com.actiontech.dble.net.mysql.RowDataPacket;\n import com.actiontech.dble.util.StringUtil;\n \n-import java.io.UnsupportedEncodingException;\n import java.nio.ByteBuffer;\n import java.util.Map;\n import java.util.concurrent.ConcurrentMap;\n@@ -176,8 +175,6 @@\n         }\n         // write eof\n         buffer = TOTAL_EOF.write(buffer, c, true);\n-        // write rows\n-        byte packetId = TOTAL_EOF.getPacketId();\n \n         int useOffHeapForMerge = DbleServer.getInstance().getConfig().\n                 getSystem().getUseOffHeapForMerge();\n@@ -250,7 +247,8 @@\n         }\n \n         row.add(StringUtil.encode(resevedForOs > 0 ? JavaUtils.bytesToString2(resevedForOs) : \"0\", c.getCharset().getResults()));\n-\n+        // write rows\n+        byte packetId = TOTAL_EOF.getPacketId();\n         row.setPacketId(++packetId);\n         buffer = row.write(buffer, c, true);\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/AbstractConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/AbstractConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/AbstractConnection.java\t2024-10-02 23:00:42.273994297 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/AbstractConnection.java\t2024-10-02 23:00:42.161993150 +1000\n@@ -5,7 +5,6 @@\n */\n package com.actiontech.dble.net;\n \n-import com.actiontech.dble.backend.mysql.CharsetUtil;\n import com.actiontech.dble.net.mysql.CharsetNames;\n import com.actiontech.dble.net.mysql.MySQLPacket;\n import com.actiontech.dble.server.SystemVariables;\n@@ -20,6 +19,7 @@\n import java.nio.channels.AsynchronousChannel;\n import java.nio.channels.NetworkChannel;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -58,6 +58,8 @@\n     protected volatile boolean isSupportCompress = false;\n     protected final ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue = new ConcurrentLinkedQueue<>();\n     protected final ConcurrentLinkedQueue<byte[]> compressUnfinishedDataQueue = new ConcurrentLinkedQueue<>();\n+    protected volatile Map<String, String> usrVariables;\n+    protected volatile Map<String, String> sysVariables;\n \n     private long idleTimeout;\n \n@@ -83,31 +85,16 @@\n         this.isClosed = new AtomicBoolean(false);\n         this.socketWR = null;\n     }\n-    public boolean setCollationConnection(String collation) {\n-        int ci = CharsetUtil.getCollationIndex(collation);\n-        if (ci <= 0) {\n-            return false;\n-        }\n+    public void setCollationConnection(String collation) {\n         charsetName.setCollation(collation);\n-        return true;\n     }\n \n-    public boolean setCharacterConnection(String charset) {\n-        String collationName = CharsetUtil.getDefaultCollation(charset);\n-        if (collationName == null) {\n-            return false;\n-        }\n+    public void setCharacterConnection(String collationName) {\n         charsetName.setCollation(collationName);\n-        return true;\n     }\n \n-    public boolean setCharacterResults(String name) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0 && !name.equals(\"null\")) {\n-            return false;\n-        }\n+    public void setCharacterResults(String name) {\n         charsetName.setResults(name);\n-        return true;\n     }\n \n \n@@ -115,36 +102,17 @@\n         this.charsetName = charsetName.clone();\n     }\n \n-    public boolean setCharacterClient(String name) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0) {\n-            return false;\n-        }\n+    public void setCharacterClient(String name) {\n         charsetName.setClient(name);\n-        return true;\n     }\n \n-    public boolean setCharacterSet(String name) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0) {\n-            return false;\n-        }\n+    public void setCharacterSet(String name) {\n         charsetName.setClient(name);\n         charsetName.setResults(name);\n         charsetName.setCollation(SystemVariables.getDefaultValue(\"collation_database\"));\n-        return true;\n     }\n \n     public boolean setNames(String name, String collationName) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0) {\n-            return false;\n-        }\n-        if (collationName == null) {\n-            collationName = CharsetUtil.getDefaultCollation(name);\n-        } else if (CharsetUtil.getCollationIndex(collationName) <= 0) {\n-            return false;\n-        }\n         charsetName.setNames(name, collationName);\n         return true;\n     }\n@@ -198,6 +166,14 @@\n         return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime, lastReadTime) + idleTimeout;\n     }\n \n+    public Map<String, String> getUsrVariables() {\n+        return usrVariables;\n+    }\n+\n+    public Map<String, String> getSysVariables() {\n+        return sysVariables;\n+    }\n+\n     public NetworkChannel getChannel() {\n         return channel;\n     }\n@@ -583,6 +559,39 @@\n         }\n     }\n \n+    public String getStringOfSysVariables() {\n+        StringBuilder sbSysVariables = new StringBuilder();\n+        int cnt = 0;\n+        if (sysVariables != null) {\n+            for (Map.Entry sysVariable : sysVariables.entrySet()) {\n+                if (cnt > 0) {\n+                    sbSysVariables.append(\",\");\n+                }\n+                sbSysVariables.append(sysVariable.getKey());\n+                sbSysVariables.append(\"=\");\n+                sbSysVariables.append(sysVariable.getValue());\n+                cnt++;\n+            }\n+        }\n+        return sbSysVariables.toString();\n+    }\n+\n+    public String getStringOfUsrVariables() {\n+        StringBuilder sbUsrVariables = new StringBuilder();\n+        int cnt = 0;\n+        if (usrVariables != null) {\n+            for (Map.Entry usrVariable : usrVariables.entrySet()) {\n+                if (cnt > 0) {\n+                    sbUsrVariables.append(\",\");\n+                }\n+                sbUsrVariables.append(usrVariable.getKey());\n+                sbUsrVariables.append(\"=\");\n+                sbUsrVariables.append(usrVariable.getValue());\n+                cnt++;\n+            }\n+        }\n+        return sbUsrVariables.toString();\n+    }\n     public void onConnectfinish() {\n         LOGGER.debug(\"The backend conntinon has finished connecting\");\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java\t2024-10-02 23:00:42.273994297 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java\t2024-10-02 23:00:42.161993150 +1000\n@@ -32,8 +32,7 @@\n  */\n public class OkPacket extends MySQLPacket {\n     public static final byte FIELD_COUNT = 0x00;\n-    public static final byte[] OK = new byte[]{7, 0, 0, 1, 0, 0, 0, 2, 0, 0,\n-            0};\n+    public static final byte[] OK = new byte[]{7, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0};\n \n     private byte fieldCount = FIELD_COUNT;\n     private long affectedRows;\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql: ResetConnectionPacket.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java\t2024-10-02 23:00:42.281994379 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java\t2024-10-02 23:00:42.173993273 +1000\n@@ -82,7 +82,7 @@\n \n     @Override\n     public void okResponse(byte[] ok, BackendConnection conn) {\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             ((SequenceVal) conn.getAttachment()).dbfinished = true;\n             conn.release();\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler: SetCallBack.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/handler/SetHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\t2024-10-02 23:00:42.281994379 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\t2024-10-02 23:00:42.173993273 +1000\n@@ -11,15 +11,27 @@\n import com.actiontech.dble.config.Isolations;\n import com.actiontech.dble.log.transaction.TxnLogHelper;\n import com.actiontech.dble.net.mysql.OkPacket;\n+import com.actiontech.dble.route.parser.util.Pair;\n import com.actiontech.dble.route.parser.util.ParseUtil;\n import com.actiontech.dble.server.ServerConnection;\n-import com.actiontech.dble.server.parser.ServerParseSet;\n-import com.actiontech.dble.util.SetIgnoreUtil;\n+import com.actiontech.dble.server.SystemVariables;\n+import com.actiontech.dble.sqlengine.OneRawSQLQueryResultHandler;\n+import com.actiontech.dble.sqlengine.SetTestJob;\n import com.actiontech.dble.util.StringUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.actiontech.dble.server.parser.ServerParseSet.*;\n+import com.alibaba.druid.sql.ast.SQLExpr;\n+import com.alibaba.druid.sql.ast.SQLStatement;\n+import com.alibaba.druid.sql.ast.expr.*;\n+import com.alibaba.druid.sql.ast.statement.SQLAssignItem;\n+import com.alibaba.druid.sql.ast.statement.SQLSetStatement;\n+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetCharSetStatement;\n+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetNamesStatement;\n+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement;\n+import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;\n+import com.alibaba.druid.sql.parser.SQLStatementParser;\n+\n+import java.sql.SQLSyntaxErrorException;\n+import java.util.ArrayList;\n+import java.util.List;\n \n\n@@ -31,259 +43,712 @@\n     private SetHandler() {\n     }\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(SetHandler.class);\n-\n     private static final byte[] AC_OFF = new byte[]{7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};\n \n+    public enum KeyType {\n+        SYNTAX_ERROR,\n+        XA,\n+        AUTOCOMMIT,\n+        NAMES,\n+        CHARSET,\n+        CHARACTER_SET_CLIENT,\n+        CHARACTER_SET_CONNECTION,\n+        CHARACTER_SET_RESULTS,\n+        COLLATION_CONNECTION,\n+        SYSTEM_VARIABLES,\n+        USER_VARIABLES,\n+        TX_READ_ONLY,\n+        TX_ISOLATION\n+    }\n+\n     public static void handle(String stmt, ServerConnection c, int offset) {\n         if (!ParseUtil.isSpace(stmt.charAt(offset))) {\n             c.writeErrMessage(ErrorCode.ERR_WRONG_USED, stmt + \" is not supported\");\n         }\n-        int rs = ServerParseSet.parse(stmt, offset);\n-        switch (rs & 0xff) {\n-            case MULTI_SET:\n-                //set split with ','\n-                if (!parserMultiSet(stmt.substring(offset), c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                }\n-                break;\n-            case AUTOCOMMIT_ON:\n-                if (c.isAutocommit()) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        try {\n+            String smt = convertCharsetKeyWord(stmt);\n+            List<Pair<KeyType, Pair<String, String>>> contextTask = new ArrayList<>();\n+            if (handleSetStatement(smt, c, contextTask) && contextTask.size() > 0) {\n+                setStmtCallback(stmt, c, contextTask);\n+            }\n+        } catch (SQLSyntaxErrorException e) {\n+            c.writeErrMessage(ErrorCode.ER_PARSE_ERROR, e.toString());\n+        }\n+    }\n+\n+    private static SQLStatement parseSQL(String stmt) throws SQLSyntaxErrorException {\n+        SQLStatementParser parser = new MySqlStatementParser(stmt);\n+        try {\n+            return parser.parseStatement();\n+        } catch (Exception t) {\n+            if (t.getMessage() != null) {\n+                throw new SQLSyntaxErrorException(t.getMessage());\n+            } else {\n+                throw new SQLSyntaxErrorException(t);\n+            }\n+        }\n+    }\n+    private static boolean handleSetStatement(String stmt, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) throws SQLSyntaxErrorException {\n+        SQLStatement statement = parseSQL(stmt);\n+        if (statement instanceof SQLSetStatement) {\n+            List<SQLAssignItem> assignItems = ((SQLSetStatement) statement).getItems();\n+            if (assignItems.size() == 1 && contextTask.size() == 0) {\n+                return handleSingleVariable(stmt, assignItems.get(0), c, contextTask);\n+            } else {\n+                return handleSetMultiStatement(assignItems, c, contextTask);\n+            }\n+        } else if (statement instanceof MySqlSetNamesStatement) {\n+            MySqlSetNamesStatement setNamesStatement = (MySqlSetNamesStatement) statement;\n+            if (contextTask.size() > 0 || stmt.contains(\",\")) {\n+                if (handleSetNamesInMultiStmt(c, setNamesStatement.getCharSet(), setNamesStatement.getCollate(), contextTask)) {\n+                    int index = stmt.indexOf(\",\");\n+                    String newStmt = \"set \" + stmt.substring(index + 1);\n+                    return handleSetStatement(newStmt, c, contextTask);\n                 } else {\n-                    c.commit(\"commit[because of \" + stmt + \"]\");\n-                    c.setAutocommit(true);\n+                    return false;\n                 }\n-                break;\n-            case AUTOCOMMIT_OFF: {\n-                if (c.isAutocommit()) {\n-                    c.setAutocommit(false);\n-                    TxnLogHelper.putTxnLog(c, stmt);\n-                }\n-                c.write(c.writeToBuffer(AC_OFF, c.allocate()));\n-                break;\n+            } else {\n+                return handleSingleSetNames(stmt, c, setNamesStatement);\n             }\n-            case XA_FLAG_ON: {\n-                if (c.isTxstart() && c.getSession2().getSessionXaID() == null) {\n-                    c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd on can't used before ending a transaction\");\n-                    return;\n+        } else if (statement instanceof MySqlSetCharSetStatement) {\n+            MySqlSetCharSetStatement setCharSetStatement = (MySqlSetCharSetStatement) statement;\n+            if (contextTask.size() > 0 || stmt.contains(\",\")) {\n+                if (handleCharsetInMultiStmt(c, setCharSetStatement.getCharSet(), contextTask)) {\n+                    int index = stmt.indexOf(\",\");\n+                    String newStmt = \"set \" + stmt.substring(index + 1);\n+                    return handleSetStatement(newStmt, c, contextTask);\n+                } else {\n+                    return false;\n                 }\n-                c.getSession2().setXaTxEnabled(true);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                break;\n+            } else {\n+                return handleSingleSetCharset(stmt, c, setCharSetStatement);\n             }\n-            case XA_FLAG_OFF: {\n-                if (c.isTxstart() && c.getSession2().getSessionXaID() != null) {\n-                    c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd off can't used before ending a transaction\");\n-                    return;\n-                }\n-                c.getSession2().setXaTxEnabled(false);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                return;\n+        } else if (statement instanceof MySqlSetTransactionStatement) {\n+            return handleTransaction(c, (MySqlSetTransactionStatement) statement);\n+        } else {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, stmt + \" is not recognized and ignored\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSetNamesInMultiStmt(ServerConnection c, String charset, String collate, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String[] charsetInfo = checkSetNames(charset, collate);\n+        if (charsetInfo != null) {\n+            contextTask.add(new Pair<>(KeyType.NAMES, new Pair<>(charsetInfo[0], charsetInfo[1])));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set  '\" + charset + \" or collate '\" + collate + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleSetNames(String stmt, ServerConnection c, MySqlSetNamesStatement statement) {\n+        String[] charsetInfo = checkSetNames(statement.getCharSet(), statement.getCollate());\n+        if (charsetInfo != null) {\n+            c.setNames(charsetInfo[0], charsetInfo[1]);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set in statement '\" + stmt + \"\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleSetCharset(String stmt, ServerConnection c, MySqlSetCharSetStatement statement) {\n+        String charset = getCharset(statement.getCharSet());\n+        if (charset != null) {\n+            c.setCharacterSet(charset);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set in statement '\" + stmt + \"\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSetMultiStatement(List<SQLAssignItem> assignItems, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        for (SQLAssignItem assignItem : assignItems) {\n+            if (!handleVariableInMultiStmt(assignItem, c, contextTask)) {\n+                return false;\n             }\n-            case TX_READ_UNCOMMITTED: {\n-                c.setTxIsolation(Isolations.READ_UNCOMMITTED);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        }\n+        return true;\n+    }\n+\n+    //execute multiStmt and callback to reset conn\n+    private static void setStmtCallback(String multiStmt, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        c.setContextTask(contextTask);\n+        OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(new String[0], new SetCallBack(c));\n+        SetTestJob sqlJob = new SetTestJob(multiStmt, resultHandler, c);\n+        sqlJob.run();\n+    }\n+\n+    private static boolean handleVariableInMultiStmt(SQLAssignItem assignItem, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String key = handleSetKey(assignItem, c);\n+        if (key == null) {\n+            return false;\n+        }\n+        SQLExpr valueExpr = assignItem.getValue();\n+        if (!checkValue(valueExpr)) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + assignItem.getValue() + \"'\");\n+            return false;\n+        }\n+        KeyType keyType = parseKeyType(key, true, KeyType.SYSTEM_VARIABLES);\n+        switch (keyType) {\n+            case XA:\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd can't used in multi-set statement\");\n+                return false;\n+            case AUTOCOMMIT:\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set autocommit cmd can't used in multi-set statement\");\n+                return false;\n+            case NAMES: {\n+                String charset = parseStringValue(valueExpr);\n+                //TODO:druid lost collation info\n+                if (!handleSetNamesInMultiStmt(c, charset, null, contextTask)) return false;\n                 break;\n             }\n-            case TX_READ_COMMITTED: {\n-                c.setTxIsolation(Isolations.READ_COMMITTED);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARSET: {\n+                String charset = parseStringValue(valueExpr);\n+                if (!handleCharsetInMultiStmt(c, charset, contextTask)) return false;\n                 break;\n             }\n-            case TX_REPEATED_READ: {\n-                c.setTxIsolation(Isolations.REPEATED_READ);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARACTER_SET_CLIENT:\n+                if (!handleCharsetClientInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            }\n-            case TX_SERIALIZABLE: {\n-                c.setTxIsolation(Isolations.SERIALIZABLE);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARACTER_SET_CONNECTION:\n+                if (!handleCharsetConnInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            }\n-            case TX_READ_WRITE:\n-                c.setSessionReadOnly(false);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARACTER_SET_RESULTS:\n+                if (!handleCharsetResultsInMultiStmt(c, contextTask, valueExpr)) return false;\n+                break;\n+            case COLLATION_CONNECTION:\n+                if (!handleCollationConnInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n             case TX_READ_ONLY:\n-                c.setSessionReadOnly(true);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+                if (!handleReadOnlyInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            case NAMES: {\n-                String names = stmt.substring(rs >>> 8).trim();\n-                if (handleSetNames(names, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set\" + names + \"\");\n-                }\n+            case TX_ISOLATION:\n+                if (!handleTxIsolationInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            }\n-            case CHARACTER_SET_CLIENT:\n-                String charsetClient = stmt.substring(rs >>> 8).trim().toLowerCase();\n-                if (charsetClient.equals(\"null\")) {\n-                    c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n-                }\n-                if (handleCharSetClient(charsetClient, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charsetClient + \"\");\n+            case SYSTEM_VARIABLES:\n+                if (SystemVariables.getDefaultValue(key) == null) {\n+                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"system variable \" + key + \" is not supported\");\n                 }\n+                contextTask.add(new Pair<>(KeyType.SYSTEM_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n                 break;\n-            case CHARACTER_SET_CONNECTION:\n-                String charsetConnection = stmt.substring(rs >>> 8).trim().toLowerCase();\n-                if (charsetConnection.equals(\"null\")) {\n-                    c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_connection' can't be set to the value of 'NULL'\");\n-                }\n-                if (handleCharSetConnection(charsetConnection, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charsetConnection + \"\");\n-                }\n+            case USER_VARIABLES:\n+                contextTask.add(new Pair<>(KeyType.USER_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n                 break;\n+            default:\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, key + \" is not supported\");\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleCharsetInMultiStmt(ServerConnection c, String charset, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String charsetInfo = getCharset(charset);\n+        if (charsetInfo != null) {\n+            contextTask.add(new Pair<>(KeyType.CHARSET, new Pair<String, String>(charsetInfo, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charset + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleTxIsolationInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String value = parseStringValue(valueExpr);\n+        Integer txIsolation = getIsolationLevel(value);\n+        if (txIsolation == null) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"Variable 'tx_isolation' can't be set to the value of '\" + value + \"'\");\n+            return false;\n+        }\n+        contextTask.add(new Pair<>(KeyType.TX_ISOLATION, new Pair<String, String>(String.valueOf(txIsolation), null)));\n+        return true;\n+    }\n+\n+    private static boolean handleReadOnlyInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'tx_read_only|transaction_read_only'\");\n+            return false;\n+        } else if (switchStatus) {\n+            contextTask.add(new Pair<>(KeyType.TX_READ_ONLY, new Pair<String, String>(\"true\", null)));\n+        } else {\n+            contextTask.add(new Pair<>(KeyType.TX_READ_ONLY, new Pair<String, String>(\"false\", null)));\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleCollationConnInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String collation = parseStringValue(valueExpr);\n+        if (checkCollation(collation)) {\n+            contextTask.add(new Pair<>(KeyType.COLLATION_CONNECTION, new Pair<String, String>(collation, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, \"Unknown collation '\" + collation + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleCharsetResultsInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String charsetResult = parseStringValue(valueExpr);\n+        if (charsetResult.equals(\"null\") || checkCharset(charsetResult)) {\n+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_RESULTS, new Pair<String, String>(charsetResult, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetResult + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleCharsetConnInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String charsetConnection = parseStringValue(valueExpr);\n+        if (charsetConnection.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_connection' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        String collationName = CharsetUtil.getDefaultCollation(charsetConnection);\n+        if (collationName != null) {\n+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_CONNECTION, new Pair<String, String>(collationName, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetConnection + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleCharsetClientInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String charsetClient = parseStringValue(valueExpr);\n+        if (charsetClient.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        if (checkCharset(charsetClient)) {\n+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_CLIENT, new Pair<String, String>(charsetClient, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetClient + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleVariable(String stmt, SQLAssignItem assignItem, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String key = handleSetKey(assignItem, c);\n+        if (key == null) return false;\n+        SQLExpr valueExpr = assignItem.getValue();\n+        if (!checkValue(valueExpr)) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + assignItem.getValue() + \"'\");\n+            return false;\n+        }\n+        KeyType keyType = parseKeyType(key, true, KeyType.SYSTEM_VARIABLES);\n+        switch (keyType) {\n+            case XA:\n+                return handleSingleXA(c, valueExpr);\n+            case AUTOCOMMIT:\n+                return handleSingleAutocommit(stmt, c, valueExpr);\n+            case CHARACTER_SET_CLIENT:\n+                return handleSingleCharsetClient(c, valueExpr);\n+            case CHARACTER_SET_CONNECTION:\n+                return handleSingleCharsetConnection(c, valueExpr);\n             case CHARACTER_SET_RESULTS:\n-                String charsetResult = stmt.substring(rs >>> 8).trim();\n-                if (handleCharSetResults(charsetResult, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charsetResult + \"\");\n-                }\n-                break;\n-            case CHARACTER_SET_NAME: {\n-                String charset = stmt.substring(rs >>> 8).trim();\n-                if (handleCharSetName(charset, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charset + \"\");\n+                return handleSingleCharsetResults(c, valueExpr);\n+            case COLLATION_CONNECTION:\n+                return handleCollationConnection(c, valueExpr);\n+            case TX_READ_ONLY:\n+                return handleTxReadOnly(c, valueExpr);\n+            case TX_ISOLATION:\n+                return handleTxIsolation(c, valueExpr);\n+            case SYSTEM_VARIABLES:\n+                if (SystemVariables.getDefaultValue(key) == null) {\n+                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"system variable \" + key + \" is not supported\");\n+                    return false;\n                 }\n-                break;\n+                contextTask.add(new Pair<>(KeyType.SYSTEM_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n+                return true;\n+            case USER_VARIABLES:\n+                contextTask.add(new Pair<>(KeyType.USER_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n+                return true;\n+            default:\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, stmt + \" is not supported\");\n+                return false;\n+        }\n+    }\n+\n+    private static boolean handleTxReadOnly(ServerConnection c, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'tx_read_only|transaction_read_only'\");\n+            return false;\n+        } else if (switchStatus) {\n+            c.setSessionReadOnly(true);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        } else {\n+            c.setSessionReadOnly(false);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleTxIsolation(ServerConnection c, SQLExpr valueExpr) {\n+        String value = parseStringValue(valueExpr);\n+        Integer txIsolation = getIsolationLevel(value);\n+        if (txIsolation == null) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"Variable 'tx_isolation' can't be set to the value of '\" + value + \"'\");\n+            return false;\n+        }\n+        c.setTxIsolation(txIsolation);\n+        c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        return true;\n+    }\n+\n+    private static Integer getIsolationLevel(String value) {\n+        switch (value) {\n+            case \"read-uncommitted\":\n+                return Isolations.READ_UNCOMMITTED;\n+            case \"read-committed\":\n+                return Isolations.READ_COMMITTED;\n+            case \"repeatable-read\":\n+                return Isolations.REPEATED_READ;\n+            case \"serializable\":\n+                return Isolations.SERIALIZABLE;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    private static boolean handleCollationConnection(ServerConnection c, SQLExpr valueExpr) {\n+        String collation = parseStringValue(valueExpr);\n+        if (checkCollation(collation)) {\n+            c.setCollationConnection(collation);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, \"Unknown collation '\" + collation + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleCharsetResults(ServerConnection c, SQLExpr valueExpr) {\n+        String charsetResult = parseStringValue(valueExpr);\n+        if (charsetResult.equals(\"null\") || checkCharset(charsetResult)) {\n+            c.setCharacterResults(charsetResult);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetResult + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleCharsetConnection(ServerConnection c, SQLExpr valueExpr) {\n+        String charsetConnection = parseStringValue(valueExpr);\n+        if (charsetConnection.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_connection' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        String collationName = CharsetUtil.getDefaultCollation(charsetConnection);\n+        if (collationName != null) {\n+            c.setCharacterConnection(collationName);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetConnection + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleCharsetClient(ServerConnection c, SQLExpr valueExpr) {\n+        String charsetClient = parseStringValue(valueExpr);\n+        if (charsetClient.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        if (checkCharset(charsetClient)) {\n+            c.setCharacterClient(charsetClient);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetClient + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleAutocommit(String stmt, ServerConnection c, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'AUTOCOMMIT'\");\n+            return false;\n+        } else if (switchStatus) {\n+            if (c.isAutocommit()) {\n+                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            } else {\n+                c.commit(\"commit[because of \" + stmt + \"]\");\n+                c.setAutocommit(true);\n+            }\n+        } else {\n+            if (c.isAutocommit()) {\n+                c.setAutocommit(false);\n+                TxnLogHelper.putTxnLog(c, stmt);\n             }\n-            case COLLATION_CONNECTION: {\n-                String collation = stmt.substring(rs >>> 8).trim();\n-                if (handleCollationConn(collation, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, \"Unknown collation \" + collation + \"\");\n-                }\n-                break;\n+            c.write(c.writeToBuffer(AC_OFF, c.allocate()));\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleSingleXA(ServerConnection c, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'XA'\");\n+            return false;\n+        } else if (switchStatus) {\n+            if (c.isTxstart() && c.getSession2().getSessionXaID() == null) {\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd on can't used before ending a transaction\");\n+                return false;\n+            }\n+            c.getSession2().setXaTxEnabled(true);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            if (c.isTxstart() && c.getSession2().getSessionXaID() != null) {\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd off can't used before ending a transaction\");\n+                return false;\n+            }\n+            c.getSession2().setXaTxEnabled(false);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        }\n+    }\n+\n+    // druid not support 'set charset' ,change to 'set character set'\n+    private static String convertCharsetKeyWord(String stmt) {\n+        StringBuilder result = new StringBuilder();\n+        String toCheck = stmt.toLowerCase();\n+        int index = toCheck.indexOf(\"charset\");\n+        int tailStart = 0;\n+        while (index > 0) {\n+            char before = toCheck.charAt(index - 1);\n+            char after = toCheck.charAt(index + 7);\n+            if ((ParseUtil.isSpace(before) || ',' == before) && ParseUtil.isSpace(after)) {\n+                result.append(stmt.substring(tailStart, index));\n+                result.append(\"character set\");\n+            }\n+            tailStart = index + 7;\n+            index = toCheck.indexOf(\"charset\", tailStart);\n+        }\n+        if (result.length() > 0) {\n+            result.append(stmt.substring(tailStart));\n+            return result.toString();\n+        }\n+        return stmt;\n+    }\n+\n+    private static String handleSetKey(SQLAssignItem assignItem, ServerConnection c) {\n+        if (assignItem.getTarget() instanceof SQLPropertyExpr) {\n+            SQLPropertyExpr target = (SQLPropertyExpr) assignItem.getTarget();\n+            if (!(target.getOwner() instanceof SQLVariantRefExpr)) {\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + target + \"'\");\n+                return null;\n             }\n-            case GLOBAL:\n+            SQLVariantRefExpr owner = (SQLVariantRefExpr) target.getOwner();\n+            if (owner.isGlobal()) {\n                 c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n-                break;\n+                return null;\n+            }\n+            return target.getName();\n+        } else if (assignItem.getTarget() instanceof SQLVariantRefExpr) {\n+            SQLVariantRefExpr target = (SQLVariantRefExpr) assignItem.getTarget();\n+            if (target.isGlobal()) {\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n+                return null;\n+            }\n+            return target.getName();\n+        } else if (assignItem.getTarget() instanceof SQLIdentifierExpr) {\n+            SQLIdentifierExpr target = (SQLIdentifierExpr) assignItem.getTarget();\n+            return target.getLowerName();\n+        } else {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + assignItem.getTarget() + \"'\");\n+            return null;\n+        }\n+    }\n+\n+    private static boolean checkValue(SQLExpr valueExpr) {\n+        return (valueExpr instanceof SQLCharExpr) || (valueExpr instanceof SQLIdentifierExpr) ||\n+                (valueExpr instanceof SQLIntegerExpr);\n+    }\n+\n+    private static KeyType parseKeyType(String key, boolean origin, KeyType defaultVariables) {\n+        switch (key.toLowerCase()) {\n+            case \"xa\":\n+                return KeyType.XA;\n+            case \"autocommit\":\n+                return KeyType.AUTOCOMMIT;\n+            case \"collation_connection\":\n+                return KeyType.COLLATION_CONNECTION;\n+            case \"character_set_client\":\n+                return KeyType.CHARACTER_SET_CLIENT;\n+            case \"character_set_results\":\n+                return KeyType.CHARACTER_SET_RESULTS;\n+            case \"character_set_connection\":\n+                return KeyType.CHARACTER_SET_CONNECTION;\n+            case \"transaction_isolation\":\n+            case \"tx_isolation\":\n+                return KeyType.TX_ISOLATION;\n+            case \"transaction_read_only\":\n+            case \"tx_read_only\":\n+                return KeyType.TX_READ_ONLY;\n+            case \"names\":\n+                return KeyType.NAMES;\n+            case \"character set\":\n+                return KeyType.CHARSET;\n             default:\n-                boolean ignore = SetIgnoreUtil.isIgnoreStmt(stmt);\n-                if (!ignore) {\n-                    StringBuilder s = new StringBuilder();\n-                    String warn = stmt + \" is not recognized and ignored\";\n-                    LOGGER.warn(s.append(c).append(warn).toString());\n-                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, warn);\n+                if (!origin && key.startsWith(\"@\")) {\n+                    return KeyType.SYNTAX_ERROR;\n+                } else if (key.startsWith(\"@@\")) {\n+                    return parseKeyType(key.substring(2), false, KeyType.SYSTEM_VARIABLES);\n+                } else if (key.startsWith(\"@\")) {\n+                    return parseKeyType(key.substring(1), false, KeyType.USER_VARIABLES);\n                 } else {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+                    return defaultVariables;\n                 }\n         }\n     }\n \n-    //TODO:\n-    private static boolean parserMultiSet(String setSQL, ServerConnection c) {\n-        String[] setStatements = setSQL.split(\",\");\n-        for (String statement : setStatements) {\n-            boolean setError = false;\n-            int rs = ServerParseSet.parse(statement, 0);\n-            switch (rs & 0xff) {\n-                case AUTOCOMMIT_ON:\n+    private static Boolean isSwitchOn(SQLExpr valueExpr) {\n+        if (valueExpr instanceof SQLIntegerExpr) {\n+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n+            int iValue = value.getNumber().intValue();\n+            if (iValue < 0 || iValue > 1) {\n+                return null;\n+            }\n+            return (iValue == 1);\n+        }\n+        String strValue = parseStringValue(valueExpr);\n+        switch (strValue) {\n+            case \"on\":\n+                return true;\n+            case \"off\":\n+                return false;\n+            default:\n+                return null;\n+        }\n+    }\n \n-                    break;\n-                case AUTOCOMMIT_OFF: {\n-                    break;\n-                }\n-                case XA_FLAG_ON: {\n+    private static String parseVariablesValue(SQLExpr valueExpr) {\n+        String strValue = \"\";\n+        if (valueExpr instanceof SQLIdentifierExpr) {\n+            SQLIdentifierExpr value = (SQLIdentifierExpr) valueExpr;\n+            strValue = \"'\" + StringUtil.removeBackQuote(value.getSimpleName().toLowerCase()) + \"'\";\n+        } else if (valueExpr instanceof SQLCharExpr) {\n+            SQLCharExpr value = (SQLCharExpr) valueExpr;\n+            strValue = \"'\" + value.getText().toLowerCase() + \"'\";\n+        } else if (valueExpr instanceof SQLIntegerExpr) {\n+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n+            strValue = value.getNumber().toString();\n+        }\n+        return strValue;\n+    }\n \n-                    break;\n-                }\n-                case XA_FLAG_OFF: {\n+    private static String parseStringValue(SQLExpr valueExpr) {\n+        String strValue = \"\";\n+        if (valueExpr instanceof SQLIdentifierExpr) {\n+            SQLIdentifierExpr value = (SQLIdentifierExpr) valueExpr;\n+            strValue = StringUtil.removeBackQuote(value.getSimpleName().toLowerCase());\n+        } else if (valueExpr instanceof SQLCharExpr) {\n+            SQLCharExpr value = (SQLCharExpr) valueExpr;\n+            strValue = value.getText().toLowerCase();\n+        } else if (valueExpr instanceof SQLIntegerExpr) {\n+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n+            strValue = value.getNumber().toString();\n+        }\n+        return strValue;\n+    }\n \n+\n+    private static boolean handleTransaction(ServerConnection c, MySqlSetTransactionStatement setStatement) {\n+        //always single\n+        if (setStatement.getGlobal() == null) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting transaction without any SESSION or GLOBAL keyword is not supported now\");\n+            return false;\n+        } else if (setStatement.getGlobal()) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n+            return false;\n+        } else if (setStatement.getAccessModel() != null) {\n+            if (setStatement.getAccessModel().equals(\"ONLY\")) {\n+                c.setSessionReadOnly(true);\n+            } else {\n+                c.setSessionReadOnly(false);\n+            }\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            int txIsolation = Isolations.REPEATED_READ;\n+            switch (setStatement.getIsolationLevel()) {\n+                case \"READ UNCOMMITTED\":\n+                    txIsolation = Isolations.READ_UNCOMMITTED;\n                     break;\n-                }\n-                case NAMES: {\n-                    String names = statement.substring(rs >>> 8).trim();\n-                    if (!handleSetNames(names, c)) {\n-                        setError = true;\n-                        c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + names + \"\");\n-                    }\n-                    break;\n-                }\n-                case CHARACTER_SET_CLIENT:\n-                case CHARACTER_SET_CONNECTION:\n-                case CHARACTER_SET_RESULTS:\n-                    //TODO:\n-                    break;\n-                case CHARACTER_SET_NAME: {\n-                    String charset = statement.substring(rs >>> 8).trim();\n-                    if (!handleCharSetName(charset, c)) {\n-                        setError = true;\n-                        c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charset + \"\");\n-                    }\n+                case \"READ COMMITTED\":\n+                    txIsolation = Isolations.READ_COMMITTED;\n                     break;\n-                }\n-                case GLOBAL:\n-                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n+                case \"REPEATABLE READ\":\n+                    txIsolation = Isolations.REPEATED_READ;\n                     break;\n-                case TX_READ_UNCOMMITTED:\n-                case TX_READ_COMMITTED:\n-                case TX_REPEATED_READ:\n-                case TX_SERIALIZABLE: {\n+                case \"SERIALIZABLE\":\n+                    txIsolation = Isolations.SERIALIZABLE;\n                     break;\n-                }\n                 default:\n-                    //TODO\n-            }\n-            if (setError) {\n-                return true;\n+                    // can't be happened\n+                    break;\n             }\n+            c.setTxIsolation(txIsolation);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n         }\n-        return false;\n-    }\n-    private static boolean handleCollationConn(String collation, ServerConnection c) {\n-        collation = StringUtil.removeApostropheOrBackQuote(collation);\n-        return c.setCollationConnection(collation);\n-    }\n-    private static boolean handleCharSetConnection(String charset, ServerConnection c) {\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterConnection(charset);\n     }\n-    private static boolean handleCharSetResults(String charset, ServerConnection c) {\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterResults(charset);\n+\n+    private static boolean checkCollation(String collation) {\n+        int ci = CharsetUtil.getCollationIndex(collation);\n+        return ci > 0;\n     }\n-    private static boolean handleCharSetClient(String charset, ServerConnection c) {\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterClient(charset);\n+\n+    private static boolean checkCharset(String name) {\n+        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n+        return ci > 0;\n     }\n-    private static boolean handleCharSetName(String charset, ServerConnection c) {\n+\n+    private static String getCharset(String charset) {\n         charset = charset.toLowerCase();\n         if (charset.equals(\"default\")) {\n             charset = DbleServer.getInstance().getConfig().getSystem().getCharset();\n         }\n         charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterSet(charset);\n+        if (checkCharset(charset)) {\n+            return charset;\n+        }\n+        return null;\n     }\n \n-    private static boolean handleSetNames(String names, ServerConnection c) {\n-        String charset = names.toLowerCase();\n-        int collateIndex = charset.indexOf(\"collate\");\n-        String collate = null;\n-        if (collateIndex > 0) {\n-            charset = names.substring(0, collateIndex).trim();\n-            collate = names.substring(collateIndex + 7).trim();\n-            if (collate.toLowerCase().equals(\"default\")) {\n-                String defaultCharset = DbleServer.getInstance().getConfig().getSystem().getCharset();\n-                collate = CharsetUtil.getDefaultCollation(defaultCharset);\n-            }\n-        }\n+    private static String[] checkSetNames(String charset, String collate) {\n+        charset = charset.toLowerCase();\n         if (charset.equals(\"default\")) {\n             charset = DbleServer.getInstance().getConfig().getSystem().getCharset();\n+        } else {\n+            charset = StringUtil.removeApostropheOrBackQuote(charset);\n+            if (!checkCharset(charset)) {\n+                return null;\n+            }\n         }\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setNames(charset, collate);\n-\n+        if (collate == null) {\n+            collate = CharsetUtil.getDefaultCollation(charset);\n+        } else {\n+            collate = collate.toLowerCase();\n+            if (collate.equals(\"default\")) {\n+                collate = CharsetUtil.getDefaultCollation(charset);\n+            } else if (CharsetUtil.getCollationIndex(collate) <= 0) {\n+                return null;\n+            }\n+        }\n+        return new String[]{charset, collate};\n     }\n }\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/parser: ServerParseSet.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/ServerConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/ServerConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/ServerConnection.java\t2024-10-02 23:00:42.281994379 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/ServerConnection.java\t2024-10-02 23:00:42.173993273 +1000\n@@ -16,7 +16,9 @@\n import com.actiontech.dble.log.transaction.TxnLogHelper;\n import com.actiontech.dble.net.FrontendConnection;\n import com.actiontech.dble.route.RouteResultset;\n+import com.actiontech.dble.route.parser.util.Pair;\n import com.actiontech.dble.route.util.RouterUtil;\n+import com.actiontech.dble.server.handler.SetHandler;\n import com.actiontech.dble.server.parser.ServerParse;\n import com.actiontech.dble.server.response.Heartbeat;\n import com.actiontech.dble.server.response.Ping;\n@@ -31,6 +33,9 @@\n import java.nio.channels.NetworkChannel;\n import java.sql.SQLException;\n import java.sql.SQLNonTransientException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.LockSupport;\n@@ -53,11 +58,12 @@\n     private NonBlockingSession session;\n     private volatile boolean isLocked = false;\n     private AtomicLong txID;\n-\n+    private List<Pair<SetHandler.KeyType, Pair<String, String>>> contextTask = new ArrayList<>();\n     public long getAndIncrementXid() {\n         return txID.getAndIncrement();\n     }\n \n+\n     public long getXid() {\n         return txID.get();\n     }\n@@ -68,6 +74,8 @@\n         this.txInterrupted = false;\n         this.autocommit = true;\n         this.txID = new AtomicLong(1);\n+        this.usrVariables = new LinkedHashMap<>();\n+        this.sysVariables = new LinkedHashMap<>();\n     }\n \n     public ServerConnection() {\n@@ -131,7 +139,7 @@\n         return session;\n     }\n \n-    public void setSession2(NonBlockingSession session2) {\n+    void setSession2(NonBlockingSession session2) {\n         this.session = session2;\n     }\n \n@@ -139,10 +147,64 @@\n         return isLocked;\n     }\n \n-    public void setLocked(boolean locked) {\n+    void setLocked(boolean locked) {\n         this.isLocked = locked;\n     }\n \n+\n+    public List<Pair<SetHandler.KeyType, Pair<String, String>>> getContextTask() {\n+        return contextTask;\n+    }\n+\n+    public void setContextTask(List<Pair<SetHandler.KeyType, Pair<String, String>>> contextTask) {\n+        this.contextTask = contextTask;\n+    }\n+\n+    public void executeTask() {\n+        for (Pair<SetHandler.KeyType, Pair<String, String>> task : contextTask) {\n+            switch (task.getKey()) {\n+                case CHARACTER_SET_CLIENT:\n+                    String charsetClient = task.getValue().getKey();\n+                    this.setCharacterClient(charsetClient);\n+                    break;\n+                case CHARACTER_SET_CONNECTION:\n+                    String collationName = task.getValue().getKey();\n+                    this.setCharacterConnection(collationName);\n+                    break;\n+                case CHARACTER_SET_RESULTS:\n+                    String charsetResult = task.getValue().getKey();\n+                    this.setCharacterResults(charsetResult);\n+                    break;\n+                case COLLATION_CONNECTION:\n+                    String collation = task.getValue().getKey();\n+                    this.setCollationConnection(collation);\n+                    break;\n+                case TX_ISOLATION:\n+                    String isolationLevel = task.getValue().getKey();\n+                    this.setTxIsolation(Integer.parseInt(isolationLevel));\n+                    break;\n+                case TX_READ_ONLY:\n+                    String enable = task.getValue().getKey();\n+                    this.setSessionReadOnly(Boolean.parseBoolean(enable));\n+                    break;\n+                case SYSTEM_VARIABLES:\n+                    this.sysVariables.put(task.getValue().getKey(), task.getValue().getValue());\n+                    break;\n+                case USER_VARIABLES:\n+                    this.usrVariables.put(task.getValue().getKey(), task.getValue().getValue());\n+                    break;\n+                case CHARSET:\n+                    this.setCharacterSet(task.getValue().getKey());\n+                    break;\n+                case NAMES:\n+                    this.setNames(task.getValue().getKey(), task.getValue().getValue());\n+                    break;\n+                default:\n+                    //can't happen\n+                    break;\n+            }\n+        }\n+    }\n     @Override\n     public void ping() {\n         Ping.response(this);\n@@ -319,10 +381,7 @@\n         session.rollback();\n     }\n \n-    /**\n-     * @param sql\n-     */\n-    public void lockTable(String sql) {\n+    void lockTable(String sql) {\n         // lock table is disable in transaction\n         if (!autocommit) {\n             writeErrMessage(ErrorCode.ER_YES, \"can't lock table in transaction!\");\n@@ -339,10 +398,7 @@\n         }\n     }\n \n-    /**\n-     * @param sql\n-     */\n-    public void unLockTable(String sql) {\n+    void unLockTable(String sql) {\n         sql = sql.replaceAll(\"\\n\", \" \").replaceAll(\"\\t\", \" \");\n         String[] words = SplitUtil.split(sql, ' ', true);\n         if (words.length == 2 && (\"table\".equalsIgnoreCase(words[1]) || \"tables\".equalsIgnoreCase(words[1]))) {\n@@ -395,9 +451,31 @@\n \n     @Override\n     public String toString() {\n-        return \"ServerConnection [id=\" + id + \", schema=\" + schema + \", host=\" + host +\n-                \", user=\" + user + \",txIsolation=\" + txIsolation + \", autocommit=\" + autocommit +\n-                \", schema=\" + schema + \"]\";\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"ServerConnection [id=\");\n+        result.append(id);\n+        result.append(\", schema=\");\n+        result.append(schema);\n+        result.append(\", host=\");\n+        result.append(host);\n+        result.append(\", user=\");\n+        result.append(user);\n+        result.append(\",txIsolation=\");\n+        result.append(txIsolation);\n+        result.append(\", autocommit=\");\n+        result.append(autocommit);\n+        result.append(\", schema=\");\n+        result.append(schema);\n+        if (sysVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfSysVariables());\n+        }\n+        if (usrVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfUsrVariables());\n+        }\n+        result.append(\"]\");\n+        return result.toString();\n     }\n \n }\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine: SetTestJob.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java\t2024-10-02 23:00:42.281994379 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java\t2024-10-02 23:00:42.173993273 +1000\n@@ -36,14 +36,12 @@\n     private BackendConnection connection;\n     private final SQLJobHandler jobHandler;\n     private final PhysicalDatasource ds;\n-    private final int id;\n     private volatile boolean finished;\n \n \n     public SQLJob(String sql, String databaseName, SQLJobHandler jobHandler,\n                   PhysicalDatasource ds) {\n         super();\n-        this.id = 0;\n         this.sql = sql;\n         this.dataNodeOrDatabase = databaseName;\n         this.jobHandler = jobHandler;\n@@ -132,7 +130,7 @@\n \n     @Override\n     public void okResponse(byte[] ok, BackendConnection conn) {\n-        if (conn.syncAndExcute()) {\n+        if (conn.syncAndExecute()) {\n             conn.release();\n             doFinished(false);\n         }\n@@ -170,14 +168,9 @@\n     public void connectionClose(BackendConnection conn, String reason) {\n         doFinished(true);\n     }\n-\n-    public int getId() {\n-        return id;\n-    }\n-\n     @Override\n     public String toString() {\n-        return \"SQLJob [ id=\" + id + \",dataNodeOrDatabase=\" +\n+        return \"SQLJob [dataNodeOrDatabase=\" +\n                 dataNodeOrDatabase + \",sql=\" + sql + \",  jobHandler=\" +\n                 jobHandler + \"]\";\n     }\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/util: SetIgnoreUtil.java",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-20",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.actiontech.dble.parser.ServerParserTest",
                "error": "java.lang.AssertionError",
                "message": "expected:<6> but was:<154>",
                "methodName": "testIsRollback"
            }
        ],
        "metrics": {
            "chunks": 93,
            "classes": 21,
            "files": 21,
            "linesAdd": 124,
            "linesMod": 55,
            "linesRem": 35,
            "methods": 20,
            "sizeInLines": 214
        },
        "program": "RegressionBug-20",
        "project": "RegressionBug-20",
        "repairOperators": [
            "Uncategorized"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/backend/datasource/PhysicalDbGroup.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/backend/datasource/PhysicalDbGroup.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/backend/datasource/PhysicalDbGroup.java\t2024-09-08 01:36:10.361782309 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/backend/datasource/PhysicalDbGroup.java\t2024-09-08 01:36:10.281781749 +1000\n@@ -50,7 +50,7 @@\n     private final LoadBalancer loadBalancer = new RandomLoadBalancer();\n     private final ReentrantReadWriteLock adjustLock = new ReentrantReadWriteLock();\n \n-    private boolean useless = false;\n+    private boolean useless = true;\n \n     public PhysicalDbGroup(String name, DbGroupConfig config, PhysicalDbInstance writeDbInstances, PhysicalDbInstance[] readDbInstances, int rwSplitMode) {\n         this.groupName = name;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/backend/heartbeat/MySQLHeartbeat.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/backend/heartbeat/MySQLHeartbeat.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/backend/heartbeat/MySQLHeartbeat.java\t2024-09-08 01:36:10.365782337 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/backend/heartbeat/MySQLHeartbeat.java\t2024-09-08 01:36:10.281781749 +1000\n@@ -19,6 +19,7 @@\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n \n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -46,7 +47,7 @@\n     protected volatile int status;\n     private String heartbeatSQL;\n     private long heartbeatTimeout; // during the time, heart failed will ignore\n-    private volatile int errorCount = 0;\n+    private final AtomicInteger errorCount = new AtomicInteger(0);\n     private AtomicLong startErrorTime = new AtomicLong(-1L);\n     private volatile boolean isStop = true;\n     private volatile int dbSynStatus = DB_SYN_NORMAL;\n@@ -131,13 +132,13 @@\n \n     // only use when heartbeat connection is closed\n     boolean doHeartbeatRetry() {\n-        if (errorRetryCount > 0 && ++errorCount <= errorRetryCount) {\n+        if (errorRetryCount > 0 && errorCount.get() < errorRetryCount) {\n             // should continue checking error status\n             if (detector != null) {\n                 detector.quit();\n             }\n             isChecking.set(false);\n-            LOGGER.warn(\"retry to do heartbeat for the \" + errorCount + \" times\");\n+            LOGGER.warn(\"retry to do heartbeat for the \" + errorCount.incrementAndGet() + \" times\");\n             heartbeat(); // error count not enough, heart beat again\n             recordErrorCount();\n             return true;\n@@ -157,8 +158,8 @@\n         startErrorTime.compareAndSet(-1, System.currentTimeMillis());\n         Map<String, String> labels = AlertUtil.genSingleLabel(\"dbInstance\", this.source.getDbGroupConfig().getName() + \"-\" + this.source.getConfig().getInstanceName());\n         AlertUtil.alert(AlarmCode.HEARTBEAT_FAIL, Alert.AlertLevel.WARN, \"heartbeat status:\" + this.status, \"mysql\", this.source.getConfig().getId(), labels);\n-        if (errorRetryCount > 0 && ++errorCount <= errorRetryCount) {\n-            LOGGER.warn(\"retry to do heartbeat for the \" + errorCount + \" times\");\n+        if (errorRetryCount > 0 && errorCount.get() < errorRetryCount) {\n+            LOGGER.warn(\"retry to do heartbeat for the \" + errorCount.incrementAndGet() + \" times\");\n             heartbeat(); // error count not enough, heart beat again\n             recordErrorCount();\n         }\n@@ -190,7 +191,7 @@\n         switch (status) {\n             case TIMEOUT_STATUS:\n                 this.status = INIT_STATUS;\n-                this.errorCount = 0;\n+                this.errorCount.set(0);\n                 this.startErrorTime.set(-1);\n                 if (isStop) {\n                     detector.quit();\n@@ -202,7 +203,7 @@\n                 break;\n             default:\n                 this.status = OK_STATUS;\n-                this.errorCount = 0;\n+                this.errorCount.set(0);\n                 this.startErrorTime.set(-1);\n                 Map<String, String> labels = AlertUtil.genSingleLabel(\"dbInstance\", this.source.getDbGroupConfig().getName() + \"-\" + this.source.getConfig().getInstanceName());\n                 AlertUtil.alertResolve(AlarmCode.HEARTBEAT_FAIL, Alert.AlertLevel.WARN, \"mysql\", this.source.getConfig().getId(), labels);\n@@ -274,7 +275,7 @@\n     }\n \n     public int getErrorCount() {\n-        return errorCount;\n+        return errorCount.get();\n     }\n \n     public HeartbeatRecorder getRecorder() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/util/HandlerTool.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/util/HandlerTool.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/util/HandlerTool.java\t2024-09-08 01:36:10.365782337 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/util/HandlerTool.java\t2024-09-08 01:36:10.285781777 +1000\n@@ -103,6 +103,7 @@\n         ret.fixFields();\n         return ret;\n     }\n+\n     /**\n      * create Item, the Item value referenced by field and changed by field changes\n      *\n@@ -249,6 +250,7 @@\n             args.add(newArg);\n         }\n         ItemFunc ret = (ItemFunc) f.reStruct(args, allPushDown, fields);\n+        ret.setCharsetIndex(f.getCharsetIndex());\n         ret.setItemName(f.getPushDownName() == null ? f.getItemName() : f.getPushDownName());\n         return ret;\n     }\n@@ -293,7 +295,7 @@\n         int index = findField(col, fields, startIndex);\n         if (index < 0)\n             throw new MySQLOutPutException(ErrorCode.ER_QUERYHANDLER, \"\", \"field not found:\" + col);\n-        ItemField ret = new ItemField(fields.get(index), col.getCharsetIndex());\n+        ItemField ret = new ItemField(fields.get(index));\n         ret.setItemName(col.getPushDownName() == null ? col.getItemName() : col.getPushDownName());\n         return ret;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/ConfigInitializer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/ConfigInitializer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/ConfigInitializer.java\t2024-09-08 01:36:10.369782365 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/ConfigInitializer.java\t2024-09-08 01:36:10.289781805 +1000\n@@ -53,24 +53,33 @@\n     public ConfigInitializer(boolean lowerCaseNames) {\n         TraceManager.TraceObject traceObject = TraceManager.threadTrace(\"load-config-file\");\n         try {\n+            //load user.xml\n+            XMLUserLoader userLoader = new XMLUserLoader(null, this);\n+            this.users = userLoader.getUsers();\n+            this.blacklistConfig = userLoader.getBlacklistConfig();\n+\n             //load db.xml\n             XMLDbLoader dbLoader = new XMLDbLoader(null, this);\n             this.dbGroups = dbLoader.getDbGroups();\n \n-            //load sharding.xml\n-            XMLShardingLoader shardingLoader = new XMLShardingLoader(lowerCaseNames, this);\n-            this.schemas = shardingLoader.getSchemas();\n-            this.erRelations = shardingLoader.getErRelations();\n-            this.shardingNodes = initShardingNodes(shardingLoader.getShardingNode());\n-            this.functions = shardingLoader.getFunctions();\n+            if (userLoader.isContainsShardingUser()) {\n+                //load sharding.xml\n+                XMLShardingLoader shardingLoader = new XMLShardingLoader(lowerCaseNames, this);\n+                this.schemas = shardingLoader.getSchemas();\n+                this.erRelations = shardingLoader.getErRelations();\n+                this.shardingNodes = initShardingNodes(shardingLoader.getShardingNode());\n+                this.functions = shardingLoader.getFunctions();\n \n-            //load user.xml\n-            XMLUserLoader userLoader = new XMLUserLoader(null, this);\n-            this.users = userLoader.getUsers();\n-            this.blacklistConfig = userLoader.getBlacklistConfig();\n+                deleteUselessShardingNode();\n+            } else {\n+                this.schemas = Collections.EMPTY_MAP;\n+                this.erRelations = Collections.EMPTY_MAP;\n+                this.shardingNodes = Collections.EMPTY_MAP;\n+                this.functions = Collections.EMPTY_MAP;\n+            }\n \n-            deleteRedundancyConf();\n-            checkWriteHost();\n+            checkRwSplitDbGroup();\n+            checkWriteDbInstance();\n         } finally {\n             TraceManager.finishSpan(traceObject);\n         }\n@@ -93,12 +102,16 @@\n         LOGGER.info(problem);\n     }\n \n-    private void checkWriteHost() {\n+    private void checkWriteDbInstance() {\n         if (this.dbGroups.isEmpty()) {\n             return;\n         }\n         //Mark all dbInstance whether they are fake or not\n         for (PhysicalDbGroup dbGroup : this.dbGroups.values()) {\n+            if (dbGroup.isUseless()) {\n+                LOGGER.info(\"dbGroup \" + dbGroup.getGroupName() + \" is useless,server will create heartbeat,not create pool\");\n+            }\n+\n             for (PhysicalDbInstance dbInstance : dbGroup.getDbInstances(true)) {\n                 if (checkDbInstanceFake(dbInstance)) {\n                     dbInstance.setFakeNode(true);\n@@ -107,12 +120,6 @@\n                 }\n             }\n         }\n-        // if there are dbGroups exists. no empty shardingNodes allowed\n-        for (ShardingNode shardingNode : this.shardingNodes.values()) {\n-            if (shardingNode.getDbGroup() == null) {\n-                throw new ConfigException(\"dbGroup not exists \" + shardingNode.getDbGroupName());\n-            }\n-        }\n     }\n \n     private boolean checkDbInstanceFake(PhysicalDbInstance source) {\n@@ -124,13 +131,11 @@\n         return false;\n     }\n \n-    private void deleteRedundancyConf() {\n-        Set<String> allUseShardingNode = new HashSet<>();\n-\n+    private void deleteUselessShardingNode() {\n         if (schemas.size() == 0) {\n             errorInfos.add(new ErrorInfo(\"Xml\", \"WARNING\", \"No sharding available\"));\n         }\n-\n+        Set<String> allUseShardingNode = new HashSet<>();\n         for (SchemaConfig sc : schemas.values()) {\n             // check shardingNode / dbGroup\n             Set<String> shardingNodeNames = sc.getAllShardingNodes();\n@@ -144,15 +149,18 @@\n             allUseShardingNode.addAll(redundancy.getShardingNodes());\n         }\n \n-        Set<String> allUseDbGroups = new HashSet<>();\n         //delete redundancy shardingNode\n         Iterator<Map.Entry<String, ShardingNode>> iterator = this.shardingNodes.entrySet().iterator();\n+        PhysicalDbGroup shardingNodeGroup;\n         while (iterator.hasNext()) {\n             Map.Entry<String, ShardingNode> entry = iterator.next();\n             String shardingNodeName = entry.getKey();\n             if (allUseShardingNode.contains(shardingNodeName)) {\n-                if (entry.getValue().getDbGroup() != null) {\n-                    allUseDbGroups.add(entry.getValue().getDbGroup().getGroupName());\n+                shardingNodeGroup = entry.getValue().getDbGroup();\n+                if (shardingNodeGroup != null) {\n+                    shardingNodeGroup.setUseless(false);\n+                } else {\n+                    throw new ConfigException(\"dbGroup not exists \" + entry.getValue().getDbGroupName());\n                 }\n             } else {\n                 LOGGER.info(\"shardingNode \" + shardingNodeName + \" is useless,server will ignore it\");\n@@ -160,37 +168,25 @@\n                 iterator.remove();\n             }\n         }\n-        allUseShardingNode.clear();\n+    }\n \n+    private void checkRwSplitDbGroup() {\n         // include rwSplit dbGroup\n         RwSplitUserConfig rwSplitUserConfig;\n-        HashSet<String> rwGroups = new HashSet<>();\n+        PhysicalDbGroup group;\n         for (UserConfig config : this.users.values()) {\n             if (config instanceof RwSplitUserConfig) {\n                 rwSplitUserConfig = (RwSplitUserConfig) config;\n-                String group = rwSplitUserConfig.getDbGroup();\n-                if (!this.dbGroups.containsKey(group)) {\n-                    throw new ConfigException(\"The user's group[\" + rwSplitUserConfig.getName() + \".\" + group + \"] for rwSplit isn't configured in db.xml.\");\n-                }\n-                if (allUseDbGroups.contains(group)) {\n-                    throw new ConfigException(\"The group[\" + rwSplitUserConfig.getName() + \".\" + group + \"] has been used by sharding node, can't be used by rwSplit.\");\n+                group = this.dbGroups.get(rwSplitUserConfig.getDbGroup());\n+                if (group == null) {\n+                    throw new ConfigException(\"The user's group[\" + rwSplitUserConfig.getName() + \".\" + rwSplitUserConfig.getDbGroup() + \"] for rwSplit isn't configured in db.xml.\");\n+                } else if (!group.isUseless()) {\n+                    throw new ConfigException(\"The group[\" + rwSplitUserConfig.getName() + \".\" + rwSplitUserConfig.getDbGroup() + \"] has been used by sharding node, can't be used by rwSplit.\");\n                 } else {\n-                    rwGroups.add(group);\n+                    group.setUseless(false);\n                 }\n             }\n         }\n-        allUseDbGroups.addAll(rwGroups);\n-\n-        //mark useless db_group: have heartbeat/ have not pool init\n-        for (Map.Entry<String, PhysicalDbGroup> dbGroupEntry : this.dbGroups.entrySet()) {\n-            dbGroupEntry.getValue().setUseless(false);\n-            if (allUseDbGroups.size() < this.dbGroups.size() && !allUseDbGroups.contains(dbGroupEntry.getKey())) {\n-                LOGGER.info(\"dbGroup \" + dbGroupEntry.getKey() + \" is useless,server will create heartbeat,not create pool\");\n-                errorInfos.add(new ErrorInfo(\"Xml\", \"WARNING\", \"dbGroup \" + dbGroupEntry.getKey() + \" is useless\"));\n-                dbGroupEntry.getValue().setUseless(true);\n-            }\n-        }\n-        allUseDbGroups.clear();\n     }\n \n     public void testConnection() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/loader/xml/XMLUserLoader.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/loader/xml/XMLUserLoader.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/loader/xml/XMLUserLoader.java\t2024-09-08 01:36:10.369782365 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/loader/xml/XMLUserLoader.java\t2024-09-08 01:36:10.289781805 +1000\n@@ -28,11 +28,10 @@\n import java.sql.SQLException;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n \n import static com.actiontech.dble.services.manager.information.tables.DbleRwSplitEntry.*;\n \n-import java.util.regex.Pattern;\n-\n public class XMLUserLoader {\n     public static final String TYPE_MANAGER_USER = \"managerUser\";\n     public static final String TYPE_SHARDING_USER = \"shardingUser\";\n@@ -46,6 +45,8 @@\n     private AtomicInteger userId = new AtomicInteger(0);\n     private static final Pattern DML_PATTERN = Pattern.compile(\"^[0|1]{4}$\");\n     private Document document;\n+    // whether db.xml contains shardingUser\n+    private boolean containsShardingUser;\n \n     public XMLUserLoader() {\n         this.users = Maps.newHashMap();\n@@ -136,10 +137,14 @@\n         }\n     }\n \n-\n     private void loadManagerUser(Element root, String xmlFile) {\n         NodeList list = root.getElementsByTagName(TYPE_MANAGER_USER);\n-        for (int i = 0, n = list.getLength(); i < n; i++) {\n+        int size = list.getLength();\n+        if (size == 0) {\n+            return;\n+        }\n+\n+        for (int i = 0; i < size; i++) {\n             Node node = list.item(i);\n             if (node instanceof Element) {\n                 Element element = (Element) node;\n@@ -164,7 +169,13 @@\n \n     private void loadShardingUser(Element root, String xmlFile, Map<String, WallProvider> blackListMap) {\n         NodeList list = root.getElementsByTagName(TYPE_SHARDING_USER);\n-        for (int i = 0, n = list.getLength(); i < n; i++) {\n+        int size = list.getLength();\n+        if (size == 0) {\n+            return;\n+        }\n+\n+        this.containsShardingUser = true;\n+        for (int i = 0; i < size; i++) {\n             Node node = list.item(i);\n             if (node instanceof Element) {\n                 Element element = (Element) node;\n@@ -210,7 +221,11 @@\n \n     private void loadRwSplitUser(Element root, String xmlFile, Map<String, WallProvider> blackListMap) {\n         NodeList list = root.getElementsByTagName(TYPE_RWSPLIT_USER);\n-        for (int i = 0, n = list.getLength(); i < n; i++) {\n+        int size = list.getLength();\n+        if (size == 0) {\n+            return;\n+        }\n+        for (int i = 0; i < size; i++) {\n             Node node = list.item(i);\n             if (node instanceof Element) {\n                 Element element = (Element) node;\n@@ -497,4 +512,9 @@\n         }\n         return privilegesConfig;\n     }\n+\n+    public boolean isContainsShardingUser() {\n+        return containsShardingUser;\n+    }\n+\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/ServerConfig.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/ServerConfig.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/ServerConfig.java\t2024-09-08 01:36:10.369782365 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/ServerConfig.java\t2024-09-08 01:36:10.289781805 +1000\n@@ -64,10 +64,12 @@\n         //read sharding.xml,db.xml and user.xml\n         confInitNew = new ConfigInitializer(false);\n         this.users = confInitNew.getUsers();\n-        this.schemas = confInitNew.getSchemas();\n         this.dbGroups = confInitNew.getDbGroups();\n+\n+        this.schemas = confInitNew.getSchemas();\n         this.shardingNodes = confInitNew.getShardingNodes();\n         this.erRelations = confInitNew.getErRelations();\n+        this.functions = confInitNew.getFunctions();\n         this.fullyConfigured = confInitNew.isFullyConfigured();\n         ConfigUtil.setSchemasForPool(dbGroups, shardingNodes);\n \n@@ -75,17 +77,17 @@\n \n         this.lock = new ReentrantReadWriteLock();\n         this.blacklistConfig = confInitNew.getBlacklistConfig();\n-        this.functions = confInitNew.getFunctions();\n     }\n \n \n     public ServerConfig(ConfigInitializer confInit) {\n         //read sharding.xml,db.xml and user.xml\n         this.users = confInit.getUsers();\n-        this.schemas = confInit.getSchemas();\n         this.dbGroups = confInit.getDbGroups();\n+        this.schemas = confInit.getSchemas();\n         this.shardingNodes = confInit.getShardingNodes();\n         this.erRelations = confInit.getErRelations();\n+        this.functions = confInit.getFunctions();\n         this.fullyConfigured = confInit.isFullyConfigured();\n         ConfigUtil.setSchemasForPool(dbGroups, shardingNodes);\n \n@@ -93,7 +95,6 @@\n \n         this.lock = new ReentrantReadWriteLock();\n         this.blacklistConfig = confInit.getBlacklistConfig();\n-        this.functions = confInit.getFunctions();\n     }\n \n     private void waitIfChanging() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/Versions.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/Versions.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/config/Versions.java\t2024-09-08 01:36:10.369782365 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/config/Versions.java\t2024-09-08 01:36:10.289781805 +1000\n@@ -14,7 +14,7 @@\n \n     public static final byte PROTOCOL_VERSION = 10;\n \n-    private static byte[] serverVersion = \"5.6.29-dble-3.20.10.99-6304e99cf687081680b6bf291800c1f279b22b8b-20240827175136\".getBytes();\n+    private static byte[] serverVersion = \"5.6.29-dble-3.20.10.99-2a13f54c867840e6b8108b50982386e8572ec1d2-20240827175451\".getBytes();\n     public static final byte[] VERSION_COMMENT = \"dble Server (ActionTech)\".getBytes();\n     public static final String ANNOTATION_NAME = \"dble:\";\n     public static final String ROOT_PREFIX = \"dble\";\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/net/connection/FrontendConnection.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/net/connection/FrontendConnection.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/net/connection/FrontendConnection.java\t2024-09-08 01:36:10.373782394 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/net/connection/FrontendConnection.java\t2024-09-08 01:36:10.293781833 +1000\n@@ -1,6 +1,6 @@\n package com.actiontech.dble.net.connection;\n \n-import com.actiontech.dble.config.model.db.PoolConfig;\n+import com.actiontech.dble.config.model.SystemConfig;\n import com.actiontech.dble.net.IOProcessor;\n import com.actiontech.dble.net.SocketWR;\n import com.actiontech.dble.net.service.AbstractService;\n@@ -22,16 +22,16 @@\n public class FrontendConnection extends AbstractConnection {\n \n     private static final long AUTH_TIMEOUT = 15 * 1000L;\n-    private final boolean isManager;\n \n-    protected final long idleTimeout = PoolConfig.DEFAULT_IDLE_TIMEOUT;\n-    private AtomicBoolean isCleanUp = new AtomicBoolean(false);\n+    private final boolean isManager;\n+    private final long idleTimeout;\n+    private final AtomicBoolean isCleanUp;\n \n     public FrontendConnection(NetworkChannel channel, SocketWR socketWR, boolean isManager) throws IOException {\n         super(channel, socketWR);\n         this.isManager = isManager;\n         InetSocketAddress localAddress = (InetSocketAddress) channel.getLocalAddress();\n-        InetSocketAddress remoteAddress = null;\n+        InetSocketAddress remoteAddress;\n         if (channel instanceof SocketChannel) {\n             remoteAddress = (InetSocketAddress) ((SocketChannel) channel).getRemoteAddress();\n         } else if (channel instanceof AsynchronousSocketChannel) {\n@@ -42,6 +42,8 @@\n         this.host = remoteAddress.getHostString();\n         this.port = localAddress.getPort();\n         this.localPort = remoteAddress.getPort();\n+        this.idleTimeout = SystemConfig.getInstance().getIdleTimeout();\n+        this.isCleanUp = new AtomicBoolean(false);\n     }\n \n     @Override\n@@ -83,7 +85,6 @@\n         }\n     }\n \n-\n     public boolean isManager() {\n         return isManager;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/common/field/FieldUtil.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/common/field/FieldUtil.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/common/field/FieldUtil.java\t2024-09-08 01:36:10.373782394 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/common/field/FieldUtil.java\t2024-09-08 01:36:10.297781861 +1000\n@@ -5,6 +5,7 @@\n \n package com.actiontech.dble.plan.common.field;\n \n+import com.actiontech.dble.config.Fields;\n import com.actiontech.dble.plan.common.item.FieldTypes;\n \n import java.util.List;\n@@ -149,7 +150,7 @@\n             return FieldTypes.MYSQL_TYPE_TIMESTAMP;\n         } else if (realType == FieldTypes.MYSQL_TYPE_NEWDATE) {\n             return FieldTypes.MYSQL_TYPE_DATE;\n-        /* Note: NEWDECIMAL is a type, not only a real_type */\n+            /* Note: NEWDECIMAL is a type, not only a real_type */\n         } else {\n             return realType;\n         }\n@@ -1430,6 +1431,16 @@\n             },\n     };\n \n+    public static boolean isBinaryType(int dataType) {\n+        return dataType == Fields.FIELD_TYPE_MEDIUM_BLOB || dataType == Fields.FIELD_TYPE_BLOB || dataType == Fields.FIELD_TYPE_LONG_BLOB ||\n+                dataType == Fields.FIELD_TYPE_TINY_BLOB;\n+    }\n+\n+    public static boolean isNumberType(int dataType) {\n+        return dataType == Fields.FIELD_TYPE_LONG || dataType == Fields.FIELD_TYPE_LONGLONG || dataType == Fields.FIELD_TYPE_TINY ||\n+                dataType == Fields.FIELD_TYPE_SHORT || dataType == Fields.FIELD_TYPE_BIT || dataType == Fields.FIELD_TYPE_NEW_DECIMAL ||\n+                dataType == Fields.FIELD_TYPE_FLOAT || dataType == Fields.FIELD_TYPE_DOUBLE;\n+    }\n \n     public static boolean isNumberType(String dataType) {\n         if (dataType == null) return false;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/common/item/ItemField.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/common/item/ItemField.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/common/item/ItemField.java\t2024-09-08 01:36:10.373782394 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/common/item/ItemField.java\t2024-09-08 01:36:10.297781861 +1000\n@@ -49,17 +49,12 @@\n         setField(field);\n     }\n \n-    public ItemField(Field field, int charsetIndex) {\n-        this(field);\n-        this.charsetIndex = charsetIndex;\n-    }\n-\n     /**\n      * save index\n      *\n      * @param index\n      */\n-    public ItemField(int index, int charsetIndex) {\n+    public ItemField(int index) {\n         super(null, \"\", \"\");\n         this.index = index;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/NamedField.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/NamedField.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/NamedField.java\t2024-09-08 01:36:10.373782394 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/NamedField.java\t2024-09-08 01:36:10.297781861 +1000\n@@ -16,6 +16,7 @@\n     private final int hashCode;\n     // which node of the field belong\n     public final PlanNode planNode;\n+    private int charsetIndex;\n \n     public NamedField(String inputSchema, String inputTable, String name, PlanNode planNode) {\n         String tempTableSchmea;\n@@ -57,6 +58,14 @@\n         return name;\n     }\n \n+    public int getCharsetIndex() {\n+        return charsetIndex;\n+    }\n+\n+    public void setCharsetIndex(int charsetIndex) {\n+        this.charsetIndex = charsetIndex;\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (obj == null)\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/node/PlanNode.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/node/PlanNode.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/node/PlanNode.java\t2024-09-08 01:36:10.377782421 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/node/PlanNode.java\t2024-09-08 01:36:10.301781889 +1000\n@@ -266,6 +266,7 @@\n         for (Item selected : this.getColumnsSelected()) {\n             Item copySel = selected.cloneItem();\n             copySel.setItemName(selected.getItemName());\n+            copySel.setCharsetIndex(selected.getCharsetIndex());\n             to.columnsSelected.add(copySel);\n         }\n         for (Order groupBy : this.getGroupBys()) {\n@@ -300,6 +301,7 @@\n                 String tmpFieldTable = child.getAlias() == null ? coutField.getTable() : child.getAlias();\n                 String tmpFieldName = coutField.getName();\n                 NamedField tmpField = new NamedField(tmpFieldSchema, tmpFieldTable, tmpFieldName, coutField.planNode);\n+                tmpField.setCharsetIndex(coutField.getCharsetIndex());\n                 if (innerFields.containsKey(tmpField) && getParent() != null)\n                     throw new MySQLOutPutException(ErrorCode.ER_DUP_FIELDNAME, \"42S21\", \"Duplicate column name '\" + tmpFieldName + \"'\");\n                 innerFields.put(tmpField, coutField);\n@@ -408,7 +410,7 @@\n \n     protected void dealSingleStarColumn(List<Item> newSels) {\n         for (NamedField field : innerFields.keySet()) {\n-            ItemField col = new ItemField(field.getSchema(), field.getTable(), field.getName());\n+            ItemField col = new ItemField(field.getSchema(), field.getTable(), field.getName(), field.getCharsetIndex());\n             newSels.add(col);\n         }\n     }\n@@ -425,7 +427,7 @@\n                     boolean found = false;\n                     for (NamedField field : innerFields.keySet()) {\n                         if (selTable.equals(field.getTable())) {\n-                            ItemField col = new ItemField(field.getSchema(), field.getTable(), field.getName());\n+                            ItemField col = new ItemField(field.getSchema(), field.getTable(), field.getName(), field.getCharsetIndex());\n                             newSels.add(col);\n                             found = true;\n                         } else if (found) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/node/TableNode.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/node/TableNode.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/node/TableNode.java\t2024-09-08 01:36:10.377782421 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/node/TableNode.java\t2024-09-08 01:36:10.301781889 +1000\n@@ -36,6 +36,7 @@\n     private TableMeta tableMeta;\n     private List<String> columns;\n     private List<SQLHint> hintList;\n+    private int charsetIndex = 63;\n \n     private TableNode() {\n     }\n@@ -61,9 +62,10 @@\n         this.keepFieldSchema = true;\n     }\n \n-    public TableNode(String catalog, String tableName, ProxyMetaManager metaManager) throws SQLNonTransientException {\n+    public TableNode(String catalog, String tableName, ProxyMetaManager metaManager, int charsetIndex) throws SQLNonTransientException {\n         if (catalog == null || tableName == null)\n             throw new RuntimeException(\"Table db or name is null error!\");\n+        this.charsetIndex = charsetIndex;\n         this.schema = catalog;\n         this.tableName = tableName;\n         ServerConfig config = DbleServer.getInstance().getConfig();\n@@ -121,11 +123,13 @@\n         if (tableMeta != null) {\n             for (ColumnMeta cm : tableMeta.getColumns()) {\n                 NamedField tmpField = new NamedField(schema, tmpTable, cm.getName(), this);\n+                tmpField.setCharsetIndex(charsetIndex);\n                 innerFields.put(tmpField, tmpField);\n             }\n         } else {\n             for (String col : columns) {\n                 NamedField tmpField = new NamedField(schema, tmpTable, col, this);\n+                tmpField.setCharsetIndex(charsetIndex);\n                 innerFields.put(tmpField, tmpField);\n             }\n         }\n@@ -159,7 +163,7 @@\n                 newSelects.add(sel);\n             else {\n                 for (NamedField innerField : innerFields.keySet()) {\n-                    ItemField col = new ItemField(null, sel.getTableName(), innerField.getName());\n+                    ItemField col = new ItemField(null, sel.getTableName(), innerField.getName(), charsetIndex);\n                     newSelects.add(col);\n                 }\n             }\n@@ -232,4 +236,11 @@\n         this.hintList = hintList;\n     }\n \n+    public int getCharsetIndex() {\n+        return charsetIndex;\n+    }\n+\n+    public void setCharsetIndex(int charsetIndex) {\n+        this.charsetIndex = charsetIndex;\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/visitor/MySQLPlanNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/visitor/MySQLPlanNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/plan/visitor/MySQLPlanNodeVisitor.java\t2024-09-08 01:36:10.377782421 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/plan/visitor/MySQLPlanNodeVisitor.java\t2024-09-08 01:36:10.305781917 +1000\n@@ -222,7 +222,7 @@\n                 return true;\n             } else {\n                 try {\n-                    table = new TableNode(schema, tableName, this.metaManager);\n+                    table = new TableNode(schema, tableName, this.metaManager, charsetIndex);\n                 } catch (SQLNonTransientException e) {\n                     throw new MySQLOutPutException(e.getErrorCode(), e.getSQLState(), e.getMessage());\n                 }\n@@ -374,6 +374,7 @@\n             MySQLItemVisitor ev = new MySQLItemVisitor(currentDb, this.charsetIndex, this.metaManager, this.usrVariables);\n             expr.accept(ev);\n             Item selItem = ev.getItem();\n+            selItem.setCharsetIndex(charsetIndex);\n             if (selItem.isWithSubQuery()) {\n                 setSubQueryNode(selItem);\n             }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/rwsplit/RWSplitNonBlockingSession.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/rwsplit/RWSplitNonBlockingSession.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/rwsplit/RWSplitNonBlockingSession.java\t2024-09-08 01:36:10.381782449 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/rwsplit/RWSplitNonBlockingSession.java\t2024-09-08 01:36:10.305781917 +1000\n@@ -28,11 +28,11 @@\n         this.rwSplitService = service;\n     }\n \n-    public void execute(boolean master, Callback callback) {\n+    public void execute(Boolean master, Callback callback) {\n         execute(master, null, callback);\n     }\n \n-    public void execute(boolean master, byte[] originPacket, Callback callback) {\n+    public void execute(Boolean master, byte[] originPacket, Callback callback) {\n         try {\n             RWSplitHandler handler = new RWSplitHandler(rwSplitService, originPacket, callback);\n             if (conn != null && !conn.isClosed()) {\n@@ -44,7 +44,7 @@\n                 return;\n             }\n \n-            PhysicalDbInstance instance = rwGroup.select(master);\n+            PhysicalDbInstance instance = rwGroup.select(canRunOnMaster(master));\n             checkDest(!instance.isReadInstance());\n             instance.getConnection(rwSplitService.getSchema(), handler, null, false);\n         } catch (IOException e) {\n@@ -55,6 +55,13 @@\n         }\n     }\n \n+    private Boolean canRunOnMaster(Boolean master) {\n+        if (!rwSplitService.isAutocommit() || rwSplitService.isTxStart()) {\n+            return true;\n+        }\n+        return master;\n+    }\n+\n     private void checkDest(boolean isMaster) throws SQLSyntaxErrorException {\n         String dest = rwSplitService.getExpectedDest();\n         if (dest == null) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/handler/SetHandler.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\t2024-09-08 01:36:10.381782449 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\t2024-09-08 01:36:10.309781945 +1000\n@@ -126,9 +126,9 @@\n             throw new SQLSyntaxErrorException(\"setting GLOBAL value is not supported\");\n         } else if (setStatement.getAccessModel() != null) {\n             if (setStatement.getAccessModel().equals(\"ONLY\")) {\n-                item = newSetItem(VersionUtil.TX_READ_ONLY, new SQLBooleanExpr(true));\n+                item = newSetItem(VersionUtil.TX_READ_ONLY, new SQLIntegerExpr(1));\n             } else {\n-                item = newSetItem(VersionUtil.TX_READ_ONLY, new SQLBooleanExpr(false));\n+                item = newSetItem(VersionUtil.TX_READ_ONLY, new SQLIntegerExpr(0));\n             }\n         } else {\n             item = newSetItem(VersionUtil.TRANSACTION_ISOLATION, new SQLCharExpr(setStatement.getIsolationLevel()));\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/parser/ServerParse.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/parser/ServerParse.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/parser/ServerParse.java\t2024-09-08 01:36:10.381782449 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/parser/ServerParse.java\t2024-09-08 01:36:10.309781945 +1000\n@@ -1058,7 +1058,8 @@\n \n     // ROLLBACK\n     protected static int rollbackCheck(String stmt, int offset) {\n-        if (stmt.length() > offset + 6) {\n+        int len = stmt.length();\n+        if (len > offset + 6) {\n             char c1 = stmt.charAt(++offset);\n             char c2 = stmt.charAt(++offset);\n             char c3 = stmt.charAt(++offset);\n@@ -1068,10 +1069,41 @@\n             if ((c1 == 'L' || c1 == 'l') && (c2 == 'L' || c2 == 'l') &&\n                     (c3 == 'B' || c3 == 'b') && (c4 == 'A' || c4 == 'a') &&\n                     (c5 == 'C' || c5 == 'c') && (c6 == 'K' || c6 == 'k')) {\n+                char tmp;\n+                while (len > ++offset) {\n+                    tmp = stmt.charAt(offset);\n+                    if (ParseUtil.isSpace(tmp)) {\n+                        continue;\n+                    }\n+                    switch (tmp) {\n+                        case '/':\n+                            offset = ParseUtil.comment(stmt, offset);\n+                            break;\n+                        case 't':\n+                        case 'T':\n+                            return ROLLBACK_SAVEPOINT;\n+                        case 'w':\n+                        case 'W':\n+                            return rollbackWorkCheck(stmt, offset);\n+                        default:\n+                            break;\n+                    }\n+                }\n+                return ROLLBACK;\n+            }\n+        }\n+        return OTHER;\n+    }\n+\n+    protected static int rollbackWorkCheck(String stmt, int offset) {\n+        if (stmt.length() > offset + 3) {\n+            char c1 = stmt.charAt(++offset);\n+            char c2 = stmt.charAt(++offset);\n+            char c3 = stmt.charAt(++offset);\n+            if ((c1 == 'O' || c1 == 'o') && (c2 == 'R' || c2 == 'r') &&\n+                    (c3 == 'K' || c3 == 'k')) {\n                 if (stmt.length() == ++offset || ParseUtil.isEOF(stmt, offset) || ParseUtil.isMultiEof(stmt, offset)) {\n                     return ROLLBACK;\n-                } else {\n-                    return ROLLBACK_SAVEPOINT;\n                 }\n             }\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/util/SetItemUtil.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/util/SetItemUtil.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/server/util/SetItemUtil.java\t2024-09-08 01:36:10.381782449 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/server/util/SetItemUtil.java\t2024-09-08 01:36:10.309781945 +1000\n@@ -55,10 +55,16 @@\n     }\n \n     public static String getCharsetClientVal(SQLExpr valueExpr) throws SQLSyntaxErrorException {\n+        if (valueExpr instanceof SQLVariantRefExpr) {\n+            return valueExpr.toString();\n+        }\n+\n         String charsetClient = parseStringValue(valueExpr);\n         if (charsetClient == null || charsetClient.equalsIgnoreCase(\"null\")) {\n             throw new SQLSyntaxErrorException(\"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n-        } else if (checkCharset(charsetClient)) {\n+        }\n+\n+        if (checkCharset(charsetClient)) {\n             if (!CharsetUtil.checkCharsetClient(charsetClient)) {\n                 throw new SQLSyntaxErrorException(\"Variable 'character_set_client' can't be set to the value of '\" + charsetClient + \"'\");\n             }\n@@ -194,10 +200,12 @@\n         } else if (valueExpr instanceof SQLIntegerExpr) {\n             SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n             strValue = value.getNumber().toString();\n-        } else if (valueExpr instanceof SQLDefaultExpr || valueExpr instanceof SQLNullExpr) {\n+        } else if (valueExpr instanceof SQLDefaultExpr || valueExpr instanceof SQLNullExpr ||\n+                valueExpr instanceof SQLVariantRefExpr) {\n             strValue = valueExpr.toString();\n         } else if (valueExpr instanceof SQLBooleanExpr) {\n-            strValue = valueExpr.toString();\n+            // SQLBooleanExpr toString is xFalse\n+            strValue = valueExpr.toString().substring(1);\n         }\n         return strValue;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitQueryHandler.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitQueryHandler.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitQueryHandler.java\t2024-09-08 01:36:10.385782477 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitQueryHandler.java\t2024-09-08 01:36:10.317782001 +1000\n@@ -46,7 +46,7 @@\n                         break;\n                     case RwSplitServerParse.SHOW:\n                     case RwSplitServerParse.SELECT:\n-                        session.execute(false, null);\n+                        session.execute(null, null);\n                         break;\n                     case RwSplitServerParse.SET:\n                         SetHandler.handle(sql, session.getService(), rs >>> 8);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitService.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitService.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitService.java\t2024-09-08 01:36:10.385782477 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/services/rwsplit/RWSplitService.java\t2024-09-08 01:36:10.317782001 +1000\n@@ -193,7 +193,7 @@\n             int sqlType = rs & 0xff;\n             switch (sqlType) {\n                 case ServerParse.SELECT:\n-                    session.execute(false, data, null);\n+                    session.execute(null, data, null);\n                     break;\n                 default:\n                     session.execute(true, data, null);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/sqlengine/SetTestJob.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/sqlengine/SetTestJob.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/actiontech/dble/sqlengine/SetTestJob.java\t2024-09-08 01:36:10.385782477 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/actiontech/dble/sqlengine/SetTestJob.java\t2024-09-08 01:36:10.317782001 +1000\n@@ -10,18 +10,19 @@\n import com.actiontech.dble.backend.mysql.nio.handler.ResetConnHandler;\n import com.actiontech.dble.backend.mysql.nio.handler.ResponseHandler;\n import com.actiontech.dble.config.ErrorCode;\n-import com.actiontech.dble.config.Fields;\n import com.actiontech.dble.net.connection.BackendConnection;\n import com.actiontech.dble.net.mysql.ErrorPacket;\n import com.actiontech.dble.net.mysql.FieldPacket;\n import com.actiontech.dble.net.mysql.ResetConnectionPacket;\n import com.actiontech.dble.net.mysql.RowDataPacket;\n import com.actiontech.dble.net.service.AbstractService;\n+import com.actiontech.dble.plan.common.field.FieldUtil;\n import com.actiontech.dble.server.variables.MysqlVariable;\n import com.actiontech.dble.services.BusinessService;\n import com.actiontech.dble.services.mysqlsharding.MySQLResponseService;\n import com.actiontech.dble.services.mysqlsharding.ShardingService;\n import com.actiontech.dble.services.rwsplit.RWSplitService;\n+import com.actiontech.dble.util.HexFormatUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -165,14 +166,17 @@\n     public boolean rowResponse(byte[] row, RowDataPacket rowPacket, boolean isLeft, AbstractService service) {\n         RowDataPacket rowDataPk = new RowDataPacket(fieldPackets.size());\n         rowDataPk.read(row);\n+\n+        FieldPacket fieldPacket;\n         for (int i = 0; i < userVariableSize; i++) {\n             if (rowDataPk.getValue(i) == null) {\n                 continue;\n             }\n-            int type = fieldPackets.get(i).getType();\n-            if (type == Fields.FIELD_TYPE_LONG || type == Fields.FIELD_TYPE_LONGLONG || type == Fields.FIELD_TYPE_NEW_DECIMAL ||\n-                    type == Fields.FIELD_TYPE_FLOAT | type == Fields.FIELD_TYPE_DOUBLE) {\n+            fieldPacket = fieldPackets.get(i);\n+            if (FieldUtil.isNumberType(fieldPacket.getType())) {\n                 setItems[i].setValue(new String(rowDataPk.getValue(i)));\n+            } else if (FieldUtil.isBinaryType(fieldPacket.getType()) && (fieldPacket.getFlags() & FieldUtil.BINARY_FLAG) != 0) {\n+                setItems[i].setValue(\"0x\" + HexFormatUtil.bytesToHexString(rowDataPk.getValue(i)));\n             } else {\n                 setItems[i].setValue(\"'\" + new String(rowDataPk.getValue(i)) + \"'\");\n             }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/BackendConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/BackendConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/BackendConnection.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/BackendConnection.java\t2024-09-08 01:36:10.321782029 +1000\n@@ -49,7 +49,7 @@\n     void execute(RouteResultsetNode node, ServerConnection source,\n                  boolean autocommit);\n \n-    boolean syncAndExcute();\n+    boolean syncAndExecute();\n \n     void rollback();\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -29,7 +29,7 @@\n \n /**\n  * company where id=(select company_id from customer where id=3); the one which\n- * return data (id) is the datanode to store child table's records\n+ * return data (id) is the data node to store child table's records\n  *\n  * @author wuzhih, huqing.yan\n  */\n@@ -73,7 +73,7 @@\n             PhysicalDBNode mysqlDN = conf.getDataNodes().get(dn);\n             try {\n                 if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"execute in datanode \" + dn);\n+                    LOGGER.debug(\"execute in data_node \" + dn);\n                 }\n                 RouteResultsetNode node = new RouteResultsetNode(dn, ServerParse.SELECT, sql);\n                 node.setRunOnSlave(false); // get child node from master\n@@ -161,7 +161,7 @@\n         if (LOGGER.isDebugEnabled()) {\n             LOGGER.debug(\"okResponse \" + conn);\n         }\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             finished.incrementAndGet();\n             if (canReleaseConn()) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -73,7 +73,7 @@\n \n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             if (clearIfSessionClosed(session)) {\n                 return;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -56,7 +56,7 @@\n         }\n \n         if (LOGGER.isDebugEnabled()) {\n-            LOGGER.debug(\"execute mutinode query \" + rrs.getStatement());\n+            LOGGER.debug(\"execute multiNode query \" + rrs.getStatement());\n         }\n \n         this.rrs = RouteResultCopy.rrCopy(rrs, ServerParse.SELECT, STMT);\n@@ -138,7 +138,7 @@\n                 errConnection = new ArrayList<>();\n             }\n             errConnection.add(conn);\n-            if (!conn.syncAndExcute()) {\n+            if (!conn.syncAndExecute()) {\n                 return;\n             }\n             if (--nodeCount <= 0) {\n@@ -167,7 +167,7 @@\n                 errConnection = new ArrayList<>();\n             }\n             errConnection.add(conn);\n-            if (!conn.syncAndExcute()) {\n+            if (!conn.syncAndExecute()) {\n                 return;\n             }\n             if (--nodeCount <= 0) {\n@@ -196,7 +196,7 @@\n         try {\n             if (!isFail())\n                 setFail(err.toString());\n-            if (!conn.syncAndExcute()) {\n+            if (!conn.syncAndExecute()) {\n                 return;\n             }\n             if (--nodeCount > 0)\n@@ -210,7 +210,7 @@\n     /* arriving here is impossible */\n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n-        if (!conn.syncAndExcute()) {\n+        if (!conn.syncAndExecute()) {\n             LOGGER.debug(\"MultiNodeDdlHandler should not arrive here(okResponse) !\");\n         }\n     }\n@@ -218,10 +218,10 @@\n     @Override\n     public void rowEofResponse(final byte[] eof, boolean isLeft, BackendConnection conn) {\n         if (LOGGER.isDebugEnabled()) {\n-            LOGGER.debug(\"on row end reseponse \" + conn);\n+            LOGGER.debug(\"on row end response \" + conn);\n         }\n \n-        if (errorRepsponsed.get()) {\n+        if (errorResponsed.get()) {\n             return;\n         }\n \n@@ -262,14 +262,14 @@\n     }\n \n     @Override\n-    public void fieldEofResponse(byte[] header, List<byte[]> fields, List<FieldPacket> fieldPacketsnull, byte[] eof,\n+    public void fieldEofResponse(byte[] header, List<byte[]> fields, List<FieldPacket> fieldPacketsNull, byte[] eof,\n                                  boolean isLeft, BackendConnection conn) {\n     }\n \n     @Override\n-    public boolean rowResponse(final byte[] row, RowDataPacket rowPacketnull, boolean isLeft, BackendConnection conn) {\n+    public boolean rowResponse(final byte[] row, RowDataPacket rowPacketNull, boolean isLeft, BackendConnection conn) {\n         /* It is impossible arriving here, because we set limit to 0 */\n-        return errorRepsponsed.get();\n+        return errorResponsed.get();\n     }\n \n     @Override\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -26,7 +26,7 @@\n     private AtomicBoolean isFailed = new AtomicBoolean(false);\n     protected volatile String error;\n     protected byte packetId;\n-    protected final AtomicBoolean errorRepsponsed = new AtomicBoolean(false);\n+    protected final AtomicBoolean errorResponsed = new AtomicBoolean(false);\n \n     public MultiNodeHandler(NonBlockingSession session) {\n         if (session == null) {\n@@ -48,7 +48,7 @@\n \n \n     protected boolean canClose(BackendConnection conn, boolean tryErrorFinish) {\n-        // realse this connection if safe\n+        // release this connection if safe\n         session.releaseConnectionIfSafe(conn, false);\n         boolean allFinished = false;\n         if (tryErrorFinish) {\n@@ -69,9 +69,9 @@\n         session.releaseConnectionIfSafe(conn, false);\n         ErrorPacket err = new ErrorPacket();\n         err.read(data);\n-        String errmsg = new String(err.getMessage());\n-        this.setFail(errmsg);\n-        LOGGER.warn(\"error response from \" + conn + \" err \" + errmsg + \" code:\" + err.getErrno());\n+        String errMsg = new String(err.getMessage());\n+        this.setFail(errMsg);\n+        LOGGER.warn(\"error response from \" + conn + \" err \" + errMsg + \" code:\" + err.getErrno());\n         this.tryErrorFinished(this.decrementCountBy(1));\n     }\n \n@@ -109,7 +109,7 @@\n         packetId = 0;\n     }\n \n-    protected ErrorPacket createErrPkg(String errmgs) {\n+    protected ErrorPacket createErrPkg(String errMsg) {\n         ErrorPacket err = new ErrorPacket();\n         lock.lock();\n         try {\n@@ -118,13 +118,13 @@\n             lock.unlock();\n         }\n         err.setErrno(ErrorCode.ER_UNKNOWN_ERROR);\n-        err.setMessage(StringUtil.encode(errmgs, session.getSource().getCharset().getResults()));\n+        err.setMessage(StringUtil.encode(errMsg, session.getSource().getCharset().getResults()));\n         return err;\n     }\n \n     protected void tryErrorFinished(boolean allEnd) {\n         if (allEnd && !session.closed()) {\n-            if (errorRepsponsed.compareAndSet(false, true)) {\n+            if (errorResponsed.compareAndSet(false, true)) {\n                 createErrPkg(this.error).write(session.getSource());\n             }\n             // clear session resources,release all\n@@ -135,7 +135,7 @@\n                 session.closeAndClearResources(error);\n             } else {\n                 session.getSource().setTxInterrupt(this.error);\n-                // clear resouces\n+                // clear resources\n                 clearResources();\n             }\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -263,7 +263,7 @@\n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n         this.netOutBytes += data.length;\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (LOGGER.isDebugEnabled()) {\n             LOGGER.debug(\"received ok response ,executeResponse:\" + executeResponse + \" from \" + conn);\n         }\n@@ -321,7 +321,7 @@\n \n         this.netOutBytes += eof.length;\n \n-        if (errorRepsponsed.get()) {\n+        if (errorResponsed.get()) {\n             return;\n         }\n \n@@ -645,7 +645,7 @@\n     }\n \n     public void handleDataProcessException(Exception e) {\n-        if (!errorRepsponsed.get()) {\n+        if (!errorResponsed.get()) {\n             this.error = e.toString();\n             LOGGER.warn(\"caught exception \", e);\n             setFail(e.toString());\n@@ -656,7 +656,7 @@\n     @Override\n     public boolean rowResponse(final byte[] row, RowDataPacket rowPacketnull, boolean isLeft, BackendConnection conn) {\n \n-        if (errorRepsponsed.get()) {\n+        if (errorResponsed.get()) {\n             // the connection has been closed or set to \"txInterrupt\" properly\n             //in tryErrorFinished() method! If we close it here, it can\n             // lead to tx error such as blocking rollback tx for ever.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -81,7 +81,7 @@\n \n     @Override\n     public void okResponse(byte[] ok, BackendConnection conn) {\n-        conn.syncAndExcute();\n+        conn.syncAndExecute();\n     }\n \n     @Override\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler: ResetConnHandler.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -176,7 +176,7 @@\n         //\n         this.netOutBytes += data.length;\n \n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             session.handleSpecial(rrs, session.getSource().getSchema(), true);\n             ServerConnection source = session.getSource();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -84,7 +84,7 @@\n \n     @Override\n     public void okResponse(byte[] data, BackendConnection conn) {\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             boolean isEndPack = decrementCountBy(1);\n             session.releaseConnection(conn);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java\t2024-09-08 01:36:10.393782533 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java\t2024-09-08 01:36:10.325782057 +1000\n@@ -15,10 +15,12 @@\n import com.actiontech.dble.net.BackendAIOConnection;\n import com.actiontech.dble.net.mysql.*;\n import com.actiontech.dble.route.RouteResultsetNode;\n+import com.actiontech.dble.route.parser.util.Pair;\n import com.actiontech.dble.server.NonBlockingSession;\n import com.actiontech.dble.server.ServerConnection;\n import com.actiontech.dble.server.SystemVariables;\n import com.actiontech.dble.server.parser.ServerParse;\n+import com.actiontech.dble.util.StringUtil;\n import com.actiontech.dble.util.TimeUtil;\n import com.actiontech.dble.util.exception.UnknownTxIsolationException;\n import org.slf4j.Logger;\n@@ -27,6 +29,7 @@\n import java.io.UnsupportedEncodingException;\n import java.nio.channels.NetworkChannel;\n import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -44,7 +47,7 @@\n     private volatile boolean isDDL = false;\n     private volatile boolean isRunning;\n     private volatile StatusSync statusSync;\n-    private volatile boolean metaDataSyned = true;\n+    private volatile boolean metaDataSynced = true;\n     private volatile TxState xaStatus = TxState.TX_INITIALIZE_STATE;\n     private volatile int txIsolation;\n     private volatile boolean autocommit;\n@@ -137,8 +140,18 @@\n         *  it need to sync the status firstly for new idle connection*/\n         this.txIsolation = -1;\n         this.complexQuery = false;\n+        this.usrVariables = new LinkedHashMap<>();\n+        this.sysVariables = new LinkedHashMap<>();\n     }\n \n+    public void resetContextStatus() {\n+        this.txIsolation = -1;\n+        this.autocommit = true;\n+        //TODO:CHECK\n+        this.setCharacterSet(SystemVariables.getDefaultValue(\"character_set_server\"));\n+        this.usrVariables.clear();\n+        this.sysVariables.clear();\n+    }\n     public void setRunning(boolean running) {\n         isRunning = running;\n     }\n@@ -211,7 +224,7 @@\n         this.threadId = threadId;\n     }\n \n-    public void setAuthenticated(boolean authenticated) {\n+    void setAuthenticated(boolean authenticated) {\n         isAuthenticated = authenticated;\n     }\n \n@@ -219,7 +232,7 @@\n         return password;\n     }\n \n-    public void authenticate() {\n+    void authenticate() {\n         AuthPacket packet = new AuthPacket();\n         packet.setPacketId(1);\n         packet.setClientFlags(clientFlags);\n@@ -254,7 +267,7 @@\n         return isClosed() || isQuit.get();\n     }\n \n-    protected void sendQueryCmd(String query, CharsetNames clientCharset) {\n+    public void sendQueryCmd(String query, CharsetNames clientCharset) {\n         CommandPacket packet = new CommandPacket();\n         packet.setPacketId(0);\n         packet.setCommand(MySQLPacket.COM_QUERY);\n@@ -316,7 +329,7 @@\n         if (!sc.isAutocommit() && !sc.isTxstart() && modifiedSQLExecuted) {\n             sc.setTxstart(true);\n         }\n-        synAndDoExecute(xaTxId, rrn, sc.getCharset(), sc.getTxIsolation(), isAutoCommit);\n+        synAndDoExecute(xaTxId, rrn, sc.getCharset(), sc.getTxIsolation(), isAutoCommit, sc.getUsrVariables(), sc.getSysVariables());\n     }\n \n     public String getConnXID(NonBlockingSession session) {\n@@ -329,23 +342,26 @@\n     }\n \n     private void synAndDoExecute(String xaTxID, RouteResultsetNode rrn,\n-                                 CharsetNames clientCharset, int clientTxIsoLation,\n-                                 boolean expectAutocommit) {\n+                                 CharsetNames clientCharset, int clientTxIsolation,\n+                                 boolean expectAutocommit, Map<String, String> usrVariables, Map<String, String> sysVariables) {\n         String xaCmd = null;\n-        boolean conAutoComit = this.autocommit;\n+        boolean conAutoCommit = this.autocommit;\n         String conSchema = this.schema;\n         int xaSyn = 0;\n         if (!expectAutocommit && xaTxID != null && xaStatus == TxState.TX_INITIALIZE_STATE) {\n-            // clientTxIsoLation = Isolations.SERIALIZABLE;\n+            // clientTxIsolation = Isolation.SERIALIZABLE;TODO:NEEDED?\n             xaCmd = \"XA START \" + xaTxID + ';';\n             this.xaStatus = TxState.TX_STARTED_STATE;\n             xaSyn = 1;\n         }\n+        Set<String> toResetSys = new HashSet();\n+        String setSql = getSetSQL(usrVariables, sysVariables, toResetSys);\n+        int setSqlFlag = setSql == null ? 0 : 1;\n         int schemaSyn = conSchema.equals(oldSchema) ? 0 : 1;\n         int charsetSyn = (charsetName.equals(clientCharset)) ? 0 : 1;\n-        int txIsoLationSyn = (txIsolation == clientTxIsoLation) ? 0 : 1;\n-        int autoCommitSyn = (conAutoComit == expectAutocommit) ? 0 : 1;\n-        int synCount = schemaSyn + charsetSyn + txIsoLationSyn + autoCommitSyn + xaSyn;\n+        int txIsolationSyn = (txIsolation == clientTxIsolation) ? 0 : 1;\n+        int autoCommitSyn = (conAutoCommit == expectAutocommit) ? 0 : 1;\n+        int synCount = schemaSyn + charsetSyn + txIsolationSyn + autoCommitSyn + xaSyn + setSqlFlag;\n         if (synCount == 0) {\n             // not need syn connection\n             sendQueryCmd(rrn.getStatement(), clientCharset);\n@@ -355,18 +371,19 @@\n         StringBuilder sb = new StringBuilder();\n         if (schemaSyn == 1) {\n             schemaCmd = getChangeSchemaCommand(conSchema);\n-            // getChangeSchemaCommand(sb, conSchema);\n         }\n-\n         if (charsetSyn == 1) {\n             getCharsetCommand(sb, clientCharset);\n         }\n-        if (txIsoLationSyn == 1) {\n-            getTxIsolationCommand(sb, clientTxIsoLation);\n+        if (txIsolationSyn == 1) {\n+            getTxIsolationCommand(sb, clientTxIsolation);\n         }\n         if (autoCommitSyn == 1) {\n             getAutocommitCommand(sb, expectAutocommit);\n         }\n+        if (setSqlFlag == 1) {\n+            sb.append(setSql);\n+        }\n         if (xaCmd != null) {\n             sb.append(xaCmd);\n         }\n@@ -375,22 +392,73 @@\n                     \" commands \" + sb.toString() + \"schema change:\" +\n                     (schemaCmd != null) + \" con:\" + this);\n         }\n-        metaDataSyned = false;\n+        metaDataSynced = false;\n         statusSync = new StatusSync(conSchema,\n-                clientCharset, clientTxIsoLation, expectAutocommit,\n-                synCount);\n+                clientCharset, clientTxIsolation, expectAutocommit,\n+                synCount, usrVariables, sysVariables, toResetSys);\n         // syn schema\n         if (schemaCmd != null) {\n             schemaCmd.write(this);\n         }\n         // and our query sql to multi command at last\n-        sb.append(rrn.getStatement() + \";\");\n+        sb.append(rrn.getStatement()).append(\";\");\n         // syn and execute others\n         this.sendQueryCmd(sb.toString(), clientCharset);\n         // waiting syn result...\n \n     }\n \n+    private String getSetSQL(Map<String, String> usrVars, Map<String, String> sysVars, Set<String> toResetSys) {\n+        //new final var\n+        List<Pair<String, String>> setVars = new ArrayList<>();\n+        Map<String, String> tmpSysVars = new HashMap<>();\n+        //tmp add all backend sysVariables\n+        tmpSysVars.putAll(sysVariables);\n+        //for all front end sysVariables\n+        for (Map.Entry<String, String> entry : sysVars.entrySet()) {\n+            if (!tmpSysVars.containsKey(entry.getKey())) {\n+                setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+            } else {\n+                String value = tmpSysVars.remove(entry.getKey());\n+                //if backend is not equal frontend, need to reset\n+                if (!StringUtil.equalsIgnoreCase(entry.getValue(), value)) {\n+                    setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+                }\n+            }\n+        }\n+        //tmp now = backend -(backend &&frontend)\n+        for (Map.Entry<String, String> entry : tmpSysVars.entrySet()) {\n+            String value = SystemVariables.getDefaultValue(entry.getKey());\n+            setVars.add(new Pair<>(entry.getKey(), value));\n+            toResetSys.add(entry.getKey());\n+        }\n+\n+        for (Map.Entry<String, String> entry : usrVars.entrySet()) {\n+            if (!usrVariables.containsKey(entry.getKey())) {\n+                setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+            } else {\n+                if (!StringUtil.equalsIgnoreCase(entry.getValue(), usrVariables.get(entry.getKey()))) {\n+                    setVars.add(new Pair<>(entry.getKey(), entry.getValue()));\n+                }\n+            }\n+        }\n+\n+        if (setVars.size() == 0)\n+            return null;\n+        StringBuilder sb = new StringBuilder(\"set \");\n+        int cnt = 0;\n+        for (Pair<String, String> var : setVars) {\n+            if (cnt > 0) {\n+                sb.append(\",\");\n+            }\n+            sb.append(var.getKey());\n+            sb.append(\"=\");\n+            sb.append(var.getValue());\n+            cnt++;\n+        }\n+        sb.append(\";\");\n+        return sb.toString();\n+    }\n     private static CommandPacket getChangeSchemaCommand(String schema) {\n         CommandPacket cmd = new CommandPacket();\n         cmd.setPacketId(0);\n@@ -402,14 +470,11 @@\n     /**\n      * by wuzh ,execute a query and ignore transaction settings for performance\n      *\n-     * @param query\n-     * @throws UnsupportedEncodingException\n      */\n-    public void query(String query) throws UnsupportedEncodingException {\n+    public void query(String query) {\n         RouteResultsetNode rrn = new RouteResultsetNode(\"default\",\n                 ServerParse.SELECT, query);\n-\n-        synAndDoExecute(null, rrn, this.charsetName, this.txIsolation, true);\n+        synAndDoExecute(null, rrn, this.charsetName, this.txIsolation, true, this.getUsrVariables(), this.getSysVariables());\n \n     }\n \n@@ -432,7 +497,7 @@\n     }\n \n \n-    public boolean isComplexQuery() {\n+    boolean isComplexQuery() {\n         return complexQuery;\n     }\n \n@@ -472,18 +537,23 @@\n     }\n \n     public void release() {\n-        if (!metaDataSyned) { // indicate connection not normalfinished\n+        if (!metaDataSynced) { // indicate connection not normal finished\n             // ,and\n             // we can't know it's syn status ,so\n             // close\n             // it\n             LOGGER.warn(\"can't sure connection syn result,so close it \" + this);\n             this.respHandler = null;\n-            this.close(\"syn status unkown \");\n+            this.close(\"syn status unknown \");\n+            return;\n+        }\n+        if (this.usrVariables.size() > 0) {\n+            this.respHandler = null;\n+            this.close(\"close for clear usrVariables\");\n             return;\n         }\n         complexQuery = false;\n-        metaDataSyned = true;\n+        metaDataSynced = true;\n         attachment = null;\n         statusSync = null;\n         modifiedSQLExecuted = false;\n@@ -541,12 +611,53 @@\n \n     @Override\n     public String toString() {\n-        return \"MySQLConnection [id=\" + id + \", lastTime=\" + lastTime + \", user=\" + user + \", schema=\" + schema +\n-                \", old shema=\" + oldSchema + \", borrowed=\" + borrowed + \", fromSlaveDB=\" + fromSlaveDB + \", threadId=\" +\n-                threadId + \",\" + charsetName.toString() + \", txIsolation=\" + txIsolation + \", autocommit=\" + autocommit +\n-                \", attachment=\" + attachment + \", respHandler=\" + respHandler + \", host=\" + host + \", port=\" + port +\n-                \", statusSync=\" + statusSync + \", writeQueue=\" + this.getWriteQueue().size() +\n-                \", modifiedSQLExecuted=\" + modifiedSQLExecuted + \"]\";\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"MySQLConnection [id=\");\n+        result.append(id);\n+        result.append(\", lastTime=\");\n+        result.append(lastTime);\n+        result.append(\", user=\");\n+        result.append(user);\n+        result.append(\", schema=\");\n+        result.append(schema);\n+        result.append(\", old schema=\");\n+        result.append(oldSchema);\n+        result.append(\", borrowed=\");\n+        result.append(borrowed);\n+        result.append(\", fromSlaveDB=\");\n+        result.append(fromSlaveDB);\n+        result.append(\", threadId=\");\n+        result.append(threadId);\n+        result.append(\",\");\n+        result.append(charsetName.toString());\n+        result.append(\", txIsolation=\");\n+        result.append(txIsolation);\n+        result.append(\", autocommit=\");\n+        result.append(autocommit);\n+        result.append(\", attachment=\");\n+        result.append(attachment);\n+        result.append(\", respHandler=\");\n+        result.append(respHandler);\n+        result.append(\", host=\");\n+        result.append(host);\n+        result.append(\", port=\");\n+        result.append(port);\n+        result.append(\", statusSync=\");\n+        result.append(statusSync);\n+        result.append(\", writeQueue=\");\n+        result.append(this.getWriteQueue().size());\n+        result.append(\", modifiedSQLExecuted=\");\n+        result.append(modifiedSQLExecuted);\n+        if (sysVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfSysVariables());\n+        }\n+        if (usrVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfUsrVariables());\n+        }\n+        result.append(\"]\");\n+        return result.toString();\n     }\n \n     public String compactInfo() {\n@@ -572,7 +683,7 @@\n      * @return if synchronization finished and execute-sql has already been sent\n      * before\n      */\n-    public boolean syncAndExcute() {\n+    public boolean syncAndExecute() {\n         StatusSync sync = this.statusSync;\n         if (sync == null) {\n             return true;\n@@ -592,23 +703,30 @@\n         private final Integer txtIsolation;\n         private final Boolean autocommit;\n         private final AtomicInteger synCmdCount;\n+        private final Map<String, String> usrVariables = new LinkedHashMap<>();\n+        private final Map<String, String> sysVariables = new LinkedHashMap<>();\n \n         StatusSync(String schema,\n                    CharsetNames clientCharset, Integer txtIsolation, Boolean autocommit,\n-                   int synCount) {\n+                   int synCount, Map<String, String> usrVariables, Map<String, String> sysVariables, Set<String> toResetSys) {\n             super();\n             this.schema = schema;\n             this.clientCharset = clientCharset;\n             this.txtIsolation = txtIsolation;\n             this.autocommit = autocommit;\n             this.synCmdCount = new AtomicInteger(synCount);\n+            this.usrVariables.putAll(usrVariables);\n+            this.sysVariables.putAll(sysVariables);\n+            for (String sysVariable : toResetSys) {\n+                this.sysVariables.remove(sysVariable);\n+            }\n         }\n \n-        public boolean synAndExecuted(MySQLConnection conn) {\n+        boolean synAndExecuted(MySQLConnection conn) {\n             int remains = synCmdCount.decrementAndGet();\n             if (remains == 0) { // syn command finished\n                 this.updateConnectionInfo(conn);\n-                conn.metaDataSyned = true;\n+                conn.metaDataSynced = true;\n                 return false;\n             } else if (remains < 0) {\n                 return true;\n@@ -630,7 +748,8 @@\n             if (autocommit != null) {\n                 conn.autocommit = autocommit;\n             }\n+            conn.sysVariables = sysVariables;\n+            conn.usrVariables = usrVariables;\n         }\n-\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/config/Versions.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/config/Versions.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/config/Versions.java\t2024-09-08 01:36:10.397782561 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/config/Versions.java\t2024-09-08 01:36:10.329782085 +1000\n@@ -12,7 +12,7 @@\n \n     public static final byte PROTOCOL_VERSION = 10;\n \n-    private static byte[] serverVersion = \"5.6.29-dble-2.17.08.0-20240827175049\".getBytes();\n+    private static byte[] serverVersion = \"5.6.29-dble-2.17.08.0-20240827175206\".getBytes();\n     public static final byte[] VERSION_COMMENT = \"dble Server (ActionTech)\".getBytes();\n     public static final String ANNOTATION_NAME = \"dble:\";\n     public static final String ROOT_PREFIX = \"dble\";\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java\t2024-09-08 01:36:10.401782589 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java\t2024-09-08 01:36:10.333782113 +1000\n@@ -32,7 +32,7 @@\n     private ShowBackend() {\n     }\n \n-    private static final int FIELD_COUNT = 18;\n+    private static final int FIELD_COUNT = 20;\n     private static final ResultSetHeaderPacket HEADER = PacketUtil.getHeader(FIELD_COUNT);\n     private static final FieldPacket[] FIELDS = new FieldPacket[FIELD_COUNT];\n     private static final EOFPacket EOF = new EOFPacket();\n@@ -41,8 +41,7 @@\n         int i = 0;\n         byte packetId = 0;\n         HEADER.setPacketId(++packetId);\n-        FIELDS[i] = PacketUtil.getField(\"processor\",\n-                Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"processor\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n         FIELDS[i] = PacketUtil.getField(\"ID\", Fields.FIELD_TYPE_LONG);\n         FIELDS[i++].setPacketId(++packetId);\n@@ -76,10 +75,15 @@\n         FIELDS[i++].setPacketId(++packetId);\n         FIELDS[i] = PacketUtil.getField(\"CHARACTER_SET_RESULTS\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n-        FIELDS[i] = PacketUtil.getField(\"TXLEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"TX_ISOLATION_LEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n         FIELDS[i] = PacketUtil.getField(\"AUTOCOMMIT\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+        FIELDS[i] = PacketUtil.getField(\"SYS_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+        FIELDS[i] = PacketUtil.getField(\"USER_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i].setPacketId(++packetId);\n+\n         EOF.setPacketId(++packetId);\n     }\n \n@@ -132,6 +136,8 @@\n         row.add(conn.getCharset().getResults().getBytes());\n         row.add((conn.getTxIsolation() + \"\").getBytes());\n         row.add((conn.isAutocommit() + \"\").getBytes());\n+        row.add(StringUtil.encode(conn.getStringOfSysVariables(), charset));\n+        row.add(StringUtil.encode(conn.getStringOfUsrVariables(), charset));\n         return row;\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java\t2024-09-08 01:36:10.401782589 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java\t2024-09-08 01:36:10.333782113 +1000\n@@ -33,7 +33,7 @@\n     private ShowConnection() {\n     }\n \n-    private static final int FIELD_COUNT = 17;\n+    private static final int FIELD_COUNT = 19;\n     private static final ResultSetHeaderPacket HEADER = PacketUtil.getHeader(FIELD_COUNT);\n     private static final FieldPacket[] FIELDS = new FieldPacket[FIELD_COUNT];\n     private static final EOFPacket EOF = new EOFPacket();\n@@ -80,8 +80,7 @@\n         FIELDS[i] = PacketUtil.getField(\"NET_OUT\", Fields.FIELD_TYPE_LONGLONG);\n         FIELDS[i++].setPacketId(++packetId);\n \n-        FIELDS[i] = PacketUtil.getField(\"ALIVE_TIME(S)\",\n-                Fields.FIELD_TYPE_LONGLONG);\n+        FIELDS[i] = PacketUtil.getField(\"ALIVE_TIME(S)\", Fields.FIELD_TYPE_LONGLONG);\n         FIELDS[i++].setPacketId(++packetId);\n \n         FIELDS[i] = PacketUtil.getField(\"RECV_BUFFER\", Fields.FIELD_TYPE_LONG);\n@@ -90,11 +89,16 @@\n         FIELDS[i] = PacketUtil.getField(\"SEND_QUEUE\", Fields.FIELD_TYPE_LONG);\n         FIELDS[i++].setPacketId(++packetId);\n \n-        FIELDS[i] = PacketUtil.getField(\"TXLEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"TX_ISOLATION_LEVEL\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i++].setPacketId(++packetId);\n \n-        FIELDS[i] = PacketUtil.getField(\"AUTOCOMMIT\",\n-                Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i] = PacketUtil.getField(\"AUTOCOMMIT\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+\n+        FIELDS[i] = PacketUtil.getField(\"SYS_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n+        FIELDS[i++].setPacketId(++packetId);\n+\n+        FIELDS[i] = PacketUtil.getField(\"USER_VARIABLES\", Fields.FIELD_TYPE_VAR_STRING);\n         FIELDS[i].setPacketId(++packetId);\n \n         EOF.setPacketId(++packetId);\n@@ -156,15 +160,16 @@\n         row.add(IntegerUtil.toBytes(c.getWriteQueue().size()));\n \n         String txLevel = \"\";\n-        String txAutommit = \"\";\n+        String autocommit = \"\";\n         if (c instanceof ServerConnection) {\n-            ServerConnection mysqlC = (ServerConnection) c;\n-            txLevel = mysqlC.getTxIsolation() + \"\";\n-            txAutommit = mysqlC.isAutocommit() + \"\";\n+            ServerConnection serverConn = (ServerConnection) c;\n+            txLevel = serverConn.getTxIsolation() + \"\";\n+            autocommit = serverConn.isAutocommit() + \"\";\n         }\n         row.add(txLevel.getBytes());\n-        row.add(txAutommit.getBytes());\n-\n+        row.add(autocommit.getBytes());\n+        row.add(StringUtil.encode(c.getStringOfSysVariables(), charset));\n+        row.add(StringUtil.encode(c.getStringOfUsrVariables(), charset));\n         return row;\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java\t2024-09-08 01:36:10.401782589 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java\t2024-09-08 01:36:10.333782113 +1000\n@@ -18,7 +18,6 @@\n import com.actiontech.dble.net.mysql.RowDataPacket;\n import com.actiontech.dble.util.StringUtil;\n \n-import java.io.UnsupportedEncodingException;\n import java.nio.ByteBuffer;\n import java.util.Map;\n import java.util.concurrent.ConcurrentMap;\n@@ -176,8 +175,6 @@\n         }\n         // write eof\n         buffer = TOTAL_EOF.write(buffer, c, true);\n-        // write rows\n-        byte packetId = TOTAL_EOF.getPacketId();\n \n         int useOffHeapForMerge = DbleServer.getInstance().getConfig().\n                 getSystem().getUseOffHeapForMerge();\n@@ -250,7 +247,8 @@\n         }\n \n         row.add(StringUtil.encode(resevedForOs > 0 ? JavaUtils.bytesToString2(resevedForOs) : \"0\", c.getCharset().getResults()));\n-\n+        // write rows\n+        byte packetId = TOTAL_EOF.getPacketId();\n         row.setPacketId(++packetId);\n         buffer = row.write(buffer, c, true);\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/AbstractConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/AbstractConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/AbstractConnection.java\t2024-09-08 01:36:10.405782618 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/AbstractConnection.java\t2024-09-08 01:36:10.333782113 +1000\n@@ -5,7 +5,6 @@\n */\n package com.actiontech.dble.net;\n \n-import com.actiontech.dble.backend.mysql.CharsetUtil;\n import com.actiontech.dble.net.mysql.CharsetNames;\n import com.actiontech.dble.net.mysql.MySQLPacket;\n import com.actiontech.dble.server.SystemVariables;\n@@ -20,6 +19,7 @@\n import java.nio.channels.AsynchronousChannel;\n import java.nio.channels.NetworkChannel;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -58,6 +58,8 @@\n     protected volatile boolean isSupportCompress = false;\n     protected final ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue = new ConcurrentLinkedQueue<>();\n     protected final ConcurrentLinkedQueue<byte[]> compressUnfinishedDataQueue = new ConcurrentLinkedQueue<>();\n+    protected volatile Map<String, String> usrVariables;\n+    protected volatile Map<String, String> sysVariables;\n \n     private long idleTimeout;\n \n@@ -83,31 +85,16 @@\n         this.isClosed = new AtomicBoolean(false);\n         this.socketWR = null;\n     }\n-    public boolean setCollationConnection(String collation) {\n-        int ci = CharsetUtil.getCollationIndex(collation);\n-        if (ci <= 0) {\n-            return false;\n-        }\n+    public void setCollationConnection(String collation) {\n         charsetName.setCollation(collation);\n-        return true;\n     }\n \n-    public boolean setCharacterConnection(String charset) {\n-        String collationName = CharsetUtil.getDefaultCollation(charset);\n-        if (collationName == null) {\n-            return false;\n-        }\n+    public void setCharacterConnection(String collationName) {\n         charsetName.setCollation(collationName);\n-        return true;\n     }\n \n-    public boolean setCharacterResults(String name) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0 && !name.equals(\"null\")) {\n-            return false;\n-        }\n+    public void setCharacterResults(String name) {\n         charsetName.setResults(name);\n-        return true;\n     }\n \n \n@@ -115,36 +102,17 @@\n         this.charsetName = charsetName.clone();\n     }\n \n-    public boolean setCharacterClient(String name) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0) {\n-            return false;\n-        }\n+    public void setCharacterClient(String name) {\n         charsetName.setClient(name);\n-        return true;\n     }\n \n-    public boolean setCharacterSet(String name) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0) {\n-            return false;\n-        }\n+    public void setCharacterSet(String name) {\n         charsetName.setClient(name);\n         charsetName.setResults(name);\n         charsetName.setCollation(SystemVariables.getDefaultValue(\"collation_database\"));\n-        return true;\n     }\n \n     public boolean setNames(String name, String collationName) {\n-        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n-        if (ci <= 0) {\n-            return false;\n-        }\n-        if (collationName == null) {\n-            collationName = CharsetUtil.getDefaultCollation(name);\n-        } else if (CharsetUtil.getCollationIndex(collationName) <= 0) {\n-            return false;\n-        }\n         charsetName.setNames(name, collationName);\n         return true;\n     }\n@@ -198,6 +166,14 @@\n         return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime, lastReadTime) + idleTimeout;\n     }\n \n+    public Map<String, String> getUsrVariables() {\n+        return usrVariables;\n+    }\n+\n+    public Map<String, String> getSysVariables() {\n+        return sysVariables;\n+    }\n+\n     public NetworkChannel getChannel() {\n         return channel;\n     }\n@@ -583,6 +559,39 @@\n         }\n     }\n \n+    public String getStringOfSysVariables() {\n+        StringBuilder sbSysVariables = new StringBuilder();\n+        int cnt = 0;\n+        if (sysVariables != null) {\n+            for (Map.Entry sysVariable : sysVariables.entrySet()) {\n+                if (cnt > 0) {\n+                    sbSysVariables.append(\",\");\n+                }\n+                sbSysVariables.append(sysVariable.getKey());\n+                sbSysVariables.append(\"=\");\n+                sbSysVariables.append(sysVariable.getValue());\n+                cnt++;\n+            }\n+        }\n+        return sbSysVariables.toString();\n+    }\n+\n+    public String getStringOfUsrVariables() {\n+        StringBuilder sbUsrVariables = new StringBuilder();\n+        int cnt = 0;\n+        if (usrVariables != null) {\n+            for (Map.Entry usrVariable : usrVariables.entrySet()) {\n+                if (cnt > 0) {\n+                    sbUsrVariables.append(\",\");\n+                }\n+                sbUsrVariables.append(usrVariable.getKey());\n+                sbUsrVariables.append(\"=\");\n+                sbUsrVariables.append(usrVariable.getValue());\n+                cnt++;\n+            }\n+        }\n+        return sbUsrVariables.toString();\n+    }\n     public void onConnectfinish() {\n         LOGGER.debug(\"The backend conntinon has finished connecting\");\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java\t2024-09-08 01:36:10.405782618 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java\t2024-09-08 01:36:10.337782141 +1000\n@@ -32,8 +32,7 @@\n  */\n public class OkPacket extends MySQLPacket {\n     public static final byte FIELD_COUNT = 0x00;\n-    public static final byte[] OK = new byte[]{7, 0, 0, 1, 0, 0, 0, 2, 0, 0,\n-            0};\n+    public static final byte[] OK = new byte[]{7, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0};\n \n     private byte fieldCount = FIELD_COUNT;\n     private long affectedRows;\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql: ResetConnectionPacket.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java\t2024-09-08 01:36:10.413782673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java\t2024-09-08 01:36:10.345782197 +1000\n@@ -82,7 +82,7 @@\n \n     @Override\n     public void okResponse(byte[] ok, BackendConnection conn) {\n-        boolean executeResponse = conn.syncAndExcute();\n+        boolean executeResponse = conn.syncAndExecute();\n         if (executeResponse) {\n             ((SequenceVal) conn.getAttachment()).dbfinished = true;\n             conn.release();\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler: SetCallBack.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/handler/SetHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\t2024-09-08 01:36:10.413782673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java\t2024-09-08 01:36:10.345782197 +1000\n@@ -11,15 +11,27 @@\n import com.actiontech.dble.config.Isolations;\n import com.actiontech.dble.log.transaction.TxnLogHelper;\n import com.actiontech.dble.net.mysql.OkPacket;\n+import com.actiontech.dble.route.parser.util.Pair;\n import com.actiontech.dble.route.parser.util.ParseUtil;\n import com.actiontech.dble.server.ServerConnection;\n-import com.actiontech.dble.server.parser.ServerParseSet;\n-import com.actiontech.dble.util.SetIgnoreUtil;\n+import com.actiontech.dble.server.SystemVariables;\n+import com.actiontech.dble.sqlengine.OneRawSQLQueryResultHandler;\n+import com.actiontech.dble.sqlengine.SetTestJob;\n import com.actiontech.dble.util.StringUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.actiontech.dble.server.parser.ServerParseSet.*;\n+import com.alibaba.druid.sql.ast.SQLExpr;\n+import com.alibaba.druid.sql.ast.SQLStatement;\n+import com.alibaba.druid.sql.ast.expr.*;\n+import com.alibaba.druid.sql.ast.statement.SQLAssignItem;\n+import com.alibaba.druid.sql.ast.statement.SQLSetStatement;\n+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetCharSetStatement;\n+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetNamesStatement;\n+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement;\n+import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;\n+import com.alibaba.druid.sql.parser.SQLStatementParser;\n+\n+import java.sql.SQLSyntaxErrorException;\n+import java.util.ArrayList;\n+import java.util.List;\n \n\n@@ -31,259 +43,712 @@\n     private SetHandler() {\n     }\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(SetHandler.class);\n-\n     private static final byte[] AC_OFF = new byte[]{7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};\n \n+    public enum KeyType {\n+        SYNTAX_ERROR,\n+        XA,\n+        AUTOCOMMIT,\n+        NAMES,\n+        CHARSET,\n+        CHARACTER_SET_CLIENT,\n+        CHARACTER_SET_CONNECTION,\n+        CHARACTER_SET_RESULTS,\n+        COLLATION_CONNECTION,\n+        SYSTEM_VARIABLES,\n+        USER_VARIABLES,\n+        TX_READ_ONLY,\n+        TX_ISOLATION\n+    }\n+\n     public static void handle(String stmt, ServerConnection c, int offset) {\n         if (!ParseUtil.isSpace(stmt.charAt(offset))) {\n             c.writeErrMessage(ErrorCode.ERR_WRONG_USED, stmt + \" is not supported\");\n         }\n-        int rs = ServerParseSet.parse(stmt, offset);\n-        switch (rs & 0xff) {\n-            case MULTI_SET:\n-                //set split with ','\n-                if (!parserMultiSet(stmt.substring(offset), c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                }\n-                break;\n-            case AUTOCOMMIT_ON:\n-                if (c.isAutocommit()) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        try {\n+            String smt = convertCharsetKeyWord(stmt);\n+            List<Pair<KeyType, Pair<String, String>>> contextTask = new ArrayList<>();\n+            if (handleSetStatement(smt, c, contextTask) && contextTask.size() > 0) {\n+                setStmtCallback(stmt, c, contextTask);\n+            }\n+        } catch (SQLSyntaxErrorException e) {\n+            c.writeErrMessage(ErrorCode.ER_PARSE_ERROR, e.toString());\n+        }\n+    }\n+\n+    private static SQLStatement parseSQL(String stmt) throws SQLSyntaxErrorException {\n+        SQLStatementParser parser = new MySqlStatementParser(stmt);\n+        try {\n+            return parser.parseStatement();\n+        } catch (Exception t) {\n+            if (t.getMessage() != null) {\n+                throw new SQLSyntaxErrorException(t.getMessage());\n+            } else {\n+                throw new SQLSyntaxErrorException(t);\n+            }\n+        }\n+    }\n+    private static boolean handleSetStatement(String stmt, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) throws SQLSyntaxErrorException {\n+        SQLStatement statement = parseSQL(stmt);\n+        if (statement instanceof SQLSetStatement) {\n+            List<SQLAssignItem> assignItems = ((SQLSetStatement) statement).getItems();\n+            if (assignItems.size() == 1 && contextTask.size() == 0) {\n+                return handleSingleVariable(stmt, assignItems.get(0), c, contextTask);\n+            } else {\n+                return handleSetMultiStatement(assignItems, c, contextTask);\n+            }\n+        } else if (statement instanceof MySqlSetNamesStatement) {\n+            MySqlSetNamesStatement setNamesStatement = (MySqlSetNamesStatement) statement;\n+            if (contextTask.size() > 0 || stmt.contains(\",\")) {\n+                if (handleSetNamesInMultiStmt(c, setNamesStatement.getCharSet(), setNamesStatement.getCollate(), contextTask)) {\n+                    int index = stmt.indexOf(\",\");\n+                    String newStmt = \"set \" + stmt.substring(index + 1);\n+                    return handleSetStatement(newStmt, c, contextTask);\n                 } else {\n-                    c.commit(\"commit[because of \" + stmt + \"]\");\n-                    c.setAutocommit(true);\n+                    return false;\n                 }\n-                break;\n-            case AUTOCOMMIT_OFF: {\n-                if (c.isAutocommit()) {\n-                    c.setAutocommit(false);\n-                    TxnLogHelper.putTxnLog(c, stmt);\n-                }\n-                c.write(c.writeToBuffer(AC_OFF, c.allocate()));\n-                break;\n+            } else {\n+                return handleSingleSetNames(stmt, c, setNamesStatement);\n             }\n-            case XA_FLAG_ON: {\n-                if (c.isTxstart() && c.getSession2().getSessionXaID() == null) {\n-                    c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd on can't used before ending a transaction\");\n-                    return;\n+        } else if (statement instanceof MySqlSetCharSetStatement) {\n+            MySqlSetCharSetStatement setCharSetStatement = (MySqlSetCharSetStatement) statement;\n+            if (contextTask.size() > 0 || stmt.contains(\",\")) {\n+                if (handleCharsetInMultiStmt(c, setCharSetStatement.getCharSet(), contextTask)) {\n+                    int index = stmt.indexOf(\",\");\n+                    String newStmt = \"set \" + stmt.substring(index + 1);\n+                    return handleSetStatement(newStmt, c, contextTask);\n+                } else {\n+                    return false;\n                 }\n-                c.getSession2().setXaTxEnabled(true);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                break;\n+            } else {\n+                return handleSingleSetCharset(stmt, c, setCharSetStatement);\n             }\n-            case XA_FLAG_OFF: {\n-                if (c.isTxstart() && c.getSession2().getSessionXaID() != null) {\n-                    c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd off can't used before ending a transaction\");\n-                    return;\n-                }\n-                c.getSession2().setXaTxEnabled(false);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                return;\n+        } else if (statement instanceof MySqlSetTransactionStatement) {\n+            return handleTransaction(c, (MySqlSetTransactionStatement) statement);\n+        } else {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, stmt + \" is not recognized and ignored\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSetNamesInMultiStmt(ServerConnection c, String charset, String collate, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String[] charsetInfo = checkSetNames(charset, collate);\n+        if (charsetInfo != null) {\n+            contextTask.add(new Pair<>(KeyType.NAMES, new Pair<>(charsetInfo[0], charsetInfo[1])));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set  '\" + charset + \" or collate '\" + collate + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleSetNames(String stmt, ServerConnection c, MySqlSetNamesStatement statement) {\n+        String[] charsetInfo = checkSetNames(statement.getCharSet(), statement.getCollate());\n+        if (charsetInfo != null) {\n+            c.setNames(charsetInfo[0], charsetInfo[1]);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set in statement '\" + stmt + \"\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleSetCharset(String stmt, ServerConnection c, MySqlSetCharSetStatement statement) {\n+        String charset = getCharset(statement.getCharSet());\n+        if (charset != null) {\n+            c.setCharacterSet(charset);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set in statement '\" + stmt + \"\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSetMultiStatement(List<SQLAssignItem> assignItems, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        for (SQLAssignItem assignItem : assignItems) {\n+            if (!handleVariableInMultiStmt(assignItem, c, contextTask)) {\n+                return false;\n             }\n-            case TX_READ_UNCOMMITTED: {\n-                c.setTxIsolation(Isolations.READ_UNCOMMITTED);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        }\n+        return true;\n+    }\n+\n+    //execute multiStmt and callback to reset conn\n+    private static void setStmtCallback(String multiStmt, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        c.setContextTask(contextTask);\n+        OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(new String[0], new SetCallBack(c));\n+        SetTestJob sqlJob = new SetTestJob(multiStmt, resultHandler, c);\n+        sqlJob.run();\n+    }\n+\n+    private static boolean handleVariableInMultiStmt(SQLAssignItem assignItem, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String key = handleSetKey(assignItem, c);\n+        if (key == null) {\n+            return false;\n+        }\n+        SQLExpr valueExpr = assignItem.getValue();\n+        if (!checkValue(valueExpr)) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + assignItem.getValue() + \"'\");\n+            return false;\n+        }\n+        KeyType keyType = parseKeyType(key, true, KeyType.SYSTEM_VARIABLES);\n+        switch (keyType) {\n+            case XA:\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd can't used in multi-set statement\");\n+                return false;\n+            case AUTOCOMMIT:\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set autocommit cmd can't used in multi-set statement\");\n+                return false;\n+            case NAMES: {\n+                String charset = parseStringValue(valueExpr);\n+                //TODO:druid lost collation info\n+                if (!handleSetNamesInMultiStmt(c, charset, null, contextTask)) return false;\n                 break;\n             }\n-            case TX_READ_COMMITTED: {\n-                c.setTxIsolation(Isolations.READ_COMMITTED);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARSET: {\n+                String charset = parseStringValue(valueExpr);\n+                if (!handleCharsetInMultiStmt(c, charset, contextTask)) return false;\n                 break;\n             }\n-            case TX_REPEATED_READ: {\n-                c.setTxIsolation(Isolations.REPEATED_READ);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARACTER_SET_CLIENT:\n+                if (!handleCharsetClientInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            }\n-            case TX_SERIALIZABLE: {\n-                c.setTxIsolation(Isolations.SERIALIZABLE);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARACTER_SET_CONNECTION:\n+                if (!handleCharsetConnInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            }\n-            case TX_READ_WRITE:\n-                c.setSessionReadOnly(false);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            case CHARACTER_SET_RESULTS:\n+                if (!handleCharsetResultsInMultiStmt(c, contextTask, valueExpr)) return false;\n+                break;\n+            case COLLATION_CONNECTION:\n+                if (!handleCollationConnInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n             case TX_READ_ONLY:\n-                c.setSessionReadOnly(true);\n-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+                if (!handleReadOnlyInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            case NAMES: {\n-                String names = stmt.substring(rs >>> 8).trim();\n-                if (handleSetNames(names, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set\" + names + \"\");\n-                }\n+            case TX_ISOLATION:\n+                if (!handleTxIsolationInMultiStmt(c, contextTask, valueExpr)) return false;\n                 break;\n-            }\n-            case CHARACTER_SET_CLIENT:\n-                String charsetClient = stmt.substring(rs >>> 8).trim().toLowerCase();\n-                if (charsetClient.equals(\"null\")) {\n-                    c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n-                }\n-                if (handleCharSetClient(charsetClient, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charsetClient + \"\");\n+            case SYSTEM_VARIABLES:\n+                if (SystemVariables.getDefaultValue(key) == null) {\n+                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"system variable \" + key + \" is not supported\");\n                 }\n+                contextTask.add(new Pair<>(KeyType.SYSTEM_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n                 break;\n-            case CHARACTER_SET_CONNECTION:\n-                String charsetConnection = stmt.substring(rs >>> 8).trim().toLowerCase();\n-                if (charsetConnection.equals(\"null\")) {\n-                    c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_connection' can't be set to the value of 'NULL'\");\n-                }\n-                if (handleCharSetConnection(charsetConnection, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charsetConnection + \"\");\n-                }\n+            case USER_VARIABLES:\n+                contextTask.add(new Pair<>(KeyType.USER_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n                 break;\n+            default:\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, key + \" is not supported\");\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleCharsetInMultiStmt(ServerConnection c, String charset, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String charsetInfo = getCharset(charset);\n+        if (charsetInfo != null) {\n+            contextTask.add(new Pair<>(KeyType.CHARSET, new Pair<String, String>(charsetInfo, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charset + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleTxIsolationInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String value = parseStringValue(valueExpr);\n+        Integer txIsolation = getIsolationLevel(value);\n+        if (txIsolation == null) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"Variable 'tx_isolation' can't be set to the value of '\" + value + \"'\");\n+            return false;\n+        }\n+        contextTask.add(new Pair<>(KeyType.TX_ISOLATION, new Pair<String, String>(String.valueOf(txIsolation), null)));\n+        return true;\n+    }\n+\n+    private static boolean handleReadOnlyInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'tx_read_only|transaction_read_only'\");\n+            return false;\n+        } else if (switchStatus) {\n+            contextTask.add(new Pair<>(KeyType.TX_READ_ONLY, new Pair<String, String>(\"true\", null)));\n+        } else {\n+            contextTask.add(new Pair<>(KeyType.TX_READ_ONLY, new Pair<String, String>(\"false\", null)));\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleCollationConnInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String collation = parseStringValue(valueExpr);\n+        if (checkCollation(collation)) {\n+            contextTask.add(new Pair<>(KeyType.COLLATION_CONNECTION, new Pair<String, String>(collation, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, \"Unknown collation '\" + collation + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleCharsetResultsInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String charsetResult = parseStringValue(valueExpr);\n+        if (charsetResult.equals(\"null\") || checkCharset(charsetResult)) {\n+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_RESULTS, new Pair<String, String>(charsetResult, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetResult + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleCharsetConnInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String charsetConnection = parseStringValue(valueExpr);\n+        if (charsetConnection.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_connection' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        String collationName = CharsetUtil.getDefaultCollation(charsetConnection);\n+        if (collationName != null) {\n+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_CONNECTION, new Pair<String, String>(collationName, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetConnection + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleCharsetClientInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {\n+        String charsetClient = parseStringValue(valueExpr);\n+        if (charsetClient.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        if (checkCharset(charsetClient)) {\n+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_CLIENT, new Pair<String, String>(charsetClient, null)));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetClient + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleVariable(String stmt, SQLAssignItem assignItem, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {\n+        String key = handleSetKey(assignItem, c);\n+        if (key == null) return false;\n+        SQLExpr valueExpr = assignItem.getValue();\n+        if (!checkValue(valueExpr)) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + assignItem.getValue() + \"'\");\n+            return false;\n+        }\n+        KeyType keyType = parseKeyType(key, true, KeyType.SYSTEM_VARIABLES);\n+        switch (keyType) {\n+            case XA:\n+                return handleSingleXA(c, valueExpr);\n+            case AUTOCOMMIT:\n+                return handleSingleAutocommit(stmt, c, valueExpr);\n+            case CHARACTER_SET_CLIENT:\n+                return handleSingleCharsetClient(c, valueExpr);\n+            case CHARACTER_SET_CONNECTION:\n+                return handleSingleCharsetConnection(c, valueExpr);\n             case CHARACTER_SET_RESULTS:\n-                String charsetResult = stmt.substring(rs >>> 8).trim();\n-                if (handleCharSetResults(charsetResult, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charsetResult + \"\");\n-                }\n-                break;\n-            case CHARACTER_SET_NAME: {\n-                String charset = stmt.substring(rs >>> 8).trim();\n-                if (handleCharSetName(charset, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charset + \"\");\n+                return handleSingleCharsetResults(c, valueExpr);\n+            case COLLATION_CONNECTION:\n+                return handleCollationConnection(c, valueExpr);\n+            case TX_READ_ONLY:\n+                return handleTxReadOnly(c, valueExpr);\n+            case TX_ISOLATION:\n+                return handleTxIsolation(c, valueExpr);\n+            case SYSTEM_VARIABLES:\n+                if (SystemVariables.getDefaultValue(key) == null) {\n+                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"system variable \" + key + \" is not supported\");\n+                    return false;\n                 }\n-                break;\n+                contextTask.add(new Pair<>(KeyType.SYSTEM_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n+                return true;\n+            case USER_VARIABLES:\n+                contextTask.add(new Pair<>(KeyType.USER_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));\n+                return true;\n+            default:\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, stmt + \" is not supported\");\n+                return false;\n+        }\n+    }\n+\n+    private static boolean handleTxReadOnly(ServerConnection c, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'tx_read_only|transaction_read_only'\");\n+            return false;\n+        } else if (switchStatus) {\n+            c.setSessionReadOnly(true);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        } else {\n+            c.setSessionReadOnly(false);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleTxIsolation(ServerConnection c, SQLExpr valueExpr) {\n+        String value = parseStringValue(valueExpr);\n+        Integer txIsolation = getIsolationLevel(value);\n+        if (txIsolation == null) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"Variable 'tx_isolation' can't be set to the value of '\" + value + \"'\");\n+            return false;\n+        }\n+        c.setTxIsolation(txIsolation);\n+        c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+        return true;\n+    }\n+\n+    private static Integer getIsolationLevel(String value) {\n+        switch (value) {\n+            case \"read-uncommitted\":\n+                return Isolations.READ_UNCOMMITTED;\n+            case \"read-committed\":\n+                return Isolations.READ_COMMITTED;\n+            case \"repeatable-read\":\n+                return Isolations.REPEATED_READ;\n+            case \"serializable\":\n+                return Isolations.SERIALIZABLE;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    private static boolean handleCollationConnection(ServerConnection c, SQLExpr valueExpr) {\n+        String collation = parseStringValue(valueExpr);\n+        if (checkCollation(collation)) {\n+            c.setCollationConnection(collation);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, \"Unknown collation '\" + collation + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleCharsetResults(ServerConnection c, SQLExpr valueExpr) {\n+        String charsetResult = parseStringValue(valueExpr);\n+        if (charsetResult.equals(\"null\") || checkCharset(charsetResult)) {\n+            c.setCharacterResults(charsetResult);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetResult + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleCharsetConnection(ServerConnection c, SQLExpr valueExpr) {\n+        String charsetConnection = parseStringValue(valueExpr);\n+        if (charsetConnection.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_connection' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        String collationName = CharsetUtil.getDefaultCollation(charsetConnection);\n+        if (collationName != null) {\n+            c.setCharacterConnection(collationName);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetConnection + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleCharsetClient(ServerConnection c, SQLExpr valueExpr) {\n+        String charsetClient = parseStringValue(valueExpr);\n+        if (charsetClient.equals(\"null\")) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, \"Variable 'character_set_client' can't be set to the value of 'NULL'\");\n+            return false;\n+        }\n+        if (checkCharset(charsetClient)) {\n+            c.setCharacterClient(charsetClient);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set '\" + charsetClient + \"'\");\n+            return false;\n+        }\n+    }\n+\n+    private static boolean handleSingleAutocommit(String stmt, ServerConnection c, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'AUTOCOMMIT'\");\n+            return false;\n+        } else if (switchStatus) {\n+            if (c.isAutocommit()) {\n+                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            } else {\n+                c.commit(\"commit[because of \" + stmt + \"]\");\n+                c.setAutocommit(true);\n+            }\n+        } else {\n+            if (c.isAutocommit()) {\n+                c.setAutocommit(false);\n+                TxnLogHelper.putTxnLog(c, stmt);\n             }\n-            case COLLATION_CONNECTION: {\n-                String collation = stmt.substring(rs >>> 8).trim();\n-                if (handleCollationConn(collation, c)) {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n-                } else {\n-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, \"Unknown collation \" + collation + \"\");\n-                }\n-                break;\n+            c.write(c.writeToBuffer(AC_OFF, c.allocate()));\n+        }\n+        return true;\n+    }\n+\n+    private static boolean handleSingleXA(ServerConnection c, SQLExpr valueExpr) {\n+        Boolean switchStatus = isSwitchOn(valueExpr);\n+        if (switchStatus == null) {\n+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, \"Incorrect argument type to variable 'XA'\");\n+            return false;\n+        } else if (switchStatus) {\n+            if (c.isTxstart() && c.getSession2().getSessionXaID() == null) {\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd on can't used before ending a transaction\");\n+                return false;\n+            }\n+            c.getSession2().setXaTxEnabled(true);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            if (c.isTxstart() && c.getSession2().getSessionXaID() != null) {\n+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, \"set xa cmd off can't used before ending a transaction\");\n+                return false;\n+            }\n+            c.getSession2().setXaTxEnabled(false);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        }\n+    }\n+\n+    // druid not support 'set charset' ,change to 'set character set'\n+    private static String convertCharsetKeyWord(String stmt) {\n+        StringBuilder result = new StringBuilder();\n+        String toCheck = stmt.toLowerCase();\n+        int index = toCheck.indexOf(\"charset\");\n+        int tailStart = 0;\n+        while (index > 0) {\n+            char before = toCheck.charAt(index - 1);\n+            char after = toCheck.charAt(index + 7);\n+            if ((ParseUtil.isSpace(before) || ',' == before) && ParseUtil.isSpace(after)) {\n+                result.append(stmt.substring(tailStart, index));\n+                result.append(\"character set\");\n+            }\n+            tailStart = index + 7;\n+            index = toCheck.indexOf(\"charset\", tailStart);\n+        }\n+        if (result.length() > 0) {\n+            result.append(stmt.substring(tailStart));\n+            return result.toString();\n+        }\n+        return stmt;\n+    }\n+\n+    private static String handleSetKey(SQLAssignItem assignItem, ServerConnection c) {\n+        if (assignItem.getTarget() instanceof SQLPropertyExpr) {\n+            SQLPropertyExpr target = (SQLPropertyExpr) assignItem.getTarget();\n+            if (!(target.getOwner() instanceof SQLVariantRefExpr)) {\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + target + \"'\");\n+                return null;\n             }\n-            case GLOBAL:\n+            SQLVariantRefExpr owner = (SQLVariantRefExpr) target.getOwner();\n+            if (owner.isGlobal()) {\n                 c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n-                break;\n+                return null;\n+            }\n+            return target.getName();\n+        } else if (assignItem.getTarget() instanceof SQLVariantRefExpr) {\n+            SQLVariantRefExpr target = (SQLVariantRefExpr) assignItem.getTarget();\n+            if (target.isGlobal()) {\n+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n+                return null;\n+            }\n+            return target.getName();\n+        } else if (assignItem.getTarget() instanceof SQLIdentifierExpr) {\n+            SQLIdentifierExpr target = (SQLIdentifierExpr) assignItem.getTarget();\n+            return target.getLowerName();\n+        } else {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting target is not supported for '\" + assignItem.getTarget() + \"'\");\n+            return null;\n+        }\n+    }\n+\n+    private static boolean checkValue(SQLExpr valueExpr) {\n+        return (valueExpr instanceof SQLCharExpr) || (valueExpr instanceof SQLIdentifierExpr) ||\n+                (valueExpr instanceof SQLIntegerExpr);\n+    }\n+\n+    private static KeyType parseKeyType(String key, boolean origin, KeyType defaultVariables) {\n+        switch (key.toLowerCase()) {\n+            case \"xa\":\n+                return KeyType.XA;\n+            case \"autocommit\":\n+                return KeyType.AUTOCOMMIT;\n+            case \"collation_connection\":\n+                return KeyType.COLLATION_CONNECTION;\n+            case \"character_set_client\":\n+                return KeyType.CHARACTER_SET_CLIENT;\n+            case \"character_set_results\":\n+                return KeyType.CHARACTER_SET_RESULTS;\n+            case \"character_set_connection\":\n+                return KeyType.CHARACTER_SET_CONNECTION;\n+            case \"transaction_isolation\":\n+            case \"tx_isolation\":\n+                return KeyType.TX_ISOLATION;\n+            case \"transaction_read_only\":\n+            case \"tx_read_only\":\n+                return KeyType.TX_READ_ONLY;\n+            case \"names\":\n+                return KeyType.NAMES;\n+            case \"character set\":\n+                return KeyType.CHARSET;\n             default:\n-                boolean ignore = SetIgnoreUtil.isIgnoreStmt(stmt);\n-                if (!ignore) {\n-                    StringBuilder s = new StringBuilder();\n-                    String warn = stmt + \" is not recognized and ignored\";\n-                    LOGGER.warn(s.append(c).append(warn).toString());\n-                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, warn);\n+                if (!origin && key.startsWith(\"@\")) {\n+                    return KeyType.SYNTAX_ERROR;\n+                } else if (key.startsWith(\"@@\")) {\n+                    return parseKeyType(key.substring(2), false, KeyType.SYSTEM_VARIABLES);\n+                } else if (key.startsWith(\"@\")) {\n+                    return parseKeyType(key.substring(1), false, KeyType.USER_VARIABLES);\n                 } else {\n-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+                    return defaultVariables;\n                 }\n         }\n     }\n \n-    //TODO:\n-    private static boolean parserMultiSet(String setSQL, ServerConnection c) {\n-        String[] setStatements = setSQL.split(\",\");\n-        for (String statement : setStatements) {\n-            boolean setError = false;\n-            int rs = ServerParseSet.parse(statement, 0);\n-            switch (rs & 0xff) {\n-                case AUTOCOMMIT_ON:\n+    private static Boolean isSwitchOn(SQLExpr valueExpr) {\n+        if (valueExpr instanceof SQLIntegerExpr) {\n+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n+            int iValue = value.getNumber().intValue();\n+            if (iValue < 0 || iValue > 1) {\n+                return null;\n+            }\n+            return (iValue == 1);\n+        }\n+        String strValue = parseStringValue(valueExpr);\n+        switch (strValue) {\n+            case \"on\":\n+                return true;\n+            case \"off\":\n+                return false;\n+            default:\n+                return null;\n+        }\n+    }\n \n-                    break;\n-                case AUTOCOMMIT_OFF: {\n-                    break;\n-                }\n-                case XA_FLAG_ON: {\n+    private static String parseVariablesValue(SQLExpr valueExpr) {\n+        String strValue = \"\";\n+        if (valueExpr instanceof SQLIdentifierExpr) {\n+            SQLIdentifierExpr value = (SQLIdentifierExpr) valueExpr;\n+            strValue = \"'\" + StringUtil.removeBackQuote(value.getSimpleName().toLowerCase()) + \"'\";\n+        } else if (valueExpr instanceof SQLCharExpr) {\n+            SQLCharExpr value = (SQLCharExpr) valueExpr;\n+            strValue = \"'\" + value.getText().toLowerCase() + \"'\";\n+        } else if (valueExpr instanceof SQLIntegerExpr) {\n+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n+            strValue = value.getNumber().toString();\n+        }\n+        return strValue;\n+    }\n \n-                    break;\n-                }\n-                case XA_FLAG_OFF: {\n+    private static String parseStringValue(SQLExpr valueExpr) {\n+        String strValue = \"\";\n+        if (valueExpr instanceof SQLIdentifierExpr) {\n+            SQLIdentifierExpr value = (SQLIdentifierExpr) valueExpr;\n+            strValue = StringUtil.removeBackQuote(value.getSimpleName().toLowerCase());\n+        } else if (valueExpr instanceof SQLCharExpr) {\n+            SQLCharExpr value = (SQLCharExpr) valueExpr;\n+            strValue = value.getText().toLowerCase();\n+        } else if (valueExpr instanceof SQLIntegerExpr) {\n+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;\n+            strValue = value.getNumber().toString();\n+        }\n+        return strValue;\n+    }\n \n+\n+    private static boolean handleTransaction(ServerConnection c, MySqlSetTransactionStatement setStatement) {\n+        //always single\n+        if (setStatement.getGlobal() == null) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting transaction without any SESSION or GLOBAL keyword is not supported now\");\n+            return false;\n+        } else if (setStatement.getGlobal()) {\n+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n+            return false;\n+        } else if (setStatement.getAccessModel() != null) {\n+            if (setStatement.getAccessModel().equals(\"ONLY\")) {\n+                c.setSessionReadOnly(true);\n+            } else {\n+                c.setSessionReadOnly(false);\n+            }\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n+        } else {\n+            int txIsolation = Isolations.REPEATED_READ;\n+            switch (setStatement.getIsolationLevel()) {\n+                case \"READ UNCOMMITTED\":\n+                    txIsolation = Isolations.READ_UNCOMMITTED;\n                     break;\n-                }\n-                case NAMES: {\n-                    String names = statement.substring(rs >>> 8).trim();\n-                    if (!handleSetNames(names, c)) {\n-                        setError = true;\n-                        c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + names + \"\");\n-                    }\n-                    break;\n-                }\n-                case CHARACTER_SET_CLIENT:\n-                case CHARACTER_SET_CONNECTION:\n-                case CHARACTER_SET_RESULTS:\n-                    //TODO:\n-                    break;\n-                case CHARACTER_SET_NAME: {\n-                    String charset = statement.substring(rs >>> 8).trim();\n-                    if (!handleCharSetName(charset, c)) {\n-                        setError = true;\n-                        c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown character set \" + charset + \"\");\n-                    }\n+                case \"READ COMMITTED\":\n+                    txIsolation = Isolations.READ_COMMITTED;\n                     break;\n-                }\n-                case GLOBAL:\n-                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, \"setting GLOBAL value is not supported\");\n+                case \"REPEATABLE READ\":\n+                    txIsolation = Isolations.REPEATED_READ;\n                     break;\n-                case TX_READ_UNCOMMITTED:\n-                case TX_READ_COMMITTED:\n-                case TX_REPEATED_READ:\n-                case TX_SERIALIZABLE: {\n+                case \"SERIALIZABLE\":\n+                    txIsolation = Isolations.SERIALIZABLE;\n                     break;\n-                }\n                 default:\n-                    //TODO\n-            }\n-            if (setError) {\n-                return true;\n+                    // can't be happened\n+                    break;\n             }\n+            c.setTxIsolation(txIsolation);\n+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));\n+            return true;\n         }\n-        return false;\n-    }\n-    private static boolean handleCollationConn(String collation, ServerConnection c) {\n-        collation = StringUtil.removeApostropheOrBackQuote(collation);\n-        return c.setCollationConnection(collation);\n-    }\n-    private static boolean handleCharSetConnection(String charset, ServerConnection c) {\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterConnection(charset);\n     }\n-    private static boolean handleCharSetResults(String charset, ServerConnection c) {\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterResults(charset);\n+\n+    private static boolean checkCollation(String collation) {\n+        int ci = CharsetUtil.getCollationIndex(collation);\n+        return ci > 0;\n     }\n-    private static boolean handleCharSetClient(String charset, ServerConnection c) {\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterClient(charset);\n+\n+    private static boolean checkCharset(String name) {\n+        int ci = CharsetUtil.getCharsetDefaultIndex(name);\n+        return ci > 0;\n     }\n-    private static boolean handleCharSetName(String charset, ServerConnection c) {\n+\n+    private static String getCharset(String charset) {\n         charset = charset.toLowerCase();\n         if (charset.equals(\"default\")) {\n             charset = DbleServer.getInstance().getConfig().getSystem().getCharset();\n         }\n         charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setCharacterSet(charset);\n+        if (checkCharset(charset)) {\n+            return charset;\n+        }\n+        return null;\n     }\n \n-    private static boolean handleSetNames(String names, ServerConnection c) {\n-        String charset = names.toLowerCase();\n-        int collateIndex = charset.indexOf(\"collate\");\n-        String collate = null;\n-        if (collateIndex > 0) {\n-            charset = names.substring(0, collateIndex).trim();\n-            collate = names.substring(collateIndex + 7).trim();\n-            if (collate.toLowerCase().equals(\"default\")) {\n-                String defaultCharset = DbleServer.getInstance().getConfig().getSystem().getCharset();\n-                collate = CharsetUtil.getDefaultCollation(defaultCharset);\n-            }\n-        }\n+    private static String[] checkSetNames(String charset, String collate) {\n+        charset = charset.toLowerCase();\n         if (charset.equals(\"default\")) {\n             charset = DbleServer.getInstance().getConfig().getSystem().getCharset();\n+        } else {\n+            charset = StringUtil.removeApostropheOrBackQuote(charset);\n+            if (!checkCharset(charset)) {\n+                return null;\n+            }\n         }\n-        charset = StringUtil.removeApostropheOrBackQuote(charset);\n-        return c.setNames(charset, collate);\n-\n+        if (collate == null) {\n+            collate = CharsetUtil.getDefaultCollation(charset);\n+        } else {\n+            collate = collate.toLowerCase();\n+            if (collate.equals(\"default\")) {\n+                collate = CharsetUtil.getDefaultCollation(charset);\n+            } else if (CharsetUtil.getCollationIndex(collate) <= 0) {\n+                return null;\n+            }\n+        }\n+        return new String[]{charset, collate};\n     }\n }\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/parser: ServerParseSet.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/ServerConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/ServerConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/ServerConnection.java\t2024-09-08 01:36:10.413782673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/ServerConnection.java\t2024-09-08 01:36:10.345782197 +1000\n@@ -16,7 +16,9 @@\n import com.actiontech.dble.log.transaction.TxnLogHelper;\n import com.actiontech.dble.net.FrontendConnection;\n import com.actiontech.dble.route.RouteResultset;\n+import com.actiontech.dble.route.parser.util.Pair;\n import com.actiontech.dble.route.util.RouterUtil;\n+import com.actiontech.dble.server.handler.SetHandler;\n import com.actiontech.dble.server.parser.ServerParse;\n import com.actiontech.dble.server.response.Heartbeat;\n import com.actiontech.dble.server.response.Ping;\n@@ -31,6 +33,9 @@\n import java.nio.channels.NetworkChannel;\n import java.sql.SQLException;\n import java.sql.SQLNonTransientException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.LockSupport;\n@@ -53,11 +58,12 @@\n     private NonBlockingSession session;\n     private volatile boolean isLocked = false;\n     private AtomicLong txID;\n-\n+    private List<Pair<SetHandler.KeyType, Pair<String, String>>> contextTask = new ArrayList<>();\n     public long getAndIncrementXid() {\n         return txID.getAndIncrement();\n     }\n \n+\n     public long getXid() {\n         return txID.get();\n     }\n@@ -68,6 +74,8 @@\n         this.txInterrupted = false;\n         this.autocommit = true;\n         this.txID = new AtomicLong(1);\n+        this.usrVariables = new LinkedHashMap<>();\n+        this.sysVariables = new LinkedHashMap<>();\n     }\n \n     public ServerConnection() {\n@@ -131,7 +139,7 @@\n         return session;\n     }\n \n-    public void setSession2(NonBlockingSession session2) {\n+    void setSession2(NonBlockingSession session2) {\n         this.session = session2;\n     }\n \n@@ -139,10 +147,64 @@\n         return isLocked;\n     }\n \n-    public void setLocked(boolean locked) {\n+    void setLocked(boolean locked) {\n         this.isLocked = locked;\n     }\n \n+\n+    public List<Pair<SetHandler.KeyType, Pair<String, String>>> getContextTask() {\n+        return contextTask;\n+    }\n+\n+    public void setContextTask(List<Pair<SetHandler.KeyType, Pair<String, String>>> contextTask) {\n+        this.contextTask = contextTask;\n+    }\n+\n+    public void executeTask() {\n+        for (Pair<SetHandler.KeyType, Pair<String, String>> task : contextTask) {\n+            switch (task.getKey()) {\n+                case CHARACTER_SET_CLIENT:\n+                    String charsetClient = task.getValue().getKey();\n+                    this.setCharacterClient(charsetClient);\n+                    break;\n+                case CHARACTER_SET_CONNECTION:\n+                    String collationName = task.getValue().getKey();\n+                    this.setCharacterConnection(collationName);\n+                    break;\n+                case CHARACTER_SET_RESULTS:\n+                    String charsetResult = task.getValue().getKey();\n+                    this.setCharacterResults(charsetResult);\n+                    break;\n+                case COLLATION_CONNECTION:\n+                    String collation = task.getValue().getKey();\n+                    this.setCollationConnection(collation);\n+                    break;\n+                case TX_ISOLATION:\n+                    String isolationLevel = task.getValue().getKey();\n+                    this.setTxIsolation(Integer.parseInt(isolationLevel));\n+                    break;\n+                case TX_READ_ONLY:\n+                    String enable = task.getValue().getKey();\n+                    this.setSessionReadOnly(Boolean.parseBoolean(enable));\n+                    break;\n+                case SYSTEM_VARIABLES:\n+                    this.sysVariables.put(task.getValue().getKey(), task.getValue().getValue());\n+                    break;\n+                case USER_VARIABLES:\n+                    this.usrVariables.put(task.getValue().getKey(), task.getValue().getValue());\n+                    break;\n+                case CHARSET:\n+                    this.setCharacterSet(task.getValue().getKey());\n+                    break;\n+                case NAMES:\n+                    this.setNames(task.getValue().getKey(), task.getValue().getValue());\n+                    break;\n+                default:\n+                    //can't happen\n+                    break;\n+            }\n+        }\n+    }\n     @Override\n     public void ping() {\n         Ping.response(this);\n@@ -319,10 +381,7 @@\n         session.rollback();\n     }\n \n-    /**\n-     * @param sql\n-     */\n-    public void lockTable(String sql) {\n+    void lockTable(String sql) {\n         // lock table is disable in transaction\n         if (!autocommit) {\n             writeErrMessage(ErrorCode.ER_YES, \"can't lock table in transaction!\");\n@@ -339,10 +398,7 @@\n         }\n     }\n \n-    /**\n-     * @param sql\n-     */\n-    public void unLockTable(String sql) {\n+    void unLockTable(String sql) {\n         sql = sql.replaceAll(\"\\n\", \" \").replaceAll(\"\\t\", \" \");\n         String[] words = SplitUtil.split(sql, ' ', true);\n         if (words.length == 2 && (\"table\".equalsIgnoreCase(words[1]) || \"tables\".equalsIgnoreCase(words[1]))) {\n@@ -395,9 +451,31 @@\n \n     @Override\n     public String toString() {\n-        return \"ServerConnection [id=\" + id + \", schema=\" + schema + \", host=\" + host +\n-                \", user=\" + user + \",txIsolation=\" + txIsolation + \", autocommit=\" + autocommit +\n-                \", schema=\" + schema + \"]\";\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"ServerConnection [id=\");\n+        result.append(id);\n+        result.append(\", schema=\");\n+        result.append(schema);\n+        result.append(\", host=\");\n+        result.append(host);\n+        result.append(\", user=\");\n+        result.append(user);\n+        result.append(\",txIsolation=\");\n+        result.append(txIsolation);\n+        result.append(\", autocommit=\");\n+        result.append(autocommit);\n+        result.append(\", schema=\");\n+        result.append(schema);\n+        if (sysVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfSysVariables());\n+        }\n+        if (usrVariables.size() > 0) {\n+            result.append(\", \");\n+            result.append(getStringOfUsrVariables());\n+        }\n+        result.append(\"]\");\n+        return result.toString();\n     }\n \n }\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine: SetTestJob.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java\t2024-09-08 01:36:10.417782701 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java\t2024-09-08 01:36:10.349782225 +1000\n@@ -36,14 +36,12 @@\n     private BackendConnection connection;\n     private final SQLJobHandler jobHandler;\n     private final PhysicalDatasource ds;\n-    private final int id;\n     private volatile boolean finished;\n \n \n     public SQLJob(String sql, String databaseName, SQLJobHandler jobHandler,\n                   PhysicalDatasource ds) {\n         super();\n-        this.id = 0;\n         this.sql = sql;\n         this.dataNodeOrDatabase = databaseName;\n         this.jobHandler = jobHandler;\n@@ -132,7 +130,7 @@\n \n     @Override\n     public void okResponse(byte[] ok, BackendConnection conn) {\n-        if (conn.syncAndExcute()) {\n+        if (conn.syncAndExecute()) {\n             conn.release();\n             doFinished(false);\n         }\n@@ -170,14 +168,9 @@\n     public void connectionClose(BackendConnection conn, String reason) {\n         doFinished(true);\n     }\n-\n-    public int getId() {\n-        return id;\n-    }\n-\n     @Override\n     public String toString() {\n-        return \"SQLJob [ id=\" + id + \",dataNodeOrDatabase=\" +\n+        return \"SQLJob [dataNodeOrDatabase=\" +\n                 dataNodeOrDatabase + \",sql=\" + sql + \",  jobHandler=\" +\n                 jobHandler + \"]\";\n     }\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/util: SetIgnoreUtil.java",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-21",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.druid.bvt.filter.wall.mysql.MySqlWallTest148",
                "error": "java.lang.AssertionError",
                "message": "",
                "methodName": "test_false"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-21",
        "project": "RegressionBug-21",
        "repairOperators": [
            "mcRepl",
            "assignExpChange"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java\n@@ -1975,7 +1975,7 @@\n \n                     for (;;) {\n                         lexer.nextToken();\n-                        SQLExpr more = relational();\n+                        SQLExpr more = and();\n                         group.add(more);\n                         if (lexer.token == Token.OR) {\n                             if (lexer.isKeepComments() && lexer.hasComment()) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/ast/expr/SQLPropertyExpr.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/ast/expr/SQLPropertyExpr.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/ast/expr/SQLPropertyExpr.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/ast/expr/SQLPropertyExpr.java\n@@ -23,12 +23,15 @@\n public class SQLPropertyExpr extends SQLExprImpl implements SQLName {\n \n     private SQLExpr owner;\n     private String  name;\n \n+    protected long name_hash_lower;\n\n     private transient SQLColumnDefinition resolvedColumn;\n     private transient SQLTableSource resolvedTableSource;\n \n@@ -41,6 +44,12 @@\n         this.name = name;\n     }\n \n+    public SQLPropertyExpr(SQLExpr owner, String name, long name_hash_lower){\n+        setOwner(owner);\n+        this.name = name;\n+        this.name_hash_lower = name_hash_lower;\n+    }\n+\n     public SQLPropertyExpr(){\n \n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/ast/statement/SQLTableSourceImpl.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/ast/statement/SQLTableSourceImpl.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/ast/statement/SQLTableSourceImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/ast/statement/SQLTableSourceImpl.java\n@@ -31,12 +32,13 @@ \n \n     protected SQLExpr       flashback;\n \n+    protected long          alias_hash;\n\n     public SQLTableSourceImpl(){\n \n     }\n \n@@ -46,6 +48,7 @@\n \n     public void setAlias(String alias) {\n         this.alias = alias;\n+        this.alias_hash = 0L;\n     }\n \n     public int getHintsSize() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java\n@@ -1005,9 +1005,14 @@\n             expr = new SQLPropertyExpr(expr, \"*\");\n         } else {\n             String name;\n+            long hash_lower = 0L;\n \n-            if (lexer.token == Token.IDENTIFIER || lexer.token == Token.LITERAL_CHARS || lexer.token == Token.LITERAL_ALIAS) {\n+            if (lexer.token == Token.IDENTIFIER) {\n+                name = lexer.stringVal();\n+                hash_lower = lexer.hash_lower;\n+                lexer.nextToken();\n             } else if (lexer.token == Token.LITERAL_CHARS || lexer.token == Token.LITERAL_ALIAS) {\n                 name = lexer.stringVal();\n                 lexer.nextToken();\n             } else if (lexer.getKeywods().containsValue(lexer.token)) {\n@@ -1055,7 +1060,7 @@\n                     expr = methodInvokeExpr;\n                 }\n             } else {\n-                expr = new SQLPropertyExpr(expr, name);\n+                expr = new SQLPropertyExpr(expr, name, hash_lower);\n             }\n         }\n \n@@ -1642,7 +1647,7 @@\n                 if (lexer.token == Token.AND\n                         && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n \n-                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanAnd);\n+                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanAnd, dbType);\n                     group.add(expr);\n                     group.add(rightExp);\n \n@@ -1697,25 +1702,31 @@\n                 if (lexer.token == Token.OR\n                         && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n \n-                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr);\n+                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr, dbType);\n                     group.add(expr);\n                     group.add(rightExp);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/util/FNVUtils.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/util/FNVUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/util/FNVUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/util/FNVUtils.java\n@@ -80,6 +80,7 @@\n     public final static long MATCH = fnv_64_lower(\"MATCH\");\n     public final static long EXTRACT = fnv_64_lower(\"EXTRACT\");\n     public final static long POSITION = fnv_64_lower(\"POSITION\");\n+    public final static long DUAL = fnv_64_lower(\"DUAL\");\n \n     public static long fnv_64(String input) {\n         if (input == null) {\n@@ -102,6 +103,46 @@\n             char ch = key.charAt(i);\n \n             if (ch >= 'A' && ch <= 'Z') {\n+                ch = (char) (ch + 32);\n+            }\n\n+            hashCode ^= ch;\n+            hashCode *= 0x100000001b3L;\n+        }\n\n+        return hashCode;\n+    }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/wall/spi/MySqlWallProvider.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/wall/spi/MySqlWallProvider.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/wall/spi/MySqlWallProvider.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/wall/spi/MySqlWallProvider.java\n@@ -38,7 +39,7 @@\n \n     @Override\n     public SQLStatementParser createParser(String sql) {\n-        return new MySqlStatementParser(sql);\n+        return new MySqlStatementParser(sql, SQLParserFeature.EnableSQLBinaryOpExprGroup);\n     }\n \n     @Override",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-22",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.druid.bvt.sql.UnsignedBigIntTest",
                "error": "junit.framework.ComparisonFailure",
                "message": "expected:<...ERE c <> 1 LIMIT 0, [18446744073709551615]> but was:<...ERE c <> 1 LIMIT 0, [-1]>",
                "methodName": "test_mysqlUnsignedBitInt"
            },
            {
                "className": "com.alibaba.druid.bvt.sql.UnsignedBigIntTest",
                "error": "junit.framework.ComparisonFailure",
                "message": "expected:<... WHERE c <> 1 LIMIT [18446744073709551615] OFFSET 1> but was:<... WHERE c <> 1 LIMIT [-1] OFFSET 1>",
                "methodName": "test_postgresqlUnsignedBitInt"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-22",
        "project": "RegressionBug-22",
        "repairOperators": [
            "varTyChange",
            "mcRepl",
            "condExpMod"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java\n@@ -1327,9 +1327,9 @@\n     }\n \n     protected void printInteger(SQLIntegerExpr x, boolean parameterized) {\n-        long val = x.getNumber().longValue();\n+        String val = x.getNumber().toString();\n \n-        if (val == 1) {\n+        if (\"1\".equals(val)) {\n             if (JdbcConstants.ORACLE.equals(dbType)) {\n                 SQLObject parent = x.getParent();\n                 if (parent instanceof SQLBinaryOpExpr) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java\n@@ -53,7 +53,7 @@\n \n     protected final Appendable appender;\n     private String indent = \"\\t\";\n-    private int indentCount = 0;\n+    protected int indentCount = 0;\n     private boolean prettyFormat = true;\n     protected boolean ucase = true;\n     protected int selectListNumberOfLine = 5;\n@@ -166,11 +166,11 @@\n     }\n \n     public void decrementIndent() {\n-        this.indentCount -= 1;\n+        this.indentCount--;\n     }\n \n     public void incrementIndent() {\n-        this.indentCount += 1;\n+        this.indentCount++;\n     }\n \n     public boolean isParameterized() {\n@@ -214,9 +214,30 @@\n         }\n     }\n \n+    public void print(long value) {\n+        if (this.appender == null) {\n+            return;\n+        }\n+        if (appender instanceof StringBuilder) {\n+            ((StringBuilder) appender).append(value);\n+        } else if (appender instanceof StringBuffer) {\n+            ((StringBuffer) appender).append(value);\n+        } else {\n+            print0(Long.toString(value));\n+        }\n     }\n \n     public void print(Date date) {\n         if (this.appender == null) {\n@@ -957,7 +975,7 @@\n     }\n \n     public boolean visit(SQLIntegerExpr x) {\n-        int val = x.getNumber().intValue();\n+        long val = x.getNumber().longValue();\n         SQLObject parent = x.getParent();\n \n         if (val == 1) {\n@@ -992,7 +1011,8 @@\n             return false;\n         }\n \n-        return SQLASTOutputVisitorUtils.visit(this, x);\n+        print(val);\n+        return false;\n     }\n \n     public boolean visit(SQLMethodInvokeExpr x) {\n@@ -1612,7 +1639,14 @@\n             }\n         }\n \n-        expr.accept(this);\n+        if (expr instanceof SQLIdentifierExpr) {\n+            visit((SQLIdentifierExpr) expr);\n+        } else if (expr instanceof SQLPropertyExpr) {\n+            visit((SQLPropertyExpr) expr);\n+        } else {\n+            expr.accept(this);\n+        }\n     }\n \n     public boolean visit(SQLExprTableSource x) {",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-23",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.stringtemplate.v4.test.TestModelAdaptors",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[1]> but was:<[]>",
                "methodName": "testHandlesKeysNotComparableToString"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 8,
            "linesMod": 4,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 12
        },
        "program": "RegressionBug-23",
        "project": "RegressionBug-23",
        "repairOperators": [
            "mcRem",
            "mcAdd",
            "mdAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/org/stringtemplate/v4/misc/MapModelAdaptor.java ./RegMiner4APR-Regression-Bugs/BFC/src/org/stringtemplate/v4/misc/MapModelAdaptor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/org/stringtemplate/v4/misc/MapModelAdaptor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/org/stringtemplate/v4/misc/MapModelAdaptor.java\n@@ -41,17 +41,39 @@public Object getProperty(Interpreter interp, ST self, Object o, Object property) {\n \t\tObject value;\n \t\tMap<?, ?> map = (Map<?, ?>)o;\n-\t\tif ( property==null ) value = map.get(STGroup.DEFAULT_KEY);\n+\t\tif ( property==null ) value = getDefaultValue(map);\n-\t\telse if ( map.containsKey(property) ) value = map.get(property);\n+\t\telse if ( containsKey(map, property) ) value = map.get(property);\n-\t\telse if ( map.containsKey(propertyName) ) { // if can't find the key, try toString version\n+\t\telse if ( containsKey(map, propertyName) ) { // if can't find the key, try toString version\n \t\t\tvalue = map.get(propertyName);\n \t\t}\n \t\telse if ( property.equals(\"keys\") ) value = map.keySet();\n \t\telse if ( property.equals(\"values\") ) value = map.values();\n-\t\telse value = map.get(STGroup.DEFAULT_KEY); // not found, use default\n+\t\telse value = getDefaultValue(map); // not found, use default\n \t\tif ( value == STGroup.DICT_KEY ) {\n \t\t\tvalue = property;\n \t\t}\n \t\treturn value;\n \t}\n\n+\tprivate static Boolean containsKey(Map<?, ?> map, Object key) {\n+\t\ttry {\n+\t\t\treturn map.containsKey(key);\n+\t\t}\n+\t\tcatch (ClassCastException ex) {\n+\t\t\treturn false;\n+\t\t}\n+\t}",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/org/stringtemplate/v4/misc/MapModelAdaptor.java ./RegMiner4APR-Regression-Bugs/BIC/src/org/stringtemplate/v4/misc/MapModelAdaptor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/org/stringtemplate/v4/misc/MapModelAdaptor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/org/stringtemplate/v4/misc/MapModelAdaptor.java\n@@ -42,12 +42,12 @@\n \t\tObject value;\n \t\tMap<?, ?> map = (Map<?, ?>)o;\n \t\tif ( property==null ) value = map.get(STGroup.DEFAULT_KEY);\n-\t\telse if ( property.equals(\"keys\") ) value = map.keySet();\n-\t\telse if ( property.equals(\"values\") ) value = map.values();\n \t\telse if ( map.containsKey(property) ) value = map.get(property);\n \t\telse if ( map.containsKey(propertyName) ) { // if can't find the key, try toString version\n \t\t\tvalue = map.get(propertyName);\n \t\t}\n+\t\telse if ( property.equals(\"keys\") ) value = map.keySet();\n+\t\telse if ( property.equals(\"values\") ) value = map.values();\n \t\telse value = map.get(STGroup.DEFAULT_KEY); // not found, use default\n \t\tif ( value == STGroup.DICT_KEY ) {\n \t\t\tvalue = property;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-24",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.cactoos.io.TeeInputStreamTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : <false>\n     but: was <true>",
                "methodName": "leftInputUnclosed"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-24",
        "project": "RegressionBug-24",
        "repairOperators": [
            "mcRepl"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/cactoos/io/TeeInputStream.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/cactoos/io/TeeInputStream.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/cactoos/io/TeeInputStream.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/cactoos/io/TeeInputStream.java\n@@ -96,7 +96,7 @@\n     @Override\n     public void close() throws IOException {\n         this.input.close();\n-        this.output.close();\n+        this.output.flush();\n     }\n \n     @Override",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/cactoos/io/WriterAsOutputStream.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/cactoos/io/WriterAsOutputStream.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/cactoos/io/WriterAsOutputStream.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/cactoos/io/WriterAsOutputStream.java\n@@ -171,6 +171,11 @@\n         }\n     }\n \n+    @Override\n+    public void close() throws IOException {\n+        this.writer.close();\n+    }\n\n     /**\n      * Write a portion from the buffer.\n      * @param buffer The buffer",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-25",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.cactoos.collection.CollectionEnvelopeTest",
                "error": "java.lang.NullPointerException",
                "message": "",
                "methodName": "notEqualToNull"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 0,
            "linesRem": 5,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-25",
        "project": "RegressionBug-25",
        "repairOperators": [
            "objInstRem",
            "mcRem",
            "condBranRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/cactoos/collection/CollectionEnvelope.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/cactoos/collection/CollectionEnvelope.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/cactoos/collection/CollectionEnvelope.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/cactoos/collection/CollectionEnvelope.java\n@@ -151,14 +150,10 @@\n     public final boolean equals(final Object other) {\n         return new UncheckedScalar<>(\n             new And(\n-                new Or(\n-                    () -> new InheritanceLevel(\n-                        other.getClass(), Collection.class\n-                    ).value() > -1,\n-                    () -> new InheritanceLevel(\n-                        other.getClass(), CollectionEnvelope.class\n-                    ).value() > -1\n-                ),\n+                () -> other != null,\n+                () -> new InheritanceLevel(\n+                    other.getClass(), CollectionEnvelope.class\n+                ).value() > -1,\n                () -> {\n                     final Collection<?> compared = (Collection<?>) other;\n                     return this.size() == compared.size();",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/cactoos/collection/CollectionEnvelope.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/cactoos/collection/CollectionEnvelope.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/cactoos/collection/CollectionEnvelope.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/cactoos/collection/CollectionEnvelope.java\n@@ -147,4 +151,48 @@\n+    @Override\n+    public final boolean equals(final Object other) {\n+        return new UncheckedScalar<>(\n+            new And(\n+                new Or(\n+                    () -> new InheritanceLevel(\n+                        other.getClass(), Collection.class\n+                    ).value() > -1,\n+                    () -> new InheritanceLevel(\n+                        other.getClass(), CollectionEnvelope.class\n+                    ).value() > -1\n+                ),\n+                () -> {\n+                    final Collection<?> compared = (Collection<?>) other;\n+                    return this.size() == compared.size();\n+                },\n+                () -> {\n+                    final Iterable<?> compared = (Iterable<?>) other;\n+                    final Iterator<?> iterator = compared.iterator();\n+                    return new UncheckedScalar<>(\n+                        new And(\n+                            (X input) -> input.equals(iterator.next()),\n+                            this\n+                        )\n+                    ).value();\n+                }\n+            )\n+        ).value();\n+    }\n\n",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-26",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.github.davidmoten.rtree.RTreeTest",
                "error": "java.lang.AssertionError",
                "message": "expected: com.github.davidmoten.rtree.geometry.internal.RectangleImpl<Rectangle [x1=1.0, y1=1.0, x2=2.0, y2=2.0]> but was: com.github.davidmoten.rtree.geometry.internal.RectangleDoubleImpl<Rectangle [x1=1.0, y1=1.0, x2=2.0, y2=2.0]>",
                "methodName": "testRTreeRootMbrWhenRTreeNonEmpty"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 9,
            "linesMod": 0,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 9
        },
        "program": "RegressionBug-26",
        "project": "RegressionBug-26",
        "repairOperators": [
            "assignAdd",
            "varAdd",
            "condBranIfAdd",
            "condBranIfElseAdd",
            "mcAdd",
            "retRem",
            "retBranchAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/internal/Util.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n@@ -46,8 +46,12 @@\n         double minY1 = Double.MAX_VALUE;\n         double maxX2 = -Double.MAX_VALUE;\n         double maxY2 = -Double.MAX_VALUE;\n+        boolean isDoublePrecision = false;\n         for (final HasGeometry item : items) {\n             Rectangle r = item.geometry().mbr();\n+            if (r.isDoublePrecision()) {\n+                isDoublePrecision = true;\n+            }\n             if (r.x1() < minX1)\n                 minX1 = r.x1();\n             if (r.y1() < minY1)\n@@ -57,7 +61,11 @@\n             if (r.y2() > maxY2)\n                 maxY2 = r.y2();\n         }\n-        return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n+        if (isDoublePrecision) {\n+            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n+        } else {\n+            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n+        }\n     }\n \n     public static <T> List<T> add(List<T> list, T element) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Point.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n@@ -89,27 +90,27 @@\n     }\n \n     @Override\n-    public float x1() {\n+    public double x1() {\n         return x;\n     }\n \n     @Override\n-    public float y1() {\n+    public double y1() {\n         return y;\n     }\n \n     @Override\n-    public float x2() {\n+    public double x2() {\n         return x;\n     }\n \n     @Override\n-    public float y2() {\n+    public double y2() {\n         return y;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n@@ -2,36 +2,24 @@\n \n public interface Rectangle extends Geometry, HasGeometry {\n \n-    float x1();\n+    double x1();\n \n-    float y1();\n+    double y1();\n \n-    float x2();\n+    double x2();\n \n-    float y2();\n+    double y2();\n \n-    float area();\n+    double area();\n \n-    float intersectionArea(Rectangle r);\n+    double intersectionArea(Rectangle r);\n \n-    float perimeter();\n+    double perimeter();\n \n     Rectangle add(Rectangle r);\n \n     boolean contains(double x, double y);\n\n-    double x1d();\n-    double y1d();\n-    double x2d();\n-    double y2d();\n-    double intersectionAreaD(Rectangle r);\n-    double perimeterD();\n-    double areaD();\n\n+    boolean isDoublePrecision();\n \n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/internal/Util.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n@@ -42,10 +42,10 @@\n      */\n     public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n         Preconditions.checkArgument(!items.isEmpty());\n-        float minX1 = Float.MAX_VALUE;\n+        double minX1 = Double.MAX_VALUE;\n-        float minY1 = Float.MAX_VALUE;\n+        double minY1 = Double.MAX_VALUE;\n-        float maxX2 = -Float.MAX_VALUE;\n+        double maxX2 = -Double.MAX_VALUE;\n-        float maxY2 = -Float.MAX_VALUE;\n+        double maxY2 = -Double.MAX_VALUE;\n         for (final HasGeometry item : items) {\n             Rectangle r = item.geometry().mbr();\n             if (r.x1() < minX1)",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-27",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.github.davidmoten.rtree.RTreeTest",
                "error": "java.lang.AssertionError",
                "message": "expected: com.github.davidmoten.rtree.geometry.internal.RectangleDoubleImpl<Rectangle [x1=1.0, y1=1.0, x2=2.0, y2=2.0]> but was: com.github.davidmoten.rtree.geometry.internal.RectangleImpl<Rectangle [x1=1.0, y1=1.0, x2=2.0, y2=2.0]>",
                "methodName": "testRTreeRootMbrWhenRTreeNonEmpty"
            },
            {
                "className": "com.github.davidmoten.rtree.UtilTest",
                "error": "java.lang.AssertionError",
                "message": "expected: com.github.davidmoten.rtree.geometry.internal.RectangleDoubleImpl<Rectangle [x1=-2.0, y1=-2.0, x2=-1.0, y2=-1.0]> but was: com.github.davidmoten.rtree.geometry.internal.RectangleImpl<Rectangle [x1=-2.0, y1=-2.0, x2=-1.0, y2=-1.0]>",
                "methodName": "testMbrWithNegativeValues"
            }
        ],
        "metrics": {
            "chunks": 40,
            "classes": 6,
            "files": 6,
            "linesAdd": 26,
            "linesMod": 44,
            "linesRem": 111,
            "methods": 66,
            "sizeInLines": 70
        },
        "program": "RegressionBug-27",
        "project": "RegressionBug-27",
        "repairOperators": [
            "mcRepl",
            "mdRetTyChange",
            "condBranRem",
            "mdRem",
            "mdAdd",
            "mdOverride",
            "condBranIfElseAdd",
            "mdRen",
            "mdParTyChange",
            "retExpChange"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDoubleImpl.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDoubleImpl.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDoubleImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDoubleImpl.java\n@@ -28,40 +28,29 @@\n     }\n \n     @Override\n-    public float x1() {\n+    public double x1() {\n         return (float) x1;\n     }\n \n     @Override\n-    public float y1() {\n+    public double y1() {\n         return (float) y1;\n     }\n \n     @Override\n-    public float x2() {\n+    public double x2() {\n         return (float) x2;\n     }\n \n     @Override\n-    public float y2() {\n+    public double y2() {\n         return (float) y2;\n     }\n \n     @Override\n-    public float area() {\n-        return (float) areaD();\n-    }\n\n-    @Override\n     public Rectangle add(Rectangle r) {\n-        if (r instanceof RectangleDoubleImpl) {\n-            RectangleDoubleImpl rd = (RectangleDoubleImpl) r;\n-            return new RectangleDoubleImpl(min(x1, rd.x1d()), min(y1, rd.y1d()), max(x2, rd.x2d()),\n-                    max(y2, rd.y2d()));\n-        } else {\n-            return new RectangleDoubleImpl(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n-                    max(y2, r.y2()));\n-        }\n+        return new RectangleDoubleImpl(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n+                max(y2, r.y2()));\n     }\n \n     @Override\n@@ -171,13 +160,13 @@\n     }\n \n     @Override\n-    public float intersectionArea(Rectangle r) {\n-        return (float) intersectionAreaD(r);\n-    }\n\n-    @Override\n-    public float perimeter() {\n-        return (float) perimeterD();\n+    public double intersectionArea(Rectangle r) {\n+        if (!intersects(r))\n+            return 0;\n+        else {\n+            return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n+                    .area();\n+        }\n     }\n \n     @Override\n@@ -207,50 +196,18 @@\n     }\n \n     @Override\n-    public double intersectionAreaD(Rectangle r) {\n-        if (!intersects(r))\n-            return 0;\n-        else {\n-            if (r instanceof RectangleDoubleImpl) {\n-                RectangleDoubleImpl rd = (RectangleDoubleImpl) r;\n-                return create(max(x1, rd.x1), max(y1, rd.y1), min(x2, rd.x2), min(y2, rd.y2))\n-                        .areaD();\n-            } else {\n-                return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n-                        .areaD();\n-            }\n-        }\n-    }\n\n-    @Override\n-    public double perimeterD() {\n+    public double perimeter() {\n         return 2 * (x2 - x1) + 2 * (y2 - y1);\n     }\n \n     @Override\n-    public double x1d() {\n-        return x1;\n-    }\n\n-    @Override\n-    public double y1d() {\n-        return y1;\n-    }\n\n-    @Override\n-    public double x2d() {\n-        return x2;\n-    }\n\n-    @Override\n-    public double y2d() {\n-        return y2;\n+    public double area() {\n+        return (x2 - x1) * (y2 - y1);\n     }\n \n     @Override\n-    public double areaD() {\n-        return (x2 - x1) * (y2 - y1);\n+    public boolean isDoublePrecision() {\n+        return true;\n     }\n \n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleImpl.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleImpl.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleImpl.java\n@@ -28,34 +28,39 @@\n     }\n \n     @Override\n-    public float x1() {\n+    public double x1() {\n         return x1;\n     }\n \n     @Override\n-    public float y1() {\n+    public double y1() {\n         return y1;\n     }\n \n     @Override\n-    public float x2() {\n+    public double x2() {\n         return x2;\n     }\n \n     @Override\n-    public float y2() {\n+    public double y2() {\n         return y2;\n     }\n \n     @Override\n-    public float area() {\n+    public double area() {\n         return (x2 - x1) * (y2 - y1);\n     }\n \n     @Override\n     public Rectangle add(Rectangle r) {\n-        return new RectangleImpl(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n-                max(y2, r.y2()));\n+        if (r.isDoublePrecision()) {\n+            return RectangleDoubleImpl.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n+                    max(y2, r.y2()));\n+        } else {\n+            return RectangleDoubleImpl.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n+                    max(y2, r.y2()));\n+        }\n     }\n \n     @Override\n@@ -74,29 +79,29 @@\n         return distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n     }\n \n-    public static double distance(float x1, float y1, float x2, float y2, float a1, float b1,\n-            float a2, float b2) {\n+    public static double distance(double x1, double y1, double x2, double y2, double a1, double b1,\n+            double a2, double b2) {\n         if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n             return 0;\n         }\n         boolean xyMostLeft = x1 < a1;\n-        float mostLeftX1 = xyMostLeft ? x1 : a1;\n-        float mostRightX1 = xyMostLeft ? a1 : x1;\n-        float mostLeftX2 = xyMostLeft ? x2 : a2;\n+        double mostLeftX1 = xyMostLeft ? x1 : a1;\n+        double mostRightX1 = xyMostLeft ? a1 : x1;\n+        double mostLeftX2 = xyMostLeft ? x2 : a2;\n         double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n \n         boolean xyMostDown = y1 < b1;\n-        float mostDownY1 = xyMostDown ? y1 : b1;\n-        float mostUpY1 = xyMostDown ? b1 : y1;\n-        float mostDownY2 = xyMostDown ? y2 : b2;\n+        double mostDownY1 = xyMostDown ? y1 : b1;\n+        double mostUpY1 = xyMostDown ? b1 : y1;\n+        double mostDownY2 = xyMostDown ? y2 : b2;\n \n         double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n \n         return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n     }\n \n-    private static boolean intersects(float x1, float y1, float x2, float y2, float a1, float b1,\n-            float a2, float b2) {\n+    private static boolean intersects(double x1, double y1, double x2, double y2, double a1,\n+            double b1, double a2, double b2) {\n         return x1 <= a2 && a1 <= x2 && y1 <= b2 && b1 <= y2;\n     }\n \n@@ -126,7 +131,7 @@\n     }\n \n     @Override\n-    public float intersectionArea(Rectangle r) {\n+    public double intersectionArea(Rectangle r) {\n         if (!intersects(r))\n             return 0;\n         else\n@@ -135,7 +140,7 @@\n     }\n \n     @Override\n-    public float perimeter() {\n+    public double perimeter() {\n         return 2 * (x2 - x1) + 2 * (y2 - y1);\n     }\n \n@@ -144,14 +149,14 @@\n         return this;\n     }\n \n-    private static float max(float a, float b) {\n+    private static double max(double a, double b) {\n         if (a < b)\n             return b;\n         else\n             return a;\n     }\n \n-    private static float min(float a, float b) {\n+    private static double min(double a, double b) {\n         if (a < b)\n             return a;\n         else\n@@ -159,38 +164,8 @@\n     }\n \n     @Override\n-    public double x1d() {\n-        return x1;\n-    }\n\n-    @Override\n-    public double y1d() {\n-        return y1;\n-    }\n\n-    @Override\n-    public double x2d() {\n-        return x2;\n-    }\n\n-    @Override\n-    public double y2d() {\n-        return y2;\n-    }\n\n-    @Override\n-    public double intersectionAreaD(Rectangle r) {\n-        return intersectionArea(r);\n-    }\n\n-    @Override\n-    public double perimeterD() {\n-        return perimeter();\n-    }\n\n-    @Override\n-    public double areaD() {\n-        return area();\n+    public boolean isDoublePrecision() {\n+        return false;\n     }\n \n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/Point.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n@@ -1,5 +1,6 @@\n package com.github.davidmoten.rtree.geometry;\n \n+import com.github.davidmoten.rtree.geometry.internal.RectangleDoubleImpl;\n import com.github.davidmoten.rtree.geometry.internal.RectangleImpl;\n \n public final class Point implements Rectangle {\n@@ -27,7 +28,7 @@\n \n     @Override\n     public double distance(Rectangle r) {\n-        return RectangleImpl.distance(x, y, x, y, r.x1(), r.y1(), r.x2(), r.y2());\n+        return RectangleDoubleImpl.distance(x, y, x, y, r.x1(), r.y1(), r.x2(), r.y2());\n     }\n \n     public double distance(Point p) {\n@@ -89,27 +90,27 @@\n     }\n \n     @Override\n-    public float x1() {\n+    public double x1() {\n         return x;\n     }\n \n     @Override\n-    public float y1() {\n+    public double y1() {\n         return y;\n     }\n \n     @Override\n-    public float x2() {\n+    public double x2() {\n         return x;\n     }\n \n     @Override\n-    public float y2() {\n+    public double y2() {\n         return y;\n     }\n \n     @Override\n-    public float area() {\n+    public double area() {\n         return 0;\n     }\n \n@@ -125,48 +126,18 @@\n     }\n \n     @Override\n-    public float intersectionArea(Rectangle r) {\n+    public double intersectionArea(Rectangle r) {\n         return 0;\n     }\n \n     @Override\n-    public float perimeter() {\n+    public double perimeter() {\n         return 0;\n     }\n \n     @Override\n-    public double x1d() {\n-        return x;\n-    }\n\n-    @Override\n-    public double y1d() {\n-        return y;\n-    }\n\n-    @Override\n-    public double x2d() {\n-        return x;\n-    }\n\n-    @Override\n-    public double y2d() {\n-        return y;\n-    }\n\n-    @Override\n-    public double intersectionAreaD(Rectangle r) {\n-        return intersectionArea(r);\n-    }\n\n-    @Override\n-    public double perimeterD() {\n-        return perimeter();\n-    }\n\n-    @Override\n-    public double areaD() {\n-        return area();\n+    public boolean isDoublePrecision() {\n+        return false;\n     }\n \n }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n@@ -2,36 +2,24 @@\n \n public interface Rectangle extends Geometry, HasGeometry {\n \n-    float x1();\n+    double x1();\n \n-    float y1();\n+    double y1();\n \n-    float x2();\n+    double x2();\n \n-    float y2();\n+    double y2();\n \n-    float area();\n+    double area();\n \n-    float intersectionArea(Rectangle r);\n+    double intersectionArea(Rectangle r);\n \n-    float perimeter();\n+    double perimeter();\n \n     Rectangle add(Rectangle r);\n \n     boolean contains(double x, double y);\n\n-    double x1d();\n\n-    double y1d();\n\n-    double x2d();\n\n-    double y2d();\n\n-    double intersectionAreaD(Rectangle r);\n\n-    double perimeterD();\n\n-    double areaD();\n    \n+    boolean isDoublePrecision();\n \n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/internal/Util.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/internal/Util.java\n@@ -42,10 +42,10 @@\n      */\n     public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n         Preconditions.checkArgument(!items.isEmpty());\n-        float minX1 = Float.MAX_VALUE;\n-        float minY1 = Float.MAX_VALUE;\n-        float maxX2 = -Float.MAX_VALUE;\n-        float maxY2 = -Float.MAX_VALUE;\n+        double minX1 = Double.MAX_VALUE;\n+        double minY1 = Double.MAX_VALUE;\n+        double maxX2 = -Double.MAX_VALUE;\n+        double maxY2 = -Double.MAX_VALUE;\n         for (final HasGeometry item : items) {\n             Rectangle r = item.geometry().mbr();\n             if (r.x1() < minX1)\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/RTree.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/RTree.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/github/davidmoten/rtree/RTree.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/github/davidmoten/rtree/RTree.java\n@@ -427,9 +427,9 @@\n             private double mid(HasGeometry o) {\n                 Rectangle mbr = o.geometry().mbr();\n                 if (dimension == 0)\n-                    return (mbr.x1d() + mbr.x2d()) / 2;\n+                    return (mbr.x1() + mbr.x2()) / 2;\n                 else\n-                    return (mbr.y1d() + mbr.y2d()) / 2;\n+                    return (mbr.y1() + mbr.y2()) / 2;\n             }\n         }\n \n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n@@ -1,6 +1,8 @@\n package com.github.davidmoten.rtree.geometry;\n \n import com.github.davidmoten.guavamini.annotations.VisibleForTesting;\n+import com.github.davidmoten.rtree.geometry.internal.RectangleDoubleImpl;\n+import com.github.davidmoten.rtree.geometry.internal.RectangleImpl;\n \n public final class Geometries {\n \n@@ -17,7 +19,7 @@\n     }\n \n     public static Rectangle rectangle(double x1, double y1, double x2, double y2) {\n-        return RectangleImpl.create(x1, y1, x2, y2);\n+        return rectangleDouble(x1, y1, x2, y2);\n     }\n \n     public static Rectangle rectangle(float x1, float y1, float x2, float y2) {\n@@ -54,6 +56,10 @@\n         return rectangle(x1, lat1, x2, lat2);\n     }\n \n+    public static Rectangle rectangleDouble(double x1, double y1, double x2, double y2) {\n+        return RectangleDoubleImpl.create(x1, y1, x2, y2);\n+    }\n\n     public static Point pointGeographic(double lon, double lat) {\n         return point(normalizeLongitude(lon), lat);\n     }\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry: internal\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Point.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n@@ -1,5 +1,7 @@\n package com.github.davidmoten.rtree.geometry;\n \n+import com.github.davidmoten.rtree.geometry.internal.RectangleImpl;\n\n public final class Point implements Rectangle {\n \n     private final float x;\n@@ -132,4 +134,39 @@\n         return 0;\n     }\n \n+    @Override\n+    public double x1d() {\n+        return x;\n+    }\n+\n+    @Override\n+    public double y1d() {\n+        return y;\n+    }\n+\n+    @Override\n+    public double x2d() {\n+        return x;\n+    }\n+\n+    @Override\n+    public double y2d() {\n+        return y;\n+    }\n+\n+    @Override\n+    public double intersectionAreaD(Rectangle r) {\n+        return intersectionArea(r);\n+    }\n+\n+    @Override\n+    public double perimeterD() {\n+        return perimeter();\n+    }\n+\n+    @Override\n+    public double areaD() {\n+        return area();\n+    }\n+\n }\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry: RectangleDoubleImpl.java\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry: RectangleDouble.java\nOnly in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry: RectangleImpl.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java\n@@ -20,4 +20,18 @@\n \n     boolean contains(double x, double y);\n \n+    double x1d();\n\n+    double y1d();\n\n+    double x2d();\n\n+    double y2d();\n\n+    double intersectionAreaD(Rectangle r);\n\n+    double perimeterD();\n\n+    double areaD();\n\n }\n\\ No newline at end of file\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/RTree.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/RTree.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/github/davidmoten/rtree/RTree.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/github/davidmoten/rtree/RTree.java\n@@ -13,8 +13,8 @@\n import com.github.davidmoten.guavamini.Optional;\n import com.github.davidmoten.guavamini.annotations.VisibleForTesting;\n import com.github.davidmoten.rtree.geometry.Circle;\n-import com.github.davidmoten.rtree.geometry.HasGeometry;\n import com.github.davidmoten.rtree.geometry.Geometry;\n+import com.github.davidmoten.rtree.geometry.HasGeometry;\n import com.github.davidmoten.rtree.geometry.Intersects;\n import com.github.davidmoten.rtree.geometry.Line;\n import com.github.davidmoten.rtree.geometry.Point;\n@@ -72,7 +72,7 @@\n     }\n \n     private RTree() {\n-        this(Optional.<Node<T, S>> absent(), 0, null);\n+        this(Optional.<Node<T, S>>absent(), 0, null);\n     }\n\n@@ -328,20 +327,22 @@\n         public <T, S extends Geometry> RTree<T, S> create() {\n             setDefaultCapacity();\n \n-            return new RTree<T, S>(Optional.<Node<T, S>> absent(), 0,\n+            return new RTree<T, S>(Optional.<Node<T, S>>absent(), 0,\n                     new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                             (Factory<T, S>) factory));\n         }\n \n@@ -365,8 +366,7 @@\n \n         @SuppressWarnings(\"unchecked\")\n         private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n-                                                               boolean isLeaf, int size,\n-                                                               Context<T, S> context) {\n+                boolean isLeaf, int size, Context<T, S> context) {\n             int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n             int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n \n@@ -385,23 +385,24 @@\n             int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n             int sliceCapacity = nodePerSlice * capacity;\n             int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n-            Collections.sort(objects, new MidComparator((short)0));\n+            Collections.sort(objects, new MidComparator((short) 0));\n \n             List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n             for (int s = 0; s < sliceCount; s++) {\n                 @SuppressWarnings(\"rawtypes\")\n-                List slice = objects.subList(s * sliceCapacity, Math.min((s + 1) * sliceCapacity, objects.size()));\n-                Collections.sort(slice, new MidComparator((short)1));\n+                List slice = objects.subList(s * sliceCapacity,\n+                        Math.min((s + 1) * sliceCapacity, objects.size()));\n+                Collections.sort(slice, new MidComparator((short) 1));\n \n                 for (int i = 0; i < slice.size(); i += capacity) {\n                     if (isLeaf) {\n-                        List<Entry<T, S>> entries =\n-                                slice.subList(i, Math.min(slice.size(), i + capacity));\n+                        List<Entry<T, S>> entries = slice.subList(i,\n+                                Math.min(slice.size(), i + capacity));\n                         Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                         nodes.add(leaf);\n                     } else {\n-                        List<Node<T, S>> children =\n-                                slice.subList(i, Math.min(slice.size(), i + capacity));\n+                        List<Node<T, S>> children = slice.subList(i,\n+                                Math.min(slice.size(), i + capacity));\n                         Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                         nodes.add(nonleaf);\n                     }\n@@ -419,13 +421,15 @@\n \n             @Override\n             public int compare(HasGeometry o1, HasGeometry o2) {\n-                return Float.compare(mid(o1), mid(o2));\n+                return Double.compare(mid(o1), mid(o2));\n             }\n \n-            private float mid(HasGeometry o) {\n+            private double mid(HasGeometry o) {\n                 Rectangle mbr = o.geometry().mbr();\n-                if (dimension == 0) return (mbr.x1() + mbr.x2()) / 2;\n-                else return (mbr.y1() + mbr.y2()) / 2;\n+                if (dimension == 0)\n+                    return (mbr.x1d() + mbr.x2d()) / 2;\n+                else\n+                    return (mbr.y1d() + mbr.y2d()) / 2;\n             }\n         }\n \n@@ -832,7 +828,7 @@\n     public Observable<Entry<T, S>> nearest(final Rectangle r, final double maxDistance,\n             int maxCount) {\n         return search(r, maxDistance).lift(new OperatorBoundedPriorityQueue<Entry<T, S>>(maxCount,\n-                Comparators.<T, S> ascendingDistance(r)));\n+                Comparators.<T, S>ascendingDistance(r)));\n     }\n\n@@ -895,7 +891,7 @@\n     }\n \n     private Rectangle calculateMaxView(RTree<T, S> tree) {\n-        return tree.entries().reduce(Optional.<Rectangle> absent(),\n+        return tree.entries().reduce(Optional.<Rectangle>absent(),\n                 new Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>>() {\n \n                     @Override",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-28",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_309",
                "error": "java.lang.AssertionError:",
                "message": "null",
                "methodName": "parserFilesTest"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-28",
        "project": "RegressionBug-28",
        "repairOperators": [
            "assignAdd",
            "varAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/ParserOutput.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/ParserOutput.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n@@ -399,5 +399,6 @@\n \t\tthis.currentRecord = 0;\n \t\tthis.column = 0;\n \t\tthis.headers = null;\n+\t\tthis.headerStrings = null;\n \t}\n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractParser.java\n@@ -67,6 +67,9 @@\n \tprivate final boolean extractHeaders;\n \tprotected final int whitespaceRangeStart;\n \n+\tprotected boolean ignoreTrailingWhitespace;\n+\tprotected boolean ignoreLeadingWhitespace;\n\n \t/**\n \t * All parsers must support, at the very least, the settings provided by {@link CommonParserSettings}. The AbstractParser requires its configuration to be properly initialized.*/\n@@ -76,6 +79,8 @@\n \t\tsettings.autoConfigure();\n \t\tthis.settings = settings;\n \t\tthis.errorContentLength = settings.getErrorContentLength();\n+\t\tthis.ignoreTrailingWhitespace = settings.getIgnoreTrailingWhitespaces();\n+\t\tthis.ignoreLeadingWhitespace = settings.getIgnoreLeadingWhitespaces();\n \t\tthis.output = new ParserOutput(this, settings);\n \t\tthis.processor = settings.getProcessor();\n \t\tthis.recordsToRead = settings.getNumberOfRecordsToRead();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/DefaultContext.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/DefaultContext.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/DefaultContext.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/DefaultContext.java\n@@ -45,7 +45,7 @@\n \t\tif (output == null) {\n \t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n \t\t}\n-\t\treturn output.getHeaders();\n+\t\treturn output.getHeaderAsStringArray();\n \t}\n \n \tpublic String[] selectedHeaders() {}\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/NormalizedString.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/NormalizedString.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/NormalizedString.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/NormalizedString.java\n+\tprivate static final StringCache<NormalizedString> stringCache = new StringCache<NormalizedString>() {\n+\t\t@Override\n+\t\tprotected NormalizedString process(String input) {\n+\t\t\tif (input == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new NormalizedString(input);\n+\t\t}\n+\t};\n\n+ \tprivate final String original;\n+ \tprivate final String normalized;\n+ \tprivate final boolean literal;\n+ \tprivate final int hashCode;\n\n+ \tprivate NormalizedString(String string) {\n+ \t\tString trimmed = string.trim();\n+ \t\tif (trimmed.length() > 2 && trimmed.charAt(0) == '\\'' && trimmed.charAt(trimmed.length() - 1) == '\\'') {\n+ \t\t\tthis.original = string.substring(1, string.length() - 1);\n+ \t\t\tthis.normalized = original;\n+ \t\t\tthis.hashCode = normalize(original).hashCode();\n+ \t\t\tthis.literal = true;\n+ \t\t} else {\n+ \t\t\tthis.original = string;\n+ \t\t\tthis.normalized = normalize(original);\n+ \t\t\tthis.hashCode = normalized.hashCode();\n+ \t\t\tthis.literal = false;\n+ \t\t}\n+ \t}\n\n+\tprivate String normalize(Object value) {\n+\t\tString str = String.valueOf(value);\n+\t\tstr = str.trim().toLowerCase();\n+\t\treturn str;\n+\t}\n\n+ \tpublic boolean isLiteral() {\n+ \t\treturn literal;\n+ \t}\n\n+ \t@Override\n+ \tpublic int compareTo(NormalizedString o) {\n+ \t\tif (o == this) {\n+ \t\t\treturn 0;\n+ \t\t}\n\n+ \t\tif (this.literal || o.literal) {\n+ \t\t\treturn original.compareTo(o.original);\n+ \t\t}\n\n+ \t\treturn this.normalized.compareTo(o.normalized);\n+ \t}\n\n+ \t@Override\n+ \tpublic String toString() {\n+ \t\treturn original;\n+ \t}\n\n+ \tpublic static NormalizedString valueOf(String string) {\n+ \t\tif (string == null) {\n+ \t\t\treturn null;\n+ \t\t}\n+ \t\treturn stringCache.get(string);\n+ \t}\n\n+ \tpublic static String valueOf(NormalizedString string) {\n+ \t\tif (string == null) {\n+ \t\t\treturn null;\n+ \t\t}\n+ \t\treturn string.original;\n+ \t}\n\n+ \tpublic static NormalizedString[] toArray(String... args) {\n+ \t\tif (args == null) {\n+ \t\t\treturn null;\n+ \t\t} else if (args.length == 0) {\n+ \t\t\treturn EMPTY_NORMALIZED_STRING_ARRAY;\n+ \t\t}\n\n+ \t\tNormalizedString[] out = new NormalizedString[args.length];\n+ \t\tfor (int i = 0; i < args.length; i++) {\n+ \t\t\tout[i] = valueOf(args[i]);\n+ \t\t}\n+ \t\treturn out;\n+ \t}\n\n+ \tpublic static String[] toArray(NormalizedString... args) {\n+ \t\tif (args == null) {\n+ \t\t\treturn null;\n+ \t\t} else if (args.length == 0) {\n+ \t\t\treturn EMPTY_STRING_ARRAY;\n+ \t\t}\n+ \t\tString[] out = new String[args.length];\n+ \t\tfor (int i = 0; i < args.length; i++) {\n+ \t\t\tout[i] = valueOf(args[i]);\n+ \t\t}\n+ \t\treturn out;\n+ \t}\n\n+ \tpublic static NormalizedString[] toIdentifierGroupArray(String[] strings) {\n+ \t\tNormalizedString[] out = toArray(strings);\n+ \t\tidentifyLiterals(out, false, false);\n+ \t\treturn out;\n+ \t}\n\n+ \tpublic static boolean identifyLiterals(NormalizedString[] strings, boolean lowercaseIdentifiers, boolean uppercaseIdentifiers) {\n+ \t\tif (strings == null) {\n+ \t\t\treturn false;\n+ \t\t}\n+ \t\tTreeMap<NormalizedString, Object[]> normalizedMap = new TreeMap<NormalizedString, Object[]>();\n\n+ \t\tboolean modified = false;\n\n+ \t\tfor (int i = 0; i < strings.length; i++) {\n+ \t\t\tNormalizedString string = strings[i];\n+ \t\t\tif (string == null || string.isLiteral()) {\n+ \t\t\t\tcontinue;\n+ \t\t\t}\n\n+ \t\t\tif (shouldBeLiteral(string.original, lowercaseIdentifiers, uppercaseIdentifiers)) {\n+ \t\t\t\tstrings[i] = NormalizedString.literalValueOf(string.original);\n+ \t\t\t\tcontinue;\n+ \t\t\t}\n\n+ \t\t\tObject[] clashing = normalizedMap.get(string);\n+ \t\t\tif (clashing != null && !string.original.equals(((NormalizedString) clashing[0]).original)) {\n+ \t\t\t\tstrings[i] = NormalizedString.literalValueOf(string.original);\n+ \t\t\t\tstrings[(Integer) clashing[1]] = ((NormalizedString) clashing[0]).toLiteral();\n+ \t\t\t\tmodified = true;\n+ \t\t\t} else {\n+ \t\t\t\tnormalizedMap.put(string, new Object[]{string, i});\n+ \t\t\t}\n+ \t\t}\n\n+ \t\treturn modified;\n+ \t}\n\n+ \tprivate static boolean shouldBeLiteral(String string, boolean lowercaseIdentifiers, boolean uppercaseIdentifiers) {\n+ \t\tif (lowercaseIdentifiers || uppercaseIdentifiers) {\n+ \t\t\tfor (int i = 0; i < string.length(); i++) {\n+ \t\t\t\tchar ch = string.charAt(i);\n+ \t\t\t\tif ((uppercaseIdentifiers && !Character.isUpperCase(ch)) || (lowercaseIdentifiers && !Character.isLowerCase(ch))) {\n+ \t\t\t\t\treturn true;\n+ \t\t\t\t}\n+ \t\t\t}\n+ \t\t}\n+ \t\treturn false;\n+ \t}\n+}\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/ParserOutput.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/ParserOutput.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n@@ -74,7 +74,8 @@\n \tprivate boolean columnsReordered;\n \tprivate boolean columnReorderingEnabledSetting;\n \n-\tprivate String[] headers;\n+\tprivate String[] headerStrings;\n+\tprivate NormalizedString[] headers;\n \tprivate int[] selectedIndexes;\n \n \tprivate long currentRecord;\n@@ -117,6 +118,10 @@\n \t\tthis.nullValue = settings.getNullValue();\n \t\tthis.columnsToExtractInitialized = false;\n \t\tthis.currentRecord = 0;\n+\t\tif (settings.isHeaderExtractionEnabled() && parser != null) {\n+\t\t\tparser.ignoreTrailingWhitespace = false;\n+\t\t\tparser.ignoreLeadingWhitespace = false;\n+\t\t}\n \t\tif (settings.getHeaders() != null) {\n \t\t\tinitializeHeaders();\n \t\t}\n@@ -134,17 +139,42 @@\n \t\t\tSystem.arraycopy(parsedValues, 0, parsedHeaders, 0, column);\n \t\t}\n \n-\t\tthis.headers = settings.getHeaders();\n+\t\tboolean usingParsedHeaders = false;\n+\t\tthis.headers = NormalizedString.toIdentifierGroupArray(settings.getHeaders());\n \t\tif (headers != null) {\n \t\t\theaders = headers.clone();\n \t\t} else if (column > 0) { //we only initialize headers from a parsed row if it is not empty\n-\t\t\theaders = parsedHeaders.clone();\n+\t\t\theaders = NormalizedString.toIdentifierGroupArray(parsedHeaders.clone());\n+\t\t\tusingParsedHeaders = true;\n \t\t}\n \n-\t\tif (headers != null) {\n-\t\t\tcolumnsToExtractInitialized = true;\n-\t\t\tinitializeColumnsToExtract(headers);\n+\t\tif (parser != null) {\n+\t\t\tparser.ignoreTrailingWhitespace = settings.getIgnoreTrailingWhitespaces();\n+\t\t\tparser.ignoreLeadingWhitespace = settings.getIgnoreLeadingWhitespaces();\n+\t\t\tif (usingParsedHeaders) {\n+\t\t\t\tparser.initialize();\n+\t\t\t}\n+\t\t}\n\n+\t\tif (usingParsedHeaders) {\n+\t\t\tfor (int i = 0; i < headers.length; i++) {\n+\t\t\t\tNormalizedString header = headers[i];\n+\t\t\t\tif (header != null && !header.isLiteral()) {\n+\t\t\t\t\tif (settings.getIgnoreLeadingWhitespaces()) {\n+\t\t\t\t\t\tif (settings.getIgnoreTrailingWhitespaces()) {\n+\t\t\t\t\t\t\theaders[i] = NormalizedString.valueOf(headers[i].toString().trim());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\theaders[i] = NormalizedString.valueOf(ArgumentUtils.trim(headers[i].toString(), true, false));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (settings.getIgnoreTrailingWhitespaces()) {\n+\t\t\t\t\t\theaders[i] = NormalizedString.valueOf(ArgumentUtils.trim(headers[i].toString(), false, true));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n\n+\t\tcolumnsToExtractInitialized = true;\n+\t\tinitializeColumnsToExtract(headers);\n \t}\n \n \t/**\n@@ -238,7 +268,7 @@\n \t *\n \t * @param values a sequence of values that represent the headers of the input. This can be either a parsed record or the headers as defined in {@link CommonSettings#getHeaders()}\n \t */\n-\tprivate void initializeColumnsToExtract(String[] values) {\n+\tprivate void initializeColumnsToExtract(NormalizedString[] values) {\n \t\tFieldSelector selector = settings.getFieldSelector();\n \t\tif (selector != null) {\n \t\t\tselectedIndexes = selector.getFieldIndexes(values);\n@@ -263,17 +293,24 @@\n \t\t}\n \t}\n \n+\tpublic String[] getHeaderAsStringArray() {\n+\t\tif (headerStrings == null) {\n+\t\t\theaderStrings = NormalizedString.toArray(getHeaders());\n+\t\t}\n+\t\treturn headerStrings;\n+\t}\n+\n \t/**\n \t * Returns the sequence of values that represent the headers each field in the input. This can be either a parsed record or the headers as defined in {@link CommonSettings#getHeaders()}\n \t *\n \t * @return the headers each field in the input\n \t */\n-\tpublic String[] getHeaders() {\n+\tpublic NormalizedString[] getHeaders() {\n \t\tif (parser != null) {\n \t\t\tparser.extractHeadersIfRequired();\n \t\t}\n+\t\tif (this.headers == null && parser != null && parser.settings != null) {\n-\t\t\tthis.headers = parser.settings.getHeaders();\n+\t\t\tthis.headers = NormalizedString.toIdentifierGroupArray(parser.settings.getHeaders());\n \t\t}\n \t\treturn this.headers;\n \t}\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/StringCache.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/StringCache.java\n--- ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/StringCache.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/StringCache.java\n+public abstract class StringCache<T> {\n\n+ \tprivate final Map<String, SoftReference<T>> stringCache = new ConcurrentHashMap<String, SoftReference<T>>();\n\n+\tprotected abstract T process(String input);\n\n+\tpublic boolean containsKey(String input){\n+\t\treturn stringCache.containsKey(input);\n+\t}\n\n+\tpublic void put(String input, T value) {\n+\t\tstringCache.put(input, new SoftReference<T>(value));\n+\t}\n\n+\tpublic T get(String input) {\n+\t\tif(input == null){\n+\t\t\treturn null;\n+\t\t}\n+\t\tSoftReference<T> ref = stringCache.get(input);\n+ \t\tT out;\n+\t\tif (ref == null || ref.get() == null) {\n+ \t\t\tout = process(input);\n+ \t\t\tref = new SoftReference<T>(out);\n+ \t\t\tstringCache.put(input, ref);\n+ \t\t} else {\n+\t\t\tout = ref.get();\n+ \t\t}\n+\t\treturn out;\n+ \t}\n+}\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -34,8 +34,6 @@\n  */\n public final class CsvParser extends AbstractParser<CsvParserSettings> {\n \n-\tprivate final boolean ignoreTrailingWhitespace;\n-\tprivate final boolean ignoreLeadingWhitespace;\n \tprivate boolean parseUnescapedQuotes;\n \tprivate boolean parseUnescapedQuotesUntilDelimiter;\n \tprivate boolean backToDelimiter;\n@@ -69,8 +67,6 @@\n \t */\n \tpublic CsvParser(CsvParserSettings settings) {\n \t\tsuper(settings);\n-\t\tignoreTrailingWhitespace = settings.getIgnoreTrailingWhitespaces();\n-\t\tignoreLeadingWhitespace = settings.getIgnoreLeadingWhitespaces();\n \t\tparseUnescapedQuotes = settings.isParseUnescapedQuotes();\n \t\tparseUnescapedQuotesUntilDelimiter = settings.isParseUnescapedQuotesUntilDelimiter();\n \t\tdoNotEscapeUnquotedValues = !settings.isEscapeUnquotedValues();",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-29",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.fixed.FixedWidthWriterTest",
                "error": "java.lang.AssertionError",
                "message": "Lists differ at element [0]: ? != null expected [?] but found [null]",
                "methodName": "testWriterWithSpacesAndOverflow"
            },
            {
                "className": "com.univocity.parsers.fixed.FixedWidthWriterTest",
                "error": "java.lang.AssertionError",
                "message": "expected [N/A  \n] but found [     \n]",
                "methodName": "writeNullRowShouldReplaceWithNullValueFromSettings"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 2,
            "files": 2,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 2
        },
        "program": "RegressionBug-29",
        "project": "RegressionBug-29",
        "repairOperators": [
            "retExpChange",
            "condExpExpand"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n@@ -957,7 +957,7 @@\n \t\tusingNullOrEmptyValue = false;\n \t\tif (element == null) {\n \t\t\tusingNullOrEmptyValue = true;\n-\t\t\treturn null;\n+\t\t\treturn nullValue;\n \t\t}\n \t\tString string = String.valueOf(element);\n \t\tif (string.isEmpty()) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvWriter.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvWriter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvWriter.java\n@@ -207,7 +207,7 @@\n \t\t\tboolean isElementQuoted = append(quoteAllFields || quotedColumns.contains(i), nextElement);\n \n \t\t\t//skipped all whitespaces and wrote nothing\n-\t\t\tif (appender.length() == originalLength) {\n+\t\t\tif (appender.length() == originalLength && !usingNullOrEmptyValue) {\n \t\t\t\tif (isElementQuoted) {\n \t\t\t\t\tif (nextElement == null) {\n \t\t\t\t\t\tappend(false, nullValue);\n;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n@@ -941,11 +941,8 @@\n \tprotected String getStringValue(Object element) {\n \t\tusingNullOrEmptyValue = false;\n \t\tif (element == null) {\n-\t\t\telement = nullValue;\n \t\t\tusingNullOrEmptyValue = true;\n-\t\t\tif (element == null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n+\t\t\treturn null;\n \t\t}\n \t\tString string = String.valueOf(element);\n \t\tif (string.isEmpty()) {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-30",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_250",
                "error": "com.univocity.parsers.common.TextParsingException",
                "message": "java.lang.ArrayIndexOutOfBoundsException - 2\nHint: Number of columns processed may have exceeded limit of 2 columns. Use settings.setMaxColumns(int) to define the maximum number of columns your input can have\nEnsure your configuration is correct, with delimiters, quotes and escape sequences that match the input format you are trying to parse\nParser Configuration: CsvParserSettings:\n Auto configuration enabled=true\n Autodetect column delimiter=false\n Autodetect quotes=false\n Column reordering enabled=true\n Delimiters for detection=null\n Empty value=null\n Escape unquoted values=false\n Header extraction enabled=null\n Headers=null\n Ignore leading whitespaces=true\n Ignore leading whitespaces in quotes=false\n Ignore trailing whitespaces=true\n Ignore trailing whitespaces in quotes=false\n Input buffer size=1048576\n Input reading on separate thread=true\n Keep escape sequences=false\n Keep quotes=false\n Length of content displayed on error=-1\n Line separator detection enabled=true\n Maximum number of characters per column=4096\n Maximum number of columns=2\n Normalize escaped line separators=true\n Null value=null\n Number of records to read=all\n Processor=none\n Restricting data in exceptions=false\n RowProcessor error handler=null\n Selected fields=field selection: []\n Skip bits as whitespace=true\n Skip empty lines=true\n Unescaped quote handling=nullFormat configuration:\n CsvFormat:\n  Comment character=#\n  Field delimiter=,\n  Line separator (normalized)=\\n\n  Line separator sequence=\\n\n  Quote character=\"\n  Quote escape character=\"\n  Quote escape escape character=null\nInternal state when error was thrown: line=1, column=3, record=1, charIndex=6, headers=[a, b]",
                "methodName": "testParseInputNoIndexSelected"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-30",
        "project": "RegressionBug-30",
        "repairOperators": [
            "assignAdd"
        ],
        "repairTools": [
            "rtCodeGen6B",
            "rtIncoder1B",
            "rtIncoder6B",
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/ParserOutput.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/ParserOutput.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n@@ -179,6 +179,7 @@\n \t\t\tcurrentRecord++;\n \t\t\tif (columnsReordered) {\n \t\t\t\tif(selectedIndexes.length == 0){\n+\t\t\t\t\tcolumn = 0;\n \t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n \t\t\t\t}\n \t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/ParserOutput.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/ParserOutput.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/ParserOutput.java\n@@ -178,6 +178,9 @@\n \n \t\t\tcurrentRecord++;\n \t\t\tif (columnsReordered) {\n+\t\t\t\tif(selectedIndexes.length == 0){\n+\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n+\t\t\t\t}\n \t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n \t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n \t\t\t\t\tint index = selectedIndexes[i];",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-31",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_420",
                "error": "java.lang.AssertionError",
                "message": "expected [,] but found [ ]",
                "methodName": "detectedFormatTest"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 14,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 14
        },
        "program": "RegressionBug-31",
        "project": "RegressionBug-31",
        "repairOperators": [
            "condBranIfAdd",
            "varAdd",
            "assignAdd",
            "mcAdd",
            "loopAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n@@ -265,10 +264,26 @@\n\tprotected char pickDelimiter(Map<Character, Integer> sums, Map<Character, Integer> totals) {\n \t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n \t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n \n+\t\tif (delimiterMin == ' ' || delimiterMax == ' ') {\n+\t\t\tboolean hasOtherDelimiters = false;\n+\t\t\tfor (Map.Entry<Character, Integer> e : sums.entrySet()) {\n+\t\t\t\tif (e.getValue() == 0 && e.getKey() != ' ') {\n+\t\t\t\t\thasOtherDelimiters = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (hasOtherDelimiters) {\n+\t\t\t\ttotals.remove(' ');\n+\t\t\t\tdelimiterMax = max(sums, totals, suggestedDelimiter);\n+\t\t\t\tdelimiterMin = min(sums, totals, suggestedDelimiter);\n+\t\t\t}\n+\t\t}\n\n \t\tchar delimiter;\n \t\tout:\n \t\tif (delimiterMax != delimiterMin) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n@@ -325,7 +325,7 @@\n \t}\n \n \tprivate boolean isSymbol(char ch) {\n-\t\treturn ch != comment && !Character.isLetterOrDigit(ch) && (ch == '\\t' || ch > ' ');\n+\t\treturn ch != comment && !Character.isLetterOrDigit(ch) && (ch == '\\t' || ch >= ' ');\n \t}\n \n \t/**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-32",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.csv.CsvFormatDetectorTest",
                "error": "java.lang.AssertionError",
                "message": "expected [,] but found [ ]",
                "methodName": "testDelimitersDetectedUsingOrderOfPreference"
            }
        ],
        "metrics": {
            "chunks": 6,
            "classes": 2,
            "files": 2,
            "linesAdd": 19,
            "linesMod": 0,
            "linesRem": 1,
            "methods": 3,
            "sizeInLines": 19
        },
        "program": "RegressionBug-32",
        "project": "RegressionBug-32",
        "repairOperators": [
            "mdAdd",
            "loopAdd",
            "retBranchAdd",
            "varAdd",
            "assignAdd",
            "mcAdd",
            "condBranIfElseAdd",
            "condExpRed"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/ArgumentUtils.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/ArgumentUtils.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/ArgumentUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/ArgumentUtils.java\n@@ -136,11 +139,30 @@\n\t *\n\t * @return the index of the given character in the array, or -1 if the character could not be found.\n\t */\n+\tpublic static int indexOf(char[] array, char element, int from) {\n+\t\tfor (int i = from; i < array.length; i++) {\n+\t\t\tif (array[i] == element) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\treturn -1;\n+\t}\n\n\t/**\n \t * Returns the index of an element in a given array.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n@@ -15,6 +15,7 @@\n  ******************************************************************************/\n package com.univocity.parsers.csv;\n \n+import com.univocity.parsers.common.*;\n import com.univocity.parsers.common.input.*;\n \n import java.util.*;\n@@ -33,12 +34,14 @@\n \tprivate final char normalizedNewLine;\n \tprivate final int whitespaceRangeStart;\n \tprivate char[] allowedDelimiters;\n+\tprivate char[] delimiterPreference;\n \n \t/**\n \t * Builds a new {@code CsvFormatDetector}\n@@ -48,11 +51,13 @@\n \n \t\tif (allowedDelimiters != null && allowedDelimiters.length > 0) {\n \t\t\tsuggestedDelimiter = allowedDelimiters[0];\n+\t\t\tdelimiterPreference = allowedDelimiters.clone();\n \t\t\tArrays.sort(allowedDelimiters);\n \t\t} else {\n \t\t\tString delimiter = settings.getFormat().getDelimiterString();\n \t\t\tsuggestedDelimiter = delimiter.length() > 1 ? ',' : settings.getFormat().getDelimiter();\n \t\t\tallowedDelimiters = new char[0];\n+\t\t\tdelimiterPreference = allowedDelimiters;\n \t\t}\n \n \t\tnormalizedNewLine = settings.getFormat().getNormalizedNewline();\n@@ -313,7 +318,13 @@\n \t\t\t\t\tInteger newTotal = totals.get(newChar);\n \n \t\t\t\t\tif (currentTotal != null && newTotal != null) {\n-\t\t\t\t\t\tif ((min && newTotal > currentTotal) || (!min && newTotal > currentTotal)) {\n+\t\t\t\t\t\tif (currentTotal.equals(newTotal)) {\n+\t\t\t\t\t\t\tint defIndex = ArgumentUtils.indexOf(delimiterPreference, defaultChar, 0);\n+\t\t\t\t\t\t\tint newIndex = ArgumentUtils.indexOf(delimiterPreference, newChar, 0);\n+\t\t\t\t\t\t\tif (defIndex != -1 && newIndex != -1) {\n+\t\t\t\t\t\t\t\tdefaultChar = defIndex < newIndex ? defaultChar : newChar;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else if ((min && newTotal > currentTotal) || (!min && newTotal > currentTotal)) {\n \t\t\t\t\t\t\tdefaultChar = newChar;\n \t\t\t\t\t\t}\n \t\t\t\t\t} else if (isSymbol(newChar)) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\t2024-09-08 01:36:14.481811163 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\t2024-09-08 01:36:14.457810995 +1000\n@@ -325,7 +325,7 @@\n \t}\n \n \tprivate boolean isSymbol(char ch) {\n-\t\treturn ch != comment && !Character.isLetterOrDigit(ch) && (ch == '\\t' || ch > ' ');\n+\t\treturn ch != comment && !Character.isLetterOrDigit(ch) && (ch == '\\t' || ch >= ' ');\n \t}\n \n \t/**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-33",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_299",
                "error": "java.lang.AssertionError",
                "message": "expected [3] but found [4]",
                "methodName": "shouldDetectNewLine"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-33",
        "project": "RegressionBug-33",
        "repairOperators": [
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -137,6 +137,7 @@\n \t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape, trimQuotedLeading, trimQuotedTrailing);\n \t\t\t\t\t\tif (value != null) {\n \t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n+\t\t\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tch = input.nextChar();\n \t\t\t\t\t\t\t\tif (ch == delimiter) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -53,6 +54,7 @@\n \tprivate UnescapedQuoteHandling quoteHandling;\n \tprivate final String nullValue;\n \tprivate final int maxColumnLength;\n+\tprivate final String emptyValue;\n \n \t/**\n \t * The CsvParser supports all settings provided by {@link CsvParserSettings}, and requires this configuration to be properly initialized.*/\n@@ -70,6 +72,7 @@\n \t\tkeepQuotes = settings.getKeepQuotes();\n \t\tnormalizeLineEndingsInQuotes = settings.isNormalizeLineEndingsWithinQuotes();\n \t\tnullValue = settings.getNullValue();\n+\t\temptyValue = settings.getEmptyValue();\n \t\tmaxColumnLength = settings.getMaxCharsPerColumn();\n \n \n@@ -118,13 +121,29 @@\n \t\t\t\tprev = '\\0';\n \t\t\t\tif (ch == quote) {\n \t\t\t\t\toutput.trim = false;\n-\t\t\t\t\tif (normalizeLineEndingsInQuotes) {\n-\t\t\t\t\t\tparseQuotedValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tinput.enableNormalizeLineEndings(false);\n-\t\t\t\t\t\tparseQuotedValue();\n-\t\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n+\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n+\t\t\t\t\tif (output.appender.length() == 0) {\n+\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape);\n+\t\t\t\t\t\tif (value != null) {\n+\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tch = input.nextChar();\n+\t\t\t\t\t\t\t\tif (ch == delimiter) {\n+\t\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n+\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n+\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n+\t\t\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} catch (EOFException e) {\n+\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tparseQuotedValue();\n+\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n \t\t\t\t\toutput.valueParsed();\n \t\t\t\t} else if (doNotEscapeUnquotedValues) {\n \t\t\t\t\tString value = null;\n",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-34",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_39",
                "error": "com.univocity.parsers.common.TextWritingException",
                "message": "Error processing input rows from map\nInternal state when error was thrown: recordCount=1",
                "methodName": "testMapWriting"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-34",
        "project": "RegressionBug-34",
        "repairOperators": [
            "condExpExpand"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n@@ -1735,7 +1735,7 @@\n \t\t\tObject[] keys = new Object[rowData.size()];\n \t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n \n-\t\t\tif(headers == null){\n+\t\t\tif(outputList != null && headers == null){\n \t\t\t\tif(headerMapping != null){\n \t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n \t\t\t\t} else {\n",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n@@ -1735,6 +1735,17 @@\n \t\t\tObject[] keys = new Object[rowData.size()];\n \t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n \n+\t\t\tif(headers == null){\n+\t\t\t\tif(headerMapping != null){\n+\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n+\t\t\t\t} else {\n+\t\t\t\t\tsetHeadersFromMap(rowData, true);\n+\t\t\t\t}\n+\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n+\t\t\t\t\toutputList.add(writeHeadersToString());\n+\t\t\t\t}\n+\t\t\t}\n\n \t\t\tint length = 0;\n \t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n \t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-35",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_228",
                "error": "java.lang.AssertionError",
                "message": "expected [2] but found [1]",
                "methodName": "testLastNullValueInQuotedInput"
            },
            {
                "className": "com.univocity.parsers.issues.github.Github_228",
                "error": "java.lang.AssertionError",
                "message": "expected [15] but found [14]",
                "methodName": "testLastNullValueInQuotedInput2"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 3,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 3
        },
        "program": "RegressionBug-35",
        "project": "RegressionBug-35",
        "repairOperators": [
            "condBranIfAdd",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -125,6 +125,9 @@\n \t\t\t\t\t\t\t\tif (ch == delimiter) {\n \t\t\t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n+\t\t\t\t\t\t\t\t\t\tif(ch == newLine){\n+\t\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n+\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n \t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n \t\t\t\t\t\t\t\t\t\treturn;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java\n@@ -436,4 +436,72 @@\n \n \t\treturn out;\n \t}\n\n+\t@Override\n+\tpublic final String getQuotedString(char quote, char escape, char escapeEscape, int maxLength, char stop1, char stop2, boolean keepQuotes, boolean keepEscape) {\n+\t\tif (i == 0) {\n+\t\t\treturn null;\n+\t\t}\n\n+\t\tint i = this.i;\n+\t\twhile (true) {\n+\t\t\tif (i >= length) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tch = buffer[i];\n+\t\t\tif (ch == quote) {\n+\t\t\t\tif (buffer[i - 1] == escape) {\n+\t\t\t\t\tif(keepEscape){\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tif (i + 1 < length) {\n+\t\t\t\t\tchar next = buffer[i + 1];\n+\t\t\t\t\tif (next == stop1 || next == stop2) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} else if (ch == escape && !keepEscape) {\n+\t\t\t\tif (i + 1 < length) {\n+\t\t\t\t\tchar next = buffer[i + 1];\n+\t\t\t\t\tif (next == quote || next == escapeEscape) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (lineSeparator1 == ch && normalizeLineEndings && (lineSeparator2 == '\\0' || i + 1 < length && lineSeparator2 == buffer[i + 1])) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\ti++;\n+\t\t}\n+\t\tint pos = this.i;\n+\t\tint len = i - this.i;\n+\t\tif (len > maxLength) { //validating before trailing whitespace handling so this behaves as an appender.\n+\t\t\treturn null;\n+\t\t}\n+\t\tif(keepQuotes){\n+\t\t\tpos--;\n+\t\t\tlen+=2;\n+\t\t}\n+\t\tthis.i = i + 1;\n+\t\tString out;\n+\t\tif (len <= 0) {\n+\t\t\tout = \"\";\n+\t\t} else {\n+\t\t\tout = new String(buffer, pos, len);\n+\t\t}\n+\n+\t\tif (this.i >= length) {\n+\t\t\tupdateBuffer();\n+\t\t}\n+\t\treturn out;\n+\t}\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/CharInputReader.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/CharInputReader.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/CharInputReader.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/CharInputReader.java\n@@ -141,4 +141,22 @@\n \t * @return the {@code String} found on the input, or {@code null} if the buffer needs to reloaded or the maximum length has been exceeded.\n \t */\n \tString getString(char ch, char stop, boolean trim, String nullValue, int maxLength);\n\n+\tString getQuotedString(char quote, char escape, char escapeEscape, int maxLength, char stop1, char stop2, boolean keepQuotes, boolean keepEscape);\n }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -53,6 +54,7 @@\n \tprivate UnescapedQuoteHandling quoteHandling;\n \tprivate final String nullValue;\n \tprivate final int maxColumnLength;\n+\tprivate final String emptyValue;\n \n \t/**\n \t * The CsvParser supports all settings provided by {@link CsvParserSettings}, and requires this configuration to be properly initialized.*/\n@@ -70,6 +72,7 @@\n \t\tkeepQuotes = settings.getKeepQuotes();\n \t\tnormalizeLineEndingsInQuotes = settings.isNormalizeLineEndingsWithinQuotes();\n \t\tnullValue = settings.getNullValue();\n+\t\temptyValue = settings.getEmptyValue();\n \t\tmaxColumnLength = settings.getMaxCharsPerColumn();\n \n \n@@ -118,13 +121,29 @@\n \t\t\t\tprev = '\\0';\n \t\t\t\tif (ch == quote) {\n \t\t\t\t\toutput.trim = false;\n-\t\t\t\t\tif (normalizeLineEndingsInQuotes) {\n-\t\t\t\t\t\tparseQuotedValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tinput.enableNormalizeLineEndings(false);\n-\t\t\t\t\t\tparseQuotedValue();\n-\t\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n+\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n+\t\t\t\t\tif (output.appender.length() == 0) {\n+\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape);\n+\t\t\t\t\t\tif (value != null) {\n+\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tch = input.nextChar();\n+\t\t\t\t\t\t\t\tif (ch == delimiter) {\n+\t\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n+\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n+\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n+\t\t\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} catch (EOFException e) {\n+\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tparseQuotedValue();\n+\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n \t\t\t\t\toutput.valueParsed();\n \t\t\t\t} else if (doNotEscapeUnquotedValues) {\n \t\t\t\t\tString value = null;\n",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-36",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_198",
                "error": "java.lang.AssertionError",
                "message": "expected [;] but found [-]",
                "methodName": "testDelimiterDetection"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 17,
            "linesMod": 0,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 17
        },
        "program": "RegressionBug-36",
        "project": "RegressionBug-36",
        "repairOperators": [
            "assignRem",
            "varAdd",
            "assignAdd",
            "condBranIfElseAdd",
            "condBranIfAdd"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n@@ -178,7 +178,26 @@\n \n \t\tsums.keySet().removeAll(toRemove);\n \n-\t\tchar delimiter = max(sums, totals, suggestedDelimiter);\n+\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n+\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n+\t\tchar delimiter;\n+\t\tout:\n+\t\tif (delimiterMax != delimiterMin) {\n+\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n+\t\t\t\tdelimiter = delimiterMin;\n+\t\t\t\tbreak out;\n+\t\t\t}\n+\t\t\tif(totals.get(delimiterMin) > totals.get(delimiterMax)){\n+\t\t\t\tdelimiter = delimiterMin;\n+\t\t\t\tbreak out;\n+\t\t\t}\n+\t\t\tdelimiter = delimiterMax;\n+\t\t} else {\n+\t\t\tdelimiter = delimiterMax;\n+\t\t}\n\n \t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n \n \t\tescape.remove(delimiter);",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\t2024-09-08 01:36:15.033815029 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\t2024-09-08 01:36:15.013814889 +1000\n@@ -178,7 +178,7 @@\n \n \t\tsums.keySet().removeAll(toRemove);\n \n-\t\tchar delimiter = min(sums, totals, suggestedDelimiter);\n+\t\tchar delimiter = max(sums, totals, suggestedDelimiter);\n \t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n \n \t\tescape.remove(delimiter);",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-37",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.support.Ticket_13",
                "error": "com.univocity.parsers.common.DataProcessingException",
                "message": "Unexpected error processing input row [04, 1230, 12300104241233350010, EUR, 20180618, 20180618, 00000000012345.18] using Processor com.univocity.parsers.common.processor.BeanListProcessor.\nInternal state when error was thrown: line=1, column=0, record=1, charIndex=85, headers=[type, code, identifier, currency, first_date, second_date, amount, amount_sign], row=[04, 1230, 12300104241233350010, EUR, 20180618, 20180618, 00000000012345.18]",
                "methodName": "shouldParseFile"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-37",
        "project": "RegressionBug-37",
        "repairOperators": [
            "condExpExpand"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java\n@@ -362,7 +362,7 @@\n \t\t\t}\n \t\t}\n \n-\t\tif (row.length < readOrder.length) {\n+\t\tif (conversions != null && row.length < readOrder.length) {\n \t\t\ti = last;\n \t\t\tfor (; i < readOrder.length; i++) {\n \t\t\t\tFieldMapping field = readOrder[i];",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java\n@@ -362,6 +362,17 @@\n \t\t\t}\n \t\t}\n \n+\t\tif (row.length < readOrder.length) {\n+\t\t\ti = last;\n+\t\t\tfor (; i < readOrder.length; i++) {\n+\t\t\t\tFieldMapping field = readOrder[i];\n+\t\t\t\tif (field != null) {\n+\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n+\t\t\t\t\tfield.write(instance, value);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n\n \t\tif (missing != null) {\n \t\t\tfor (i = 0; i < missing.length; i++) {\n \t\t\t\tObject value = valuesForMissing[i];",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-38",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_178",
                "error": "java.lang.AssertionError",
                "message": "expected [|] but found [,]",
                "methodName": "testDetectionOnInputWithoutExplicitCharset"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-38",
        "project": "RegressionBug-38",
        "repairOperators": [
            "condBranIfAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java\n@@ -202,7 +202,9 @@\n \t\t\t\t\tprocess.execute(buffer, length);\n \t\t\t\t}\n \t\t\t} finally {\n+\t\t\t\tif(length > 4) {\n\t\t\t\t\tinputAnalysisProcesses = null;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/BomInput.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/BomInput.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/BomInput.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/BomInput.java\n@@ -117,25 +120,23 @@\n \t\t\t// Ensures that if the original input stream returned a byte, it will be consumed.\n \t\t\t// In case of exceptions, bytes produced prior to the exception will still be returned.\n \t\t\t// Once the last byte has been consumed, the original exception will be thrown.\n-\t\t\tif (--bytesRead == 0 && exception != null) {\n+\t\t\tif (++consumed == bytesRead && exception != null) {\n \t\t\t\tthrow exception;\n \t\t\t}\n \t\t\treturn out;\n \t\t}\n-\t\treturn input.read();\n+\t\tif (consumed == bytesRead) {\n+\t\t\tconsumed++;\n+\t\t\treturn -1;\n+\t\t}\n\n+\t\tthrow new BytesProcessedNotification(input, encoding);\n \t}\n \n \t/**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-39",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_177",
                "error": "java.lang.AssertionError",
                "message": "expected [32] but found [10]",
                "methodName": "testNewlineAfterEscapedQuote"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-39",
        "project": "RegressionBug-39",
        "repairOperators": [
            "condExpMod"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -280,7 +280,7 @@\n \t\t\t\t\tprocessQuoteEscape();\n \t\t\t\t\tprev = ch;\n \t\t\t\t\tch = input.nextChar();\n-\t\t\t\t\tif(unescaped && ch == delimiter || ch == newLine){\n+\t\t\t\t\tif(unescaped && (ch == delimiter || ch == newLine)){\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvParser.java\n@@ -41,6 +41,7 @@\n \tprivate final boolean keepEscape;\n \tprivate final boolean keepQuotes;\n \n+\tprivate boolean unescaped;\n \tprivate char prev;\n \tprivate char delimiter;\n \tprivate char quote;\n@@ -113,6 +114,7 @@\n \t\t\tif (ch == delimiter || ch == newLine) {\n \t\t\t\toutput.emptyParsed();\n \t\t\t} else {\n+\t\t\t\tunescaped = false;\n \t\t\t\tprev = '\\0';\n \t\t\t\tif (ch == quote) {\n \t\t\t\t\toutput.trim = false;\n@@ -253,9 +256,8 @@\n \t\t\tif (keepQuotes && prev == '\\0') {\n \t\t\t\toutput.appender.append(quote);\n \t\t\t}\n+\t\t\tch = input.nextChar();\n \t\t\twhile (true) {\n-\t\t\t\tch = input.nextChar();\n\n \t\t\t\tif (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n@@ -272,10 +274,16 @@\n \t\t\t\t\t\toutput.appender.append(quoteEscape);\n \t\t\t\t\t}\n \t\t\t\t\tch = output.appender.appendUntil(ch, input, quote, quoteEscape, escapeEscape);\n+\t\t\t\t\tprev = ch;\n+\t\t\t\t\tch = input.nextChar();\n \t\t\t\t} else {\n \t\t\t\t\tprocessQuoteEscape();\n+\t\t\t\t\tprev = ch;\n+\t\t\t\t\tch = input.nextChar();\n+\t\t\t\t\tif(unescaped && ch == delimiter || ch == newLine){\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tprev = ch;\n \t\t\t}\n \n \t\t\t// handles whitespaces after quoted value: whitespaces are ignored. Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-40",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.parser.XmlTreeBuilderTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<<CHECK>One<[/CHECK><TEST ID=\"1\">Check</TEST]>> but was:<<CHECK>One<[TEST ID=\"1\">Check</TEST></CHECK]>>",
                "methodName": "preservesCaseByDefault"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-40",
        "project": "RegressionBug-40",
        "repairOperators": [
            "assignExpChange",
            "mcRem",
            "mcAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/parser/XmlTreeBuilder.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -114,7 +114,7 @@\n      * @param endTag tag to close\n      */\n     private void popStackToClose(Token.EndTag endTag) {\n-        String elName = endTag.normalName();\n+        String elName = settings.normalizeTag(endTag.tagName);\n         Element firstFound = null;\n \n         for (int pos = stack.size() -1; pos >= 0; pos--) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/XmlTreeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -114,7 +114,7 @@\n      * @param endTag tag to close\n      */\n     private void popStackToClose(Token.EndTag endTag) {\n-        String elName = endTag.name();\n+        String elName = endTag.normalName();\n         Element firstFound = null;\n \n         for (int pos = stack.size() -1; pos >= 0; pos--) {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-41",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.parser.HtmlParserTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<<r> <x> A <[/x> <y> B </y]> </r>> but was:<<r> <x> A <[y> B </y> </x]> </r>>",
                "methodName": "caseInsensitiveParseTree"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-41",
        "project": "RegressionBug-41",
        "repairOperators": [
            "assignExpChange",
            "mcRem",
            "mcAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -760,7 +760,7 @@\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n+            String name = tb.settings.normalizeTag(t.asEndTag().name()); // matches with case sensitivity if enabled\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -761,7 +761,7 @@\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().normalName();\n+            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-42",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.nodes.ElementTest",
                "error": "java.lang.AssertionError",
                "message": "expected:<12> but was:<10>",
                "methodName": "doesntDeleteZWJWhenNormalizingText"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-42",
        "project": "RegressionBug-42",
        "repairOperators": [
            "retExpChange",
            "condExpRed"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/internal/StringUtil.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/internal/StringUtil.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/internal/StringUtil.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/internal/StringUtil.java\n@@ -132,8 +132,8 @@\n     }\n \n     public static boolean isInvisibleChar(int c) {\n-        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n+        return c == 8203 || c == 173;\n     }\n \n     /**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java\n@@ -128,6 +128,11 @@\n         // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n     }\n \n+    public static boolean isInvisibleChar(int c) {\n+        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n+    }\n\n     /**\n      * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n      * (e.g. newline, tab) convert to a simple space*/\n@@ -160,7 +165,7 @@\n                 accum.append(' ');\n                 lastWasWhite = true;\n             }\n-            else {\n+            else if (!isInvisibleChar(c)) {\n                 accum.appendCodePoint(c);\n                 lastWasWhite = false;\n                 reachedNonWhite = true;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-43",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.nodes.AttributeTest",
                "error": "java.lang.AssertionError",
                "message": "expected:<> but was:<null>",
                "methodName": "booleanAttributesAreEmptyStringValues"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-43",
        "project": "RegressionBug-43",
        "repairOperators": [
            "retExpChange"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/nodes/Attribute.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/nodes/Attribute.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/nodes/Attribute.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -77,7 +77,7 @@\n      @return the attribute value\n      */\n     public String getValue() {\n-        return val;\n+        return Attributes.checkNotNull(val);\n     }\n \n     /**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java\n@@ -10,8 +10,10 @@\n  * A minimal String utility class. Designed for internal jsoup use only.\n  */\n public final class StringUtil {\n-    private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\n+    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n+        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n+        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n \n     /**\n      * Join a collection of strings by a separator\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attribute.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attribute.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attribute.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -20,7 +19,8 @@\n     };\n \n     private String key;\n-    private String value;\n+    private String val;\n+    Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface\n \n     /**\n      * Create a new attribute from unencoded (raw) key and value.\n@@ -29,11 +29,21 @@\n      * @see #createFromEncoded\n      */\n     public Attribute(String key, String value) {\n+        this(key, value, null);\n+    }\n\n+    public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n-        Validate.notNull(value);\n         this.key = key.trim();\n         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n-        this.value = value;\n+        this.val = val;\n+        this.parent = parent;\n     }\n \n     /**\n@@ -50,7 +60,13 @@\n      */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key.trim();\n+        key = key.trim();\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.keys[i] = key;\n+        }\n+        this.key = key;\n     }\n \n     /**\n@@ -58,18 +74,22 @@\n      @return the attribute value\n      */\n     public String getValue() {\n-        return value;\n+        return val;\n     }\n\n-    public String setValue(String value) {\n-        Validate.notNull(value);\n-        String old = this.value;\n-        this.value = value;\n-        return old;\n+    public String setValue(String val) {\n+        String oldVal = parent.get(this.key);\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.vals[i] = val;\n+        }\n+        this.val = val;\n+        return oldVal;\n     }\n \n\n@@ -86,15 +106,19 @@\n         }\n         return accum.toString();\n     }\n-    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n+    protected static void html(String key, String val, Appendable accum, Document.OutputSettings out) throws IOException {\n         accum.append(key);\n-        if (!shouldCollapseAttribute(out)) {\n+        if (!shouldCollapseAttribute(key, val, out)) {\n             accum.append(\"=\\\"\");\n-            Entities.escape(accum, value, out, true, false, false);\n+            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);\n             accum.append('\"');\n         }\n     }\n\n+    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n+        html(key, val, accum, out);\n+    }\n \n     /**\n      Get the string representation of this attribute, implemented as {@link #html()}.\n@@ -113,10 +137,14 @@\n      */\n     public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\n         String value = Entities.unescape(encodedValue, true);\n-        return new Attribute(unencodedKey, value);\n+        return new Attribute(unencodedKey, value, null); // parent will get set when Put\n     }\n \n     protected boolean isDataAttribute() {\n+        return isDataAttribute(key);\n+    }\n\n+    protected static boolean isDataAttribute(String key) {\n         return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();\n     }\n \n@@ -127,37 +155,50 @@\n      * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n-        return (\"\".equals(value) || value.equalsIgnoreCase(key))\n-                && out.syntax() == Document.OutputSettings.Syntax.html\n-                && isBooleanAttribute();\n+        return shouldCollapseAttribute(key, val, out);\n     }\n \n+    protected static boolean shouldCollapseAttribute(String key, String val, Document.OutputSettings out) {\n+        return (val == null || \"\".equals(val) || val.equalsIgnoreCase(key))\n+            && out.syntax() == Document.OutputSettings.Syntax.html\n+            && isBooleanAttribute(key);\n+    }\n\n     protected boolean isBooleanAttribute() {\n+        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;\n+    }\n\n+    protected static boolean isBooleanAttribute(final String key) {\n         return Arrays.binarySearch(booleanAttributes, key) >= 0;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(Object o) { // note parent not considered\n         if (this == o) return true;\n-        if (!(o instanceof Attribute)) return false;\n+        if (o == null || getClass() != o.getClass()) return false;\n         Attribute attribute = (Attribute) o;\n\n         if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n-        return !(value != null ? !value.equals(attribute.value) : attribute.value != null);\n+        return val != null ? val.equals(attribute.val) : attribute.val == null;\n     }\n \n     @Override\n-    public int hashCode() {\n+    public int hashCode() { // note parent not considered\n         int result = key != null ? key.hashCode() : 0;\n-        result = 31 * result + (value != null ? value.hashCode() : 0);\n+        result = 31 * result + (val != null ? val.hashCode() : 0);\n         return result;\n     }\n \n     @Override\n     public Attribute clone() {\n         try {\n-            return (Attribute) super.clone(); // only fields are immutable strings key and value, so no more deep copy required\n+            return (Attribute) super.clone();\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attributes.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attributes.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attributes.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -29,83 +31,120 @@\n  */\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n+    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n+    private static final int GrowthFactor = 2;\n+    private static final String[] Empty = {};\n+    static final int NotFound = -1;\n+    private static final String EmptyString = \"\";\n\n+    private int size = 0; // number of slots used (not capacity, which is keys.length\n+    String[] keys = Empty;\n+    String[] vals = Empty;\n\n+    private void checkCapacity(int minNewSize) {\n+        Validate.isTrue(minNewSize >= size);\n+        int curSize = keys.length;\n+        if (curSize >= minNewSize)\n+            return;\n\n+        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n+        if (minNewSize > newSize)\n+            newSize = minNewSize;\n \n-    private LinkedHashMap<String, Attribute> attributes = null;\n+        keys = Arrays.copyOf(keys, newSize);\n+        vals = Arrays.copyOf(vals, newSize);\n+    }\n\n+    int indexOfKey(String key) {\n+        Validate.notNull(key);\n+        for (int i = 0; i < size; i++) {\n+            if (key.equals(keys[i]))\n+                return i;\n+        }\n+        return NotFound;\n+    }\n\n+    static final String checkNotNull(String val) {\n+        return val == null ? EmptyString : val;\n+    }\n\n     public String get(String key) {\n-        Validate.notEmpty(key);\n-        if (attributes == null)\n-            return \"\";\n-        Attribute attr = attributes.get(key);\n-        return attr != null ? attr.getValue() : \"\";\n+        int i = indexOfKey(key);\n+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n     }\n\n \n-    private Attribute getAttributeIgnoreCase(String key) {\n-        Validate.notEmpty(key);\n-        if (attributes == null)\n-            return null;\n-        Attribute attr = attributes.get(key);\n-        if (attr != null)\n-            return attr;\n-        for (String attrKey : attributes.keySet()) {\n-            if (attrKey.equalsIgnoreCase(key))\n-                return attributes.get(attrKey);\n-        }\n-        return null;\n\n+    private void add(String key, String value) {\n+        checkCapacity(size + 1);\n+        keys[size] = key;\n+        vals[size] = value;\n+        size++;\n     }\n \n     public Attributes put(String key, String value) {\n-        Attribute attr = new Attribute(key, value);\n-        put(attr);\n+        int i = indexOfKey(key);\n+        if (i != NotFound)\n+            vals[i] = value;\n+        else\n+            add(key, value);\n         return this;\n     }\n \n@@ -191,31 +228,49 @@ \n     public Iterator<Attribute> iterator() {\n-        if (attributes == null || attributes.isEmpty()) {\n-            return Collections.<Attribute>emptyList().iterator();\n-        }\n+        return new Iterator<Attribute>() {\n+            int i = 0;\n \n-        return attributes.values().iterator();\n+            @Override\n+            public boolean hasNext() {\n+                return i < size;\n+            }\n\n+            @Override\n+            public Attribute next() {\n+                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n+                i++;\n+                return attr;\n+            }\n\n+            @Override\n+            public void remove() {\n+                Attributes.this.remove(--i); // next() advanced, so rewind\n+            }\n+        };\n     }\n \n@@ -281,31 +346,40 @@ \n-    private class Dataset extends AbstractMap<String, String> {\n+    public void normalize() {\n+        for (int i = 0; i < size; i++) {\n+            keys[i] = lowerCase(keys[i]);\n+        }\n+    }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/ParseSettings.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/ParseSettings.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/ParseSettings.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/ParseSettings.java\n@@ -52,9 +51,7 @@\n \n     Attributes normalizeAttributes(Attributes attributes) {\n         if (!preserveAttributeCase) {\n-            for (Attribute attr : attributes) {\n-                attr.setKey(lowerCase(attr.getKey()));\n-            }\n+            attributes.normalize();\n         }\n         return attributes;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Token.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Token.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Token.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Token.java\n@@ -107,15 +105,14 @@\n                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                 pendingAttributeName = pendingAttributeName.trim();\n                 if (pendingAttributeName.length() > 0) {\n-                    Attribute attribute;\n+                    String value;\n                     if (hasPendingAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName,\n-                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                     else if (hasEmptyAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName, \"\");\n+                        value = \"\";\n                     else\n-                        attribute = new BooleanAttribute(pendingAttributeName);\n-                    attributes.put(attribute);\n+                        value = null;\n+                    attributes.put(pendingAttributeName, value);\n                 }\n             }\n             pendingAttributeName = null;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-44",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_1700.Issue1723",
                "error": "junit.framework.AssertionFailedError",
                "message": "expected:<0.9390308> but was:<-1.1075817>",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-44",
        "project": "RegressionBug-44",
        "repairOperators": [
            "condExpMod"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n@@ -2472,7 +2472,7 @@\n                 count = bp + offset - start - 1;\n             }\n \n-            if (!exp && count < 20) {\n+            if (!exp && count < 18) {\n                 value = ((float) intVal) / power;\n                 if (negative) {\n                     value = -value;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n@@ -2295,23 +2295,41 @@\n         int offset = fieldName.length;\n         char chLocal = charAt(bp + (offset++));\n \n+        final boolean quote = chLocal == '\"';\n+        if (quote) {\n+            chLocal = charAt(bp + (offset++));\n+        }\n\n+        boolean negative = chLocal == '-';\n+        if (negative) {\n+            chLocal = charAt(bp + (offset++));\n+        }\n\n         float value;\n         if (chLocal >= '0' && chLocal <= '9') {\n+            int intVal = chLocal - '0';\n             for (;;) {\n                 chLocal = charAt(bp + (offset++));\n                 if (chLocal >= '0' && chLocal <= '9') {\n+                    intVal = intVal * 10 + (chLocal - '0');\n                     continue;\n                 } else {\n                     break;\n                 }\n             }\n \n-            if (chLocal == '.') {\n+            int power = 1;\n+            boolean small = (chLocal == '.');\n+            if (small) {\n                 chLocal = charAt(bp + (offset++));\n                 if (chLocal >= '0' && chLocal <= '9') {\n+                    intVal = intVal * 10 + (chLocal - '0');\n+                    power *= 10;\n                     for (;;) {\n                         chLocal = charAt(bp + (offset++));\n                         if (chLocal >= '0' && chLocal <= '9') {\n+                            intVal = intVal * 10 + (chLocal - '0');\n+                            power *= 10;\n                             continue;\n                         } else {\n                             break;\n@@ -2323,10 +2341,45 @@\n                 }\n             }\n \n-            int start = bp + fieldName.length;\n-            int count = bp + offset - start - 1;\n-            String text = this.subString(start, count);\n-            value = Float.parseFloat(text);\n+            boolean exp = chLocal == 'e' || chLocal == 'E';\n+            if (exp) {\n+                chLocal = charAt(bp + (offset++));\n+                if (chLocal == '+' || chLocal == '-') {\n+                    chLocal = charAt(bp + (offset++));\n+                }\n+                for (;;) {\n+                    if (chLocal >= '0' && chLocal <= '9') {\n+                        chLocal = charAt(bp + (offset++));\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n\n+            int start, count;\n+            if (quote) {\n+                if (chLocal != '\"') {\n+                    matchStat = NOT_MATCH;\n+                    return 0;\n+                } else {\n+                    chLocal = charAt(bp + (offset++));\n+                }\n+                start = bp + fieldName.length + 1;\n+                count = bp + offset - start - 2;\n+            } else {\n+                start = bp + fieldName.length;\n+                count = bp + offset - start - 1;\n+            }\n\n+            if (!exp && count < 20) {\n+                value = ((float) intVal) / power;\n+                if (negative) {\n+                    value = -value;\n+                }\n+            } else {\n+                String text = this.subString(start, count);\n+                value = Float.parseFloat(text);\n+            }\n         } else {\n             matchStat = NOT_MATCH;\n             return 0;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-45",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.bug.Bug_for_rd",
                "error": "junit.framework.ComparisonFailure",
                "message": "expected:<[]{\"saveAsset\":\"false\"...> but was:<[\"]{\"saveAsset\":\"false\"...>",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 9,
            "classes": 1,
            "files": 1,
            "linesAdd": 6,
            "linesMod": 4,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 10
        },
        "program": "RegressionBug-45",
        "project": "RegressionBug-45",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "assignExpChange",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\t2024-09-08 01:36:15.985821697 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\t2024-09-08 01:36:15.845820716 +1000\n@@ -946,13 +946,16 @@\n         int startPos = this.bp;\n         char startChar = this.ch;\n \n+        int spaceCount = 0;\n         for (;;) {\n             if (!charArrayCompare(text, bp, fieldName)) {\n                 if (isWhitespace(ch)) {\n                     next();\n+                    spaceCount++;\n \n                     while (isWhitespace(ch)) {\n                         next();\n+                        spaceCount++;\n                     }\n                     continue;\n                 }\n@@ -963,7 +966,7 @@\n             }\n         }\n \n-        int index = bp + fieldName.length;\n+        int index = bp + fieldName.length + spaceCount;\n \n         char ch = charAt(index++);\n         if (ch != '\"') {\n@@ -1003,8 +1006,8 @@\n                     endIndex = indexOf('\"', endIndex + 1);\n                 }\n \n-                int chars_len = endIndex - (bp + fieldName.length + 1);\n+                int chars_len = endIndex - (bp + fieldName.length + 1 + spaceCount);\n-                char[] chars = sub_chars(bp + fieldName.length + 1, chars_len);\n+                char[] chars = sub_chars(bp + fieldName.length + 1 + spaceCount, chars_len);\n \n                 stringVal = readString(chars, chars_len);\n             }\n@@ -1178,13 +1181,16 @@\n     public long scanFieldSymbol(char[] fieldName) {\n         matchStat = UNKNOWN;\n \n+        int spaceCount = 0;\n         for (;;) {\n             if (!charArrayCompare(text, bp, fieldName)) {\n                 if (isWhitespace(ch)) {\n                     next();\n+                    spaceCount++;\n \n                     while (isWhitespace(ch)) {\n                         next();\n+                        spaceCount++;\n                     }\n                     continue;\n                 }\n@@ -1195,7 +1201,7 @@\n             }\n         }\n \n-        int index = bp + fieldName.length;\n+        int index = bp + fieldName.length + spaceCount;\n \n         char ch = charAt(index++);\n         if (ch != '\"') {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n@@ -950,6 +950,10 @@\n             if (!charArrayCompare(text, bp, fieldName)) {\n                 if (isWhitespace(ch)) {\n                     next();\n+\n+                    while (isWhitespace(ch)) {\n+                        next();\n+                    }\n                     continue;\n                 }\n                 matchStat = NOT_MATCH_NAME;\n@@ -963,9 +967,15 @@\n \n         char ch = charAt(index++);\n         if (ch != '\"') {\n-            matchStat = NOT_MATCH;\n+            while (isWhitespace(ch)) {\n+                ch = charAt(index++);\n+            }\n+\n+            if (ch != '\"') {\n+                matchStat = NOT_MATCH;\n \n-            return stringDefaultValue();\n+                return stringDefaultValue();\n+            }\n         }\n \n         final String strVal;\n@@ -1168,17 +1178,36 @@\n     public long scanFieldSymbol(char[] fieldName) {\n         matchStat = UNKNOWN;\n \n-        if (!charArrayCompare(text, bp, fieldName)) {\n-            matchStat = NOT_MATCH_NAME;\n-            return 0;\n+        for (;;) {\n+            if (!charArrayCompare(text, bp, fieldName)) {\n+                if (isWhitespace(ch)) {\n+                    next();\n+\n+                    while (isWhitespace(ch)) {\n+                        next();\n+                    }\n+                    continue;\n+                }\n+                matchStat = NOT_MATCH_NAME;\n+                return 0;\n+            } else {\n+                break;\n+            }\n         }\n \n         int index = bp + fieldName.length;\n \n         char ch = charAt(index++);\n         if (ch != '\"') {\n-            matchStat = NOT_MATCH;\n-            return 0;\n+            while (isWhitespace(ch)) {\n+                ch = charAt(index++);\n+            }\n+\n+            if (ch != '\"') {\n+                matchStat = NOT_MATCH;\n+\n+                return 0;\n+            }\n         }\n \n         long hash = 0xcbf29ce484222325L;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-46",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.ref.RefTest24",
                "error": "junit.framework.ComparisonFailure",
                "message": "expected:<...igs\":{\"23299685@47\":[{\"$ref\":\"$.com\\\\.alibaba\\\\.extAppConfigs.23299685\\\\@47\"}]}}> but was:<...igs\":{\"23299685@47\":[null]}}>",
                "methodName": "test_ref"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 3,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 3
        },
        "program": "RegressionBug-46",
        "project": "RegressionBug-46",
        "repairOperators": [
            "assignAdd",
            "condBranIfAdd",
            "mcAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSONPath.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSONPath.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSONPath.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSONPath.java\n@@ -1566,6 +1566,10 @@\n             }\n             \n             String text = path.substring(start, end);\n\n+            if (text.indexOf(\"\\\\@\") != -1) {\n+                text = text.replaceAll(\"\\\\\\\\@\", \"@\");\n+            }\n             \n             if (text.indexOf(\"\\\\.\") != -1) {\n                 String propName;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -655,6 +655,17 @@\n                                     parser.resolveStatus = DefaultJSONParser.NeedToResolve;\n                                 }\n                             } else {\n+                                if (ref.indexOf('\\\\') > 0) {\n+                                    StringBuilder buf = new StringBuilder();\n+                                    for (int i = 0; i < ref.length(); ++i) {\n+                                        char ch = ref.charAt(i);\n+                                        if (ch == '\\\\') {\n+                                            ch = ref.charAt(++i);\n+                                        }\n+                                        buf.append(ch);\n+                                    }\n+                                    ref = buf.toString();\n+                                }\n                                 Object refObj = parser.resolveReference(ref);\n                                 if (refObj != null) {\n                                     object = refObj;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/serializer/JSONSerializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/serializer/JSONSerializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/serializer/JSONSerializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/serializer/JSONSerializer.java\n@@ -183,7 +183,8 @@\n             out.write(\"{\\\"$ref\\\":\\\"$\\\"}\");\n         } else {\n             out.write(\"{\\\"$ref\\\":\\\"\");\n-            out.write(references.get(object).toString());\n+            String path = references.get(object).toString();\n+            out.write(path);\n             out.write(\"\\\"}\");\n         }\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/serializer/SerialContext.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/serializer/SerialContext.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/serializer/SerialContext.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/serializer/SerialContext.java\n@@ -18,12 +18,52 @@\n         if (parent == null) {\n             return \"$\";\n         } else {\n-            if (fieldName instanceof Integer) {\n-                return parent.toString() + \"[\" + fieldName + \"]\";\n+            StringBuilder buf = new StringBuilder();\n+            toString(buf);\n+            return buf.toString();\n+        }\n+    }\n\n+    protected void toString(StringBuilder buf) {\n+        if (parent == null) {\n+            buf.append('$');\n+        } else {\n+            parent.toString(buf);\n+            if (fieldName == null) {\n+                buf.append(\".null\");\n+            } else if (fieldName instanceof Integer) {\n+                buf.append('[');\n+                buf.append(((Integer)fieldName).intValue());\n+                buf.append(']');\n             } else {\n-                return parent.toString() + \".\" + fieldName;\n-            }\n+                buf.append('.');\n \n+                String fieldName = this.fieldName.toString();\n+                boolean special = false;\n+                for (int i = 0; i < fieldName.length(); ++i) {\n+                    char ch = fieldName.charAt(i);\n+                    if (ch == '.' || ch == '@' || ch == '(' || ch == '\\\\') {\n+                        special = true;\n+                    }\n+                }\n\n+                if (special) {\n+                    for (int i = 0; i < fieldName.length(); ++i) {\n+                        char ch = fieldName.charAt(i);\n+                        if (ch == '.' || ch == '@' || ch == '(') {\n+                            buf.append('\\\\');\n+                            buf.append('\\\\');\n+                        } else if (ch == '\\\\') {\n+                            buf.append('\\\\');\n+                            buf.append('\\\\');\n+                            buf.append('\\\\');\n+                        }\n+                        buf.append(ch);\n+                    }\n+                } else {\n+                    buf.append(fieldName);\n+                }\n+            }\n         }\n     }",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-47",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.bug.bug2020.Bug_for_money",
                "error": "junit.framework.ComparisonFailure",
                "message": "expected:<[USD]> but was:<[CNY]>",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-47",
        "project": "RegressionBug-47",
        "repairOperators": [
            "condExpExpand"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -1370,7 +1370,7 @@\n                     continue;\n                 }\n \n-                if (field != null) {\n+                if (field != null && fieldInfo.method == null) {\n                     Class fieldType = field.getType();\n                     if (fieldType == boolean.class) {\n                         if (value == Boolean.FALSE) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -1284,12 +1284,59 @@\n                 }\n \n                 final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n+                Field field = fieldDeser.fieldInfo.field;\n                 Type paramType = fieldInfo.fieldType;\n\n+                if (paramType == boolean.class) {\n+                    if (value == Boolean.FALSE) {\n+                        field.setBoolean(object, false);\n+                        continue;\n+                    }\n+                    if (value == Boolean.TRUE) {\n+                        field.setBoolean(object, true);\n+                        continue;\n+                    }\n+                } else if (paramType == int.class) {\n+                    if (value instanceof Number) {\n+                        field.setInt(object, ((Number) value).intValue());\n+                        continue;\n+                    }\n+                } else if (paramType == long.class) {\n+                    if (value instanceof Number) {\n+                        field.setLong(object, ((Number) value).longValue());\n+                        continue;\n+                    }\n+                } else if (paramType == float.class) {\n+                    if (value instanceof Number) {\n+                        field.setFloat(object, ((Number) value).floatValue());\n+                        continue;\n+                    }\n+                } else if (paramType == double.class) {\n+                    if (value instanceof Number) {\n+                        field.setDouble(object, ((Number) value).doubleValue());\n+                        continue;\n+                    } else if (value instanceof String) {\n+                        double doubleValue = Double.parseDouble((String) value);\n+                        field.setDouble(object, doubleValue);\n+                        continue;\n+                    }\n+                } else if (value != null && paramType == value.getClass()) {\n+                    field.set(object, value);\n+                    continue;\n+                }\n\n                 String format = fieldInfo.format;\n                 if (format != null && paramType == java.util.Date.class) {",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-48",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.apache.commons.jexl3.Issues200Test",
                "error": "java.lang.AssertionError",
                "message": "should have thrown",
                "methodName": "test275a"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-48",
        "project": "RegressionBug-48",
        "repairOperators": [
            "condBranRem",
            "mcRem"
        ],
        "repairTools": [
            "rtIncoder1B",
            "rtIncoder6B"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/InterpreterBase.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/InterpreterBase.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/InterpreterBase.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/InterpreterBase.java\n@@ -292,9 +292,7 @@\n         if (value == null\n             && !(identifier.jjtGetParent() instanceof ASTReference)\n             && !(context.has(name))) {\n-                return isSafe() ? null : unsolvableVariable(identifier, name, true); // undefined\n+                return unsolvableVariable(identifier, name, true); // undefined\n         }\n         return value;\n     }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n@@ -1002,20 +1003,18 @@\n         String name = node.getName();\n         if (data == null) {\n             int symbol = node.getSymbol();\n-            if (symbol >= 0) {\n-                if (frame.has(symbol)) {\n-                    return frame.get(symbol);\n-                } else if (node instanceof ASTVar) {\n-                    return null;\n-                }\n+            if (symbol >= 0 && frame.has(symbol)) {\n+                return frame.get(symbol);\n             }\n             Object value = context.get(name);\n             if (value == null\n                     && !(node.jjtGetParent() instanceof ASTReference)\n                     && !(context.has(name))\n                     && !node.isTernaryProtected()) {\n-                return unsolvableVariable(node, name, true);\n+                return jexl.safe ? null : unsolvableVariable(node, name, !(node.getSymbol() >= 0 || context.has(name)));\n             }\n             return value;\n         } else {",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-49",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.apache.commons.jexl3.FinalVarTest",
                "error": "java.lang.AssertionError",
                "message": "Should have failed",
                "methodName": "testRedefinedPointer"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 2,
            "files": 2,
            "linesAdd": 12,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 12
        },
        "program": "RegressionBug-49",
        "project": "RegressionBug-49",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "mcAdd",
            "condBranIfElseAdd",
            "exThrowsAdd",
            "objInstAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n@@ -817,7 +817,13 @@\n \n         @Override\n         public void set(Object value) {\n-            executeAssign(node, node, value, null, null);\n+            int symbol = node.getSymbol();\n+            boolean isFinal = frame.getScope().isVariableFinal(symbol);\n+            if (!isFinal) {\n+                executeAssign(node, node, value, null, null);\n+            } else {\n+                throw new JexlException(node, \"can not assign a value to the final variable\", null);\n+            }\n         }\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/Scope.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n@@ -273,6 +273,12 @@\n                 }\n                 variableTypes.put(register, type);\n             }\n+            if (isFinal) {\n+                if (finalVariables == null) {\n+                    finalVariables = new HashSet<Integer>();\n+                }\n+                finalVariables.add(register);\n+            }\n         }\n         return register;\n     }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Debugger.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Debugger.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Debugger.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Debugger.java\n@@ -572,6 +573,11 @@\n     }\n \n     @Override\n+    protected Object visit(ASTInitialization node, Object data) {\n+        return infixChildren(node, \" = \", false, data);\n+    }\n\n+    @Override\n     protected Object visit(ASTMultipleAssignment node, Object data) {\n         int num = node.jjtGetNumChildren();\n         boolean isVarDeclare = node.jjtGetChild(0) instanceof ASTExtVar;\n@@ -1488,6 +1494,10 @@\n \n     @Override\n     protected Object visit(ASTVar node, Object data) {\n+        boolean isFinal = node.isFinal();\n+        if (isFinal) {\n+           builder.append(\"final \");\n+        }\n         Class type = node.getType();\n         if (type == null) {\n            builder.append(\"var \");\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n@@ -888,7 +913,7 @@\n             } else {\n                 int symbol = var.getSymbol();\n                 if (symbol >= 0) {\n-                    return new VarPointer(symbol);\n+                    return var.isFinal() ? new FinalVarPointer(symbol) : new VarPointer(symbol);\n                 } else {\n                     return new ContextVarPointer(var.getName());\n                 }\n@@ -2342,6 +2367,13 @@\n     }\n \n     @Override\n+    protected Object visit(ASTInitialization node, Object data) {\n+        JexlNode left = node.jjtGetChild(0);\n+        Object right = node.jjtGetChild(1).jjtAccept(this, data);\n+        return executeAssign(node, left, right, null, data);\n+    }\n\n+    @Override\n     protected Object visit(ASTAssignment node, Object data) {\n         JexlNode left = node.jjtGetChild(0);\n         Object right = node.jjtGetChild(1).jjtAccept(this, data);\n@@ -2533,8 +2565,8 @@\n                 Object self = left.jjtGetChild(0).jjtAccept(this, data);\n                 if (self == null)\n                     throw new JexlException(left, \"illegal assignment form *0\");\n-                if (self instanceof Pointer) {\n-                    ((Pointer) self).set(right);\n+                if (self instanceof SetPointer) {\n+                    ((SetPointer) self).set(right);\n                 } else {\n                     Object result = operators.indirectAssign(node, self, right);\n                     if (result == JexlEngine.TRY_FAILED)\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Scope.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n@@ -53,11 +55,14 @@\n     /**\n      * The set of final variables.\n      */\n+    private Set<Integer> finalVariables = null;\n     /**\n      * The empty string array.\n      */\n@@ -167,11 +172,20 @@\n+    public boolean isVariableFinal(int symbol) {\n+        return finalVariables == null ? false : finalVariables.contains(symbol);\n     }\n \n     /**\n@@ -223,7 +237,7 @@\n      * @param name the variable class\n      * @return the register index storing this variable\n      */\n-    public Integer declareVariable(String name, Class type) {\n+    public Integer declareVariable(String name, Class type, boolean isFinal) {\n         if (namedVariables == null) {\n             namedVariables = new LinkedHashMap<String, Integer>();\n         }\n@@ -238,6 +252,12 @@\n                 }\n                 variableTypes.put(register, type);\n             }\n+            if (isFinal) {\n+                if (finalVariables == null) {\n+                    finalVariables = new HashSet<Integer>();\n+                }\n+                finalVariables.add(register);\n+            }\n         }\n         return register;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifier.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifier.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifier.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifier.java\n@@ -22,6 +22,7 @@\n public class ASTIdentifier extends JexlNode {\n     protected String name = null;\n     protected int symbol = -1;\n+    protected boolean isFinal;\n \n     ASTIdentifier(int id) {\n         super(id);\n@@ -55,6 +56,14 @@\n     public String getName() {\n         return name;\n     }\n\n+    public boolean isFinal() {\n+        return isFinal;\n+    }\n\n+    void setFinal() {\n+        isFinal = true;\n+    }\n     \n     public String getNamespace() {\n         return null;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/FeatureController.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/FeatureController.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/FeatureController.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/FeatureController.java\n@@ -232,6 +232,11 @@\n     }\n \n     @Override\n+    protected Object visit(ASTInitialization node, Object data) {\n+        return controlSideEffect(node, data);\n+    }\n\n+    @Override\n     protected Object visit(ASTMultipleAssignment node, Object data) {\n         return controlSideEffect(node, data);\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java\n@@ -146,7 +146,7 @@\n     public boolean isLeftValue() {\n         JexlNode walk = this;\n         do {\n-            if (walk instanceof ASTIdentifier\n+            if (walk instanceof ASTIdentifier && !((ASTIdentifier) walk).isFinal()\n                 || walk instanceof ASTIdentifierAccess\n                 || walk instanceof ASTArrayAccess\n                 || walk instanceof ASTIndirectNode) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java\n@@ -183,6 +183,21 @@\n     * @param image      the identifier image\n     * @return true if final, false otherwise\n     */\n+    protected boolean isFinalVariable(String image) {\n+        if (frame != null) {\n+            Integer register = frame.getSymbol(image);\n+            if (register != null) {\n+                return frame.isVariableFinal(register);\n+            }\n+        }\n+        return false;\n+    }\n\n     protected boolean allowVariable(String image) {\n         JexlFeatures features = getFeatures();\n         if (!features.supportsLocalVar()) {\n@@ -208,7 +223,7 @@\n         if (frame == null) {\n             frame = new Scope(null, (String[]) null);\n         }\n-        Integer register = frame.declareVariable(identifier, var.getType());\n+        Integer register = frame.declareVariable(identifier, var.getType(), var.isFinal());\n         var.setSymbol(register.intValue(), identifier);\n     }\n ",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-50",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.apache.commons.jexl3.ExceptionTest",
                "error": "java.lang.AssertionError",
                "message": "",
                "methodName": "testExVar"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 5,
            "linesMod": 2,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 7
        },
        "program": "RegressionBug-50",
        "project": "RegressionBug-50",
        "repairOperators": [
            "condExpRed",
            "assignRem",
            "assignAdd",
            "mcRem",
            "condBranIfAdd",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/Scope.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n@@ -397,11 +395,16 @@\n          * @return this frame\n          */\n         public Frame assign(Object... values) {\n-            if (stack != null && values != null && values.length > 0) {\n+            if (stack != null) {\n                 int nparm = scope.getArgCount();\n                 Object[] copy = stack.clone();\n-                int ncopy = Math.min(nparm - curried, Math.min(nparm, values.length));\n-                System.arraycopy(values, 0, copy, curried, ncopy);\n+                int ncopy = 0;\n+                if (values != null && values.length > 0) {\n+                    ncopy = Math.min(nparm - curried, Math.min(nparm, values.length));\n+                    System.arraycopy(values, 0, copy, curried, ncopy);\n+                }\n+                Arrays.fill(copy, curried + ncopy, nparm, null);\n                 return new Frame(scope, copy, curried + ncopy);\n             }\n             return this;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java\n@@ -981,23 +981,34 @@    \n+    @Override\n     protected Object visit(ASTIdentifier node, Object data) {\n         cancelCheck(node);\n         String name = node.getName();\n         if (data == null) {\n             int symbol = node.getSymbol();\n             if (symbol >= 0) {\n-                return frame.get(symbol);\n+                if (frame.has(symbol)) {\n+                    return frame.get(symbol);\n+                } else if (node instanceof ASTVar) {\n+                    return null;\n+                }\n             }\n             Object value = context.get(name);\n             if (value == null\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Scope.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/Scope.java\n@@ -19,12 +19,22 @@\n     /**\n      * The value of a declared but undefined variable, for instance: var x;.\n      */\n+    private static final Object UNDEFINED = new Object() {\n+        @Override public String toString() {\n+            return \"?\";\n+        }\n+    };\n     /**\n      * The parent scope.\n      */\n@@ -199,6 +209,7 @@\n     public Frame createFrame(Frame frame) {\n         if (namedVariables != null) {\n             Object[] arguments = new Object[namedVariables.size()];\n+            Arrays.fill(arguments, UNDEFINED);\n             if (frame != null && hoistedVariables != null && parent != null) {\n                 for (Map.Entry<Integer, Integer> hoist : hoistedVariables.entrySet()) {\n                     Integer target = hoist.getKey();\n@@ -361,7 +372,16 @@\n         * @param s the offset in this frame\n         * @return true if this symbol has been assigned a value, false otherwise\n         */\n+        public boolean has(int s) {\n+            return s >= 0 && s < stack.length && stack[s] != UNDEFINED;\n+        }\n\n         /**\n          * Sets a value.\n          * @param r the offset in this frame\n@@ -378,8 +398,9 @@\n          */\n         public Frame assign(Object... values) {\n             if (stack != null && values != null && values.length > 0) {\n+                int nparm = scope.getArgCount();\n                 Object[] copy = stack.clone();\n-                int ncopy = Math.min(copy.length - curried, values.length);\n+                int ncopy = Math.min(nparm - curried, Math.min(nparm, values.length));\n                 System.arraycopy(values, 0, copy, curried, ncopy);\n                 return new Frame(scope, copy, curried + ncopy);\n             }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-51",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.apache.commons.jexl3.JXLTTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<if ($A) {\n[$$   $B + 1;\n} else {\n$$ ]  $C - 2;\n}> but was:<if ($A) {\n[  $B + 1;\n} else {\n]  $C - 2;\n}>",
                "methodName": "testInheritedDebugger"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 3,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 4
        },
        "program": "RegressionBug-51",
        "project": "RegressionBug-51",
        "repairOperators": [
            "varTyChange",
            "condBranIfAdd",
            "retBranchAdd",
            "mcAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java\n@@ -104,9 +104,9 @@\n \n     @Override\n     protected Object visit(ASTBlock node, Object data) {\n         // if not really a template, must use super impl\n         if (exprs == null) {\n-            return super.visit(node, data);\n+            return super.visit((ASTBlock) node, data);\n         }\n         // open the block\n         builder.append('{');\n@@ -138,8 +138,13 @@\n \n     @Override\n     protected Object acceptStatement(JexlNode child, Object data) {\n         // if not really a template, must use super impl\n+        if (exprs == null) {\n+            return super.acceptStatement(child, data);\n+        }\n         TemplateExpression te = getPrintStatement(child);\n         if (te != null) {\n             // if statement is a jexl:print(...), may need to prepend '\\n'\n             newJxltLine();\n             return visit(te, data);\n         } else {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/apache/commons/jexl3/internal/TemplateDebugger.java\n@@ -148,46 +138,15 @@\n \n     @Override\n     protected Object acceptStatement(JexlNode child, Object data) {\n-        // if not really a template, use super impl\n-        if (exprs != null) {\n-            int printe = getPrintStatement(child);\n-            if (printe >= 0) {\n-                // statement is an expr\n-                TemplateExpression te = exprs[printe];\n-                return visit(te, data);\n-            }\n-            // if statement is not a jexl:print(...), need to prepend '$$'\n-            newJexlLine();\n-        }\n-        return super.acceptStatement(child, data);\n-    }\n-\n-    /**\n-     * Recreate a statement from an expression node.\n-     * @param child the template expression\n-     * @param lastSeen the state before this child node \n-     * @return the new state after the child node\n-     */\n-    private Type debugStatement(JexlNode child, Type lastSeen) {\n-        // if not really a template, use super impl\n-        Type t = Type.EXPR_LINE;\n-        if (exprs != null) {\n-            int printe = getPrintStatement(child);\n-            if (printe >= 0) {\n-                if (Type.TMPL_LINE == lastSeen && (builder.charAt(builder.length() - 1) != '\\n')) {\n-                    builder.append('\\n');\n-                }\n-                // statement is an expr\n-                TemplateExpression te = exprs[printe];\n-                visit(te, null);\n-                return t;\n-            }\n+        TemplateExpression te = getPrintStatement(child);\n+        if (te != null) {\n+            newJxltLine();\n+            return visit(te, data);\n+        } else {\n             // if statement is not a jexl:print(...), need to prepend '$$'\n             newJexlLine();\n-            t = Type.TMPL_LINE;\n+            return super.acceptStatement(child, data);\n         }\n-        super.acceptStatement(child, null);\n-        return t;\n     }\n \n     /**\n@@ -195,8 +154,8 @@\n      * @param child the node to check\n      * @return the expression number or -1 if the node is not a jexl:print\n      */\n-    private int getPrintStatement(JexlNode child) {\n-        if (child instanceof ASTFunctionNode) {\n+    private TemplateExpression getPrintStatement(JexlNode child) {\n+        if (exprs != null && child instanceof ASTFunctionNode) {\n             ASTFunctionNode node = (ASTFunctionNode) child;\n             ASTIdentifier ns = (ASTIdentifier) node.jjtGetChild(0);\n             JexlNode args = node.jjtGetChild(1);\n@@ -206,12 +165,12 @@\n                 && args.jjtGetChild(0) instanceof ASTNumberLiteral) {\n                 ASTNumberLiteral exprn = (ASTNumberLiteral) args.jjtGetChild(0);\n                 int n = exprn.getLiteral().intValue();\n-                if (exprs != null && n >= 0 && n < exprs.length) {\n-                    return n;\n+                if (n >= 0 && n < exprs.length) {\n+                    return exprs[n];\n                 }\n             }\n         }\n-        return -1;\n+        return null;\n     }\n\n@@ -224,21 +183,39 @@\n         } else {\n             for (int i = length - 1; i >= 0; --i) {\n                 char c = builder.charAt(i);\n-                if (c == '\\n') {\n-                    builder.append(\"$$ \");\n-                    break;\n-                }\n-                if (c == '}') {\n-                    builder.append(\"\\n$$ \");\n-                    break;\n-                }\n-                if (c != ' ') {\n-                    break;\n+                switch (c) {\n+                    case '\\n':\n+                        builder.append(\"$$ \");\n+                        return;\n+                    case '}':\n+                        builder.append(\"\\n$$ \");\n+                        return;\n+                    case ' ':\n+                    case ';':\n+                        return;\n                 }\n             }\n         }\n     }\n\n    \n     /**\n      * Insert \\n when needed.\n      */",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-52",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.yahoo.sketches.theta.DirectUnionTest",
                "error": "java.lang.AssertionError",
                "message": "expected [true] but found [false]",
                "methodName": "checkForDruidBug"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 9,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 9
        },
        "program": "RegressionBug-52",
        "project": "RegressionBug-52",
        "repairOperators": [
            "condBranIfAdd",
            "objInstAdd",
            "mcAdd",
            "mcParAdd",
            "condBranIfElseAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/yahoo/sketches/theta/UnionImpl.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n@@ -301,6 +301,15 @@\n       }\n     }\n     unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //Theta rule with gadget\n+    if (gadget_.hasMemory()) {\n+      final WritableMemory wmem = (WritableMemory)gadget_.getMemory();\n+      PreambleUtil.insertUnionThetaLong(wmem, unionThetaLong_);\n+      if (unionEmpty_) {\n+        PreambleUtil.setEmpty(wmem);\n+      } else {\n+        PreambleUtil.clearEmpty(wmem);\n+      }\n+    }\n   }\n \n   @Override",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java\n@@ -77,10 +77,11 @@\n    * @return a CompactSketch\n    */\n   static CompactSketch compact(final UpdateSketch sketch) {\n-    final long thetaLong = sketch.getThetaLong();\n-    final boolean empty = sketch.isEmpty();\n     final int curCount = sketch.getRetainedEntries(true);\n\n+    long thetaLong = sketch.getThetaLong();\n+    boolean empty = sketch.isEmpty();\n+    thetaLong = thetaOnCompact(empty, curCount, thetaLong);\n+    empty = emptyOnCompact(curCount, thetaLong);\n     final short seedHash = sketch.getSeedHash();\n     final long[] cache = sketch.getCache();\n     final boolean ordered = true;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/SetOperation.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/SetOperation.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/SetOperation.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/SetOperation.java\n@@ -222,14 +224,12 @@\n   abstract boolean isEmpty();\n \n   //used only by the set operations\n-  static final CompactSketch createCompactSketch(final long[] compactCache, final boolean empty,\n-      final short seedHash, int curCount, long thetaLong, final boolean dstOrdered,\n+  static final CompactSketch createCompactSketch(final long[] compactCache, boolean empty,\n+      final short seedHash, final int curCount, long thetaLong, final boolean dstOrdered,\n       final WritableMemory dstMem) {\n-    if (empty) {\n-      curCount = 0;\n-      thetaLong = Long.MAX_VALUE;\n-    }\n+    thetaLong = thetaOnCompact(empty, curCount, thetaLong);\n+    empty = emptyOnCompact(curCount, thetaLong);\n\n     CompactSketch sketchOut = null;\n     final int sw = (dstOrdered ? 2 : 0) | ((dstMem != null) ? 1 : 0);\n     switch (sw) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/Sketch.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/Sketch.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/Sketch.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/Sketch.java\n@@ -557,40 +557,31 @@\n    * <p>emptyOnCompact() corrects for #1, 2, 6 if they occur\n    * <p>First apply thetaOnCompact() then emptyOnCompact().\n    */\n+  static final long thetaOnCompact(final boolean empty, final int curCount, final long thetaLong) {\n+    return (empty && (curCount == 0) && (thetaLong < Long.MAX_VALUE)) ? Long.MAX_VALUE : thetaLong;\n+  }\n\n+  static final boolean emptyOnCompact(final int curCount, final long thetaLong) {\n+    return ((curCount == 0) && (thetaLong == Long.MAX_VALUE));\n+  }\n \n   static final double estimate(final long thetaLong, final int curCount, final boolean empty) {\n     if (estMode(thetaLong, empty)) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/UnionImpl.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n@@ -49,8 +49,7 @@\n    */\n   private final UpdateSketch gadget_;\n   private final short seedHash_; //eliminates having to compute the seedHash on every update.\n-  private long unionThetaLong_ = Long.MAX_VALUE; //when on-heap, this is the only copy\n-  private boolean unionEmpty_ = true;\n+  private long unionThetaLong_; //when on-heap, this is the only copy\n \n   private UnionImpl(final UpdateSketch gadget, final long seed) {\n     gadget_ = gadget;\n@@ -198,7 +192,7 @@\n     final int gadgetCurCount = gadget_.getRetainedEntries(true);\n     final int k = 1 << gadget_.getLgNomLongs();\n     final long[] gadgetCacheCopy =\n-        (gadget_.isDirect()) ? gadget_.getCache() : gadget_.getCache().clone();\n+        (gadget_.hasMemory()) ? gadget_.getCache() : gadget_.getCache().clone();\n \n     //Pull back to k\n     final long curGadgetThetaLong = gadget_.getThetaLong();\n@@ -206,10 +200,10 @@\n         ? selectExcludingZeros(gadgetCacheCopy, gadgetCurCount, k + 1) : curGadgetThetaLong;\n \n     //Finalize Theta and curCount\n-    final long unionThetaLong = (gadget_.isDirect())\n+    final long unionThetaLong = (gadget_.hasMemory())\n         ? gadget_.getMemory().getLong(UNION_THETA_LONG) : unionThetaLong_;\n \n-    long minThetaLong = min(min(curGadgetThetaLong, adjGadgetThetaLong), unionThetaLong);\n+    final long minThetaLong = min(min(curGadgetThetaLong, adjGadgetThetaLong), unionThetaLong);\n     final int curCountOut = (minThetaLong < curGadgetThetaLong)\n         ? HashOperations.count(gadgetCacheCopy, minThetaLong)\n         : gadgetCurCount;\n@@ -217,8 +211,7 @@\n     //Compact the cache\n     final long[] compactCacheOut =\n         compactCache(gadgetCacheCopy, curCountOut, minThetaLong, dstOrdered);\n-    final boolean empty = gadget_.isEmpty() && unionEmpty_;\n-    if (empty) { minThetaLong = Long.MAX_VALUE; }\n+    final boolean empty = gadget_.isEmpty();\n     return createCompactSketch(\n         compactCacheOut, empty, seedHash_, curCountOut, minThetaLong, dstOrdered, dstMem);\n   }\n@@ -258,14 +248,13 @@\n     Util.checkSeedHashes(seedHash_, sketchIn.getSeedHash());\n     Sketch.checkSketchAndMemoryFlags(sketchIn);\n \n-\n     final long thetaLongIn = sketchIn.getThetaLong();\n     unionThetaLong_ = min(unionThetaLong_, thetaLongIn); //Theta rule with incoming\n     final int curCountIn = sketchIn.getRetainedEntries(true);\n     if (curCountIn > 0) {\n       if (sketchIn.isOrdered()) { //Only true if Compact. Use early stop\n         //Ordered, thus compact\n-        if (sketchIn.isDirect()) {\n+        if (sketchIn.hasMemory()) {\n           final Memory skMem = ((CompactSketch) sketchIn).getMemory();\n           final int preambleLongs = skMem.getByte(PREAMBLE_LONGS_BYTE) & 0X3F;\n           for (int i = 0; i < curCountIn; i++ ) {\n@@ -295,15 +284,14 @@\n         }\n       }\n     }\n-    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //theta rule\n-    final int gCurCount = gadget_.getRetainedEntries();\n-    unionEmpty_ = (gCurCount == 0) && (unionThetaLong_ == Long.MAX_VALUE); //empty rule\n-    if (gadget_.isDirect()) {\n-      final WritableMemory wmem = (WritableMemory)gadget_.getMemory();\n-      wmem.putLong(UNION_THETA_LONG, unionThetaLong_);\n-      if (unionEmpty_) { PreambleUtil.setEmpty(wmem); }\n+    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //Theta rule with gadget\n+    final boolean empty = gadget_.isEmpty() && sketchIn.isEmpty(); //Empty rule\n+    if (gadget_.hasMemory()) {\n+      final WritableMemory wmem = (WritableMemory) gadget_.getMemory();\n+      if (empty) { PreambleUtil.setEmpty(wmem); }\n       else { PreambleUtil.clearEmpty(wmem); }\n-    }\n+    } else { ((HeapUpdateSketch) gadget_).setEmpty(empty); }\n   }\n \n   @Override",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-53",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.yahoo.sketches.theta.DirectUnionTest",
                "error": "java.lang.AssertionError",
                "message": "expected [true] but found [false]",
                "methodName": "checkForDruidBug2"
            }
        ],
        "metrics": {
            "chunks": 10,
            "classes": 1,
            "files": 1,
            "linesAdd": 13,
            "linesMod": 0,
            "linesRem": 4,
            "methods": 3,
            "sizeInLines": 13
        },
        "program": "RegressionBug-53",
        "project": "RegressionBug-53",
        "repairOperators": [
            "mcRem",
            "mcAdd",
            "varAdd",
            "condBranIfElseAdd",
            "varRem",
            "mcParAdd",
            "condBranRem",
            "assignAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/yahoo/sketches/theta/UnionImpl.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n@@ -341,6 +343,7 @@\n             \"Family must be Alpha, QuickSelect, or Compact: \" + Family.idToFamily(fam));\n       }\n       if (cap <= 8) { return; } //empty and Theta = 1.0\n+      Util.checkSeedHashes(seedHash_, skMem.getShort(SEED_HASH_SHORT));\n       processVer3(skMem);\n     }\n     else {\n@@ -451,39 +466,48 @@\n \n   //has seedHash, p, could have 0 entries & theta,\n   // could be unordered, ordered, compact, or not, size >= 8\n   private void processVer3(final Memory skMem) {\n-    Util.checkSeedHashes(seedHash_, skMem.getShort(SEED_HASH_SHORT));\n     final int preLongs = skMem.getByte(PREAMBLE_LONGS_BYTE) & 0X3F;\n     final int curCountIn;\n     final long thetaLongIn;\n+    final int flags = skMem.getByte(FLAGS_BYTE) & 0X3F;\n     if (preLongs == 1) { //SingleItemSketch if not empty, Read-Only, Compact and Ordered\n-      final int flags = skMem.getByte(FLAGS_BYTE);\n       if (flags == (READ_ONLY_FLAG_MASK | COMPACT_FLAG_MASK | ORDERED_FLAG_MASK)) { //nonEmpty Singleton\n         curCountIn = 1;\n         thetaLongIn = Long.MAX_VALUE;\n       } else {\n         return; //otherwise an empty sketch {1.0, 0, T}. Nothing changed\n       }\n     }\n     else if (preLongs == 2) { //curCount has to be > 0 and exact mode. Cannot be from intersection.\n       curCountIn = skMem.getInt(RETAINED_ENTRIES_INT);\n       assert curCountIn > 0;\n       thetaLongIn = Long.MAX_VALUE;\n     }\n     else { //prelongs == 3, curCount may be 0 (e.g., from intersection).\n       curCountIn = skMem.getInt(RETAINED_ENTRIES_INT);\n       assert curCountIn > 0;\n       thetaLongIn = skMem.getLong(THETA_LONG);\n     }\n-    unionThetaLong_ = min(unionThetaLong_, thetaLongIn); //theta rule\n+    unionThetaLong_ = min(min(unionThetaLong_, thetaLongIn), gadget_.getThetaLong()); //theta rule\n+    unionEmpty_ = unionEmpty_ && ((flags & EMPTY_FLAG_MASK) > 0)  && gadget_.isEmpty();\n     final boolean ordered = (skMem.getByte(FLAGS_BYTE) & ORDERED_FLAG_MASK) != 0;\n     if (ordered) { //must be compact\n       for (int i = 0; i < curCountIn; i++ ) {\n         final int offsetBytes = (preLongs + i) << 3;\n         final long hashIn = skMem.getLong(offsetBytes);\n         if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n@@ -501,7 +525,15 @@\n       }\n     }\n     unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //sync thetaLongs\n-    unionEmpty_ = unionEmpty_ && gadget_.isEmpty();\n+    if (gadget_.hasMemory()) {\n+      final WritableMemory wmem = (WritableMemory)gadget_.getMemory();\n+      PreambleUtil.insertUnionThetaLong(wmem, unionThetaLong_);\n+      if (unionEmpty_) {\n+        PreambleUtil.setEmpty(wmem);\n+      } else {\n+        PreambleUtil.clearEmpty(wmem);\n+      }\n+    }\n   }\n \n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/DirectCompactOrderedSketch.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/DirectCompactOrderedSketch.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/DirectCompactOrderedSketch.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/DirectCompactOrderedSketch.java\n@@ -53,10 +53,11 @@\n    * @return a DirectCompactOrderedSketch.\n    */\n   static DirectCompactOrderedSketch compact(final UpdateSketch sketch, final WritableMemory dstMem) {\n-    final long thetaLong = sketch.getThetaLong();\n-    final boolean empty = sketch.isEmpty();\n     final int curCount = sketch.getRetainedEntries(true);\n+    long thetaLong = sketch.getThetaLong();\n+    boolean empty = sketch.isEmpty();\n+    thetaLong = thetaOnCompact(empty, curCount, thetaLong);\n+    empty = emptyOnCompact(curCount, thetaLong);\n     final int preLongs = computeCompactPreLongs(thetaLong, empty, curCount);\n     final short seedHash = sketch.getSeedHash();\n     final long[] cache = sketch.getCache();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/HeapCompactOrderedSketch.java\n@@ -77,10 +77,11 @@\n    * @return a CompactSketch\n    */\n   static CompactSketch compact(final UpdateSketch sketch) {\n-    final long thetaLong = sketch.getThetaLong();\n-    final boolean empty = sketch.isEmpty();\n     final int curCount = sketch.getRetainedEntries(true);\n+    long thetaLong = sketch.getThetaLong();\n+    boolean empty = sketch.isEmpty();\n+    thetaLong = thetaOnCompact(empty, curCount, thetaLong);\n+    empty = emptyOnCompact(curCount, thetaLong);\n     final short seedHash = sketch.getSeedHash();\n     final long[] cache = sketch.getCache();\n     final boolean ordered = true;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/SetOperation.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/SetOperation.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/SetOperation.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/SetOperation.java\n@@ -222,14 +224,12 @@\n   abstract boolean isEmpty();\n \n   //used only by the set operations\n-  static final CompactSketch createCompactSketch(final long[] compactCache, final boolean empty,\n-      final short seedHash, int curCount, long thetaLong, final boolean dstOrdered,\n+  static final CompactSketch createCompactSketch(final long[] compactCache, boolean empty,\n+      final short seedHash, final int curCount, long thetaLong, final boolean dstOrdered,\n       final WritableMemory dstMem) {\n-    if (empty) {\n-      curCount = 0;\n-      thetaLong = Long.MAX_VALUE;\n-    }\n+    thetaLong = thetaOnCompact(empty, curCount, thetaLong);\n+    empty = emptyOnCompact(curCount, thetaLong);\n+\n     CompactSketch sketchOut = null;\n     final int sw = (dstOrdered ? 2 : 0) | ((dstMem != null) ? 1 : 0);\n     switch (sw) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/Sketch.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/Sketch.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/Sketch.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/Sketch.java\n@@ -557,40 +557,31 @@\n+  static final long thetaOnCompact(final boolean empty, final int curCount, final long thetaLong) {\n+    return (empty && (curCount == 0) && (thetaLong < Long.MAX_VALUE)) ? Long.MAX_VALUE : thetaLong;\n+  }\n\n+  static final boolean emptyOnCompact(final int curCount, final long thetaLong) {\n+    return ((curCount == 0) && (thetaLong == Long.MAX_VALUE));\n+  }\n \n   static final double estimate(final long thetaLong, final int curCount, final boolean empty) {\n     if (estMode(thetaLong, empty)) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/UnionImpl.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/yahoo/sketches/theta/UnionImpl.java\n@@ -49,8 +49,7 @@\n    */\n   private final UpdateSketch gadget_;\n   private final short seedHash_; //eliminates having to compute the seedHash on every update.\n-  private long unionThetaLong_ = Long.MAX_VALUE; //when on-heap, this is the only copy\n-  private boolean unionEmpty_ = true;\n+  private long unionThetaLong_; //when on-heap, this is the only copy\n \n   private UnionImpl(final UpdateSketch gadget, final long seed) {\n     gadget_ = gadget;\n@@ -198,7 +192,7 @@\n     final int gadgetCurCount = gadget_.getRetainedEntries(true);\n     final int k = 1 << gadget_.getLgNomLongs();\n     final long[] gadgetCacheCopy =\n-        (gadget_.isDirect()) ? gadget_.getCache() : gadget_.getCache().clone();\n+        (gadget_.hasMemory()) ? gadget_.getCache() : gadget_.getCache().clone();\n \n     //Pull back to k\n     final long curGadgetThetaLong = gadget_.getThetaLong();\n@@ -206,10 +200,10 @@\n         ? selectExcludingZeros(gadgetCacheCopy, gadgetCurCount, k + 1) : curGadgetThetaLong;\n \n     //Finalize Theta and curCount\n-    final long unionThetaLong = (gadget_.isDirect())\n+    final long unionThetaLong = (gadget_.hasMemory())\n         ? gadget_.getMemory().getLong(UNION_THETA_LONG) : unionThetaLong_;\n \n-    long minThetaLong = min(min(curGadgetThetaLong, adjGadgetThetaLong), unionThetaLong);\n+    final long minThetaLong = min(min(curGadgetThetaLong, adjGadgetThetaLong), unionThetaLong);\n     final int curCountOut = (minThetaLong < curGadgetThetaLong)\n         ? HashOperations.count(gadgetCacheCopy, minThetaLong)\n         : gadgetCurCount;\n@@ -217,8 +211,7 @@\n     //Compact the cache\n     final long[] compactCacheOut =\n         compactCache(gadgetCacheCopy, curCountOut, minThetaLong, dstOrdered);\n-    final boolean empty = gadget_.isEmpty() && unionEmpty_;\n-    if (empty) { minThetaLong = Long.MAX_VALUE; }\n+    final boolean empty = gadget_.isEmpty();\n     return createCompactSketch(\n         compactCacheOut, empty, seedHash_, curCountOut, minThetaLong, dstOrdered, dstMem);\n   }\n@@ -508,15 +496,15 @@\n         gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n       }\n     }\n-    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //theta rule\n-    final int gCurCount = gadget_.getRetainedEntries();\n-    unionEmpty_ = (gCurCount == 0) && (unionThetaLong_ == Long.MAX_VALUE); //empty rule\n-    if (gadget_.isDirect()) {\n-      final WritableMemory wmem = (WritableMemory)gadget_.getMemory();\n-      wmem.putLong(UNION_THETA_LONG, unionThetaLong_);\n-      if (unionEmpty_) { PreambleUtil.setEmpty(wmem); }\n+    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //sync thetaLongs\n+    final boolean emptyIn = (curCount == 0) && (thetaLongIn == Long.MAX_VALUE);\n+    final boolean empty = gadget_.isEmpty() && emptyIn; //Empty rule\n+    if (gadget_.hasMemory()) {\n+      final WritableMemory wmem = (WritableMemory) gadget_.getMemory();\n+      //OK to modify empty but NOT thetaLong\n+      if (empty) { PreambleUtil.setEmpty(wmem); }\n       else { PreambleUtil.clearEmpty(wmem); }\n-    }\n+    } else { ((HeapUpdateSketch) gadget_).setEmpty(empty); }\n   }\n \n }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-54",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.common.AbstractWriterTest",
                "error": "com.univocity.parsers.common.TextWritingException",
                "message": "Error writing row.\nInternal state when error was thrown: recordCount=0, recordData=[V1, V2, V3]",
                "methodName": "testExcludeFields"
            },
            {
                "className": "com.univocity.parsers.common.AbstractWriterTest",
                "error": "com.univocity.parsers.common.TextWritingException",
                "message": "Error writing row.\nInternal state when error was thrown: recordCount=0, recordData=[V1, V2, V3]",
                "methodName": "testSelectFields"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-54",
        "project": "RegressionBug-54",
        "repairOperators": [
            "assignExpChange"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n@@ -910,7 +910,7 @@\n \t\t}\n \t\tif (indexesToWrite.length < row.length) {\n \t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n-\t\t\t\toutputRow[indexesToWrite[i]] = row[indexesToWrite[i]];\n+\t\t\t\toutputRow[i] = row[indexesToWrite[i]];\n \t\t\t}\n \t\t} else {\n \t\t\tfor (int i = 0; i < row.length && i < indexesToWrite.length; i++) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java\n@@ -232,7 +232,8 @@\n \t\t\tif (headers != null && headers.length > 0) {\n \t\t\t\tindexesToWrite = selector.getFieldIndexes(headers);\n \t\t\t\tif (columnReorderingEnabled) { //column reordering enabled?\n-\t\t\t\t\toutputRow = new Object[indexesToWrite.length];\n+\t\t\t\t\tint size = ArgumentUtils.removeAll(indexesToWrite, -1).length;\n+\t\t\t\t\toutputRow = new Object[size];\n \t\t\t\t} else {\n \t\t\t\t\toutputRow = new Object[headers.length];\n \t\t\t\t}\n@@ -257,13 +258,16 @@\n \t\t\t\t}\n \t\t\t\tindexesToWrite = selector.getFieldIndexes(new NormalizedString[rowLength]); //generates a dummy header array - only the indexes matter so we are good\n \t\t\t\tif (columnReorderingEnabled) { //column reordering enabled?\n-\t\t\t\t\toutputRow = new Object[indexesToWrite.length];\n+\t\t\t\t\tint size = ArgumentUtils.removeAll(indexesToWrite, -1).length;\n+\t\t\t\t\toutputRow = new Object[size];\n \t\t\t\t} else {\n \t\t\t\t\toutputRow = new Object[rowLength];\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tthrow new IllegalStateException(\"Cannot select fields by name with no headers defined\");\n \t\t\t}\n\n+\t\t\tindexesToWrite = ArgumentUtils.removeAll(indexesToWrite, -1);\n \t\t} else {\n \t\t\toutputRow = null;\n \t\t\tindexesToWrite = null;\n@@ -488,9 +492,22 @@\n \t *\n \t * @param records the records to transformed by a {@link RowWriterProcessor} and then written to the output\n \t */\n+\tpublic final <T extends Record> void processRecords(T[] records) {\n+\t\tfor (T record : records) {\n+\t\t\tprocessRecord(record);\n+\t\t}\n+\t}\n\n\t/**\n \t * Processes the data given for an individual record with the {@link RowWriterProcessor} provided by {@link CommonWriterSettings#getRowWriterProcessor()}, then writes it.\n@@ -806,23 +883,29 @@\n \t */\n \tprivate <T> void fillOutputRow(T[] row) {\n \t\tif (columnReorderingEnabled) {\n-\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n-\t\t\t\tif (indexesToWrite[i] < row.length) {\n-\t\t\t\t\toutputRow[i] = row[indexesToWrite[i]];\n-\t\t\t\t} else {\n-\t\t\t\t\toutputRow[i] = null;\n+\t\t\tif (row.length > indexesToWrite.length) {\n+\t\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n+\t\t\t\t\toutputRow[indexesToWrite[i]] = row[indexesToWrite[i]];\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor (int i = 0, j = 0; i < indexesToWrite.length && j < outputRow.length; i++) {\n+\t\t\t\t\toutputRow[j++] = row[indexesToWrite[i]];\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tif (row.length > outputRow.length) {\n-\t\t\t\toutputRow = row;\n-\t\t\t} else if (row.length > indexesToWrite.length) {\n+\t\t\t\toutputRow = Arrays.copyOf(outputRow, row.length);\n+\t\t\t}\n+\n+\t\t\tif (row.length > indexesToWrite.length) {\n \t\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n \t\t\t\t\toutputRow[indexesToWrite[i]] = row[indexesToWrite[i]];\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tfor (int i = 0; i < indexesToWrite.length && i < row.length; i++) {\n-\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n+\t\t\t\t\tif (indexesToWrite[i] != -1) {\n+\t\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-55",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.issues.github.Github_415",
                "error": "java.lang.AssertionError",
                "message": "expected [ ] but found [|]",
                "methodName": "detectedFormatTest"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 32,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 32
        },
        "program": "RegressionBug-55",
        "project": "RegressionBug-55",
        "repairOperators": [
            "condBranIfAdd",
            "loopAdd",
            "varAdd",
            "objInstAdd",
            "mcAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n@@ -204,6 +204,43 @@\n \t\t\t}\n \t\t}\n \n+\t\tif (toRemove.size() == sums.size()) { //will discard all symbols. Stick with the symbols that showed up more consistently across all rows.\n+\t\t\tMap<Character, Integer> lineCount = new HashMap<Character, Integer>();\n+\t\t\tfor (i = 0; i < symbolsPerRow.size(); i++) {\n+\t\t\t\tfor (Character symbolInRow : symbolsPerRow.get(i).keySet()) {\n+\t\t\t\t\tInteger count = lineCount.get(symbolInRow);\n+\t\t\t\t\tif (count == null) {\n+\t\t\t\t\t\tcount = 0;\n+\t\t\t\t\t}\n+\t\t\t\t\tlineCount.put(symbolInRow, count + 1);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tInteger highestLineCount = null;\n+\t\t\tfor (Map.Entry<Character, Integer> e : lineCount.entrySet()) {\n+\t\t\t\tif (highestLineCount == null || highestLineCount < e.getValue()) {\n+\t\t\t\t\thighestLineCount = e.getValue();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tCharacter bestCandidate = null;\n+\t\t\tfor (Map.Entry<Character, Integer> e : lineCount.entrySet()) {\n+\t\t\t\tif (e.getValue().equals(highestLineCount)) {\n+\t\t\t\t\tif (bestCandidate == null) {\n+\t\t\t\t\t\tbestCandidate = e.getKey();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbestCandidate = null;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (bestCandidate != null) {\n+\t\t\t\ttoRemove.remove(bestCandidate);\n+\t\t\t}\n+\t\t}\n\n \t\tsums.keySet().removeAll(toRemove);\n \n \t\tif (allowedDelimiters.length > 0) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java\n@@ -325,7 +325,7 @@\n \t}\n \n \tprivate boolean isSymbol(char ch) {\n-\t\treturn ch != comment && !Character.isLetterOrDigit(ch) && (ch == '\\t' || ch > ' ');\n+\t\treturn ch != comment && !Character.isLetterOrDigit(ch) && (ch == '\\t' || ch >= ' ');\n \t}\n \n \t/**",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-56",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.xebialabs.overthere.CmdLineTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : \"\\\"C:\\Program Files\\WebSphere\\bin\\wsadmin.bat\\\" aNormalValue \\\"\\\" \\\"the argument with spaces\\\" heretheycome'\\\"\\;()%${}*?andthatwasem\"\n     but: was \"\\\"C:\\Program Files\\WebSphere\\bin\\wsadmin.bat\\\" aNormalValue \\\"\\\" \\\"the argument with spaces\\\" heretheycome'\\\"\\;()%%${}*?andthatwasem\"",
                "methodName": "shouldEncodeCorrectlyForWindows"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 0,
            "linesRem": 3,
            "methods": 1,
            "sizeInLines": 0
        },
        "program": "RegressionBug-56",
        "project": "RegressionBug-56",
        "repairOperators": [
            "condBranRem",
            "retRem",
            "mcRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n@@ -68,9 +68,6 @@\n     }\n \n     public static boolean containsAnySpecialChars(String str) {\n-        if (str.indexOf(PERCENT_CHAR) >= 0) {\n-            return true;\n-        }\n         for (char c : SPECIAL_CHARS) {\n             if (str.indexOf(c) >= 0) {\n                 return true;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n@@ -24,7 +24,8 @@\n \n public class WindowsCommandLineArgsSanitizer {\n \n-    private static final char[] SPECIAL_CHARS = \" |<>&^\\r\\n\".toCharArray();\n+    private static final char[] SPECIAL_CHARS = \" |<>&^,;()\\r\\n\".toCharArray();\n+    private static final char[] SLASH_ESCAPED_CHARS = \"\\\\[].*?\".toCharArray();\n \n     private static final String WHITE_SPACE = \" \";\n \n@@ -39,9 +40,15 @@\n         StringBuilder builder = new StringBuilder();\n         for (int j = 0; j < str.length(); j++) {\n             char c = str.charAt(j);\n+            if (c == '%') {\n+                builder.append('%');\n+            }\n             if (contains(c, SPECIAL_CHARS)) {\n                 builder.append('^');\n             }\n+            if (contains(c, SLASH_ESCAPED_CHARS)) {\n+                builder.append('\\\\');\n+            }\n             builder.append(c);\n         }\n         return builder.toString();",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-57",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.xebialabs.overthere.CmdLineTest",
                "error": "java.lang.AssertionError",
                "message": "Expected : \"\\\"C:\\Program Files\\WebSphere\\bin\\wsadmin.bat\\\" aNormalValue \\\"\\\" \\\"the argument with spaces\\\" heretheycome'\\\"\\;()%${}*?andthatwasem\"\n     but: was \"\\\"C:\\Program Files\\WebSphere\\bin\\wsadmin.bat\\\" aNormalValue \\\"\\\" \\\"the argument with spaces\\\" heretheycome'\\\"\\\\^;^(^)%%${}\\*\\?andthatwasem\"",
                "methodName": "shouldEncodeCorrectlyForWindows"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 4,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-57",
        "project": "RegressionBug-57",
        "repairOperators": [
            "varRem",
            "assignExpChange",
            "condBranRem",
            "mcRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n@@ -24,8 +24,7 @@\n \n public class WindowsCommandLineArgsSanitizer {\n \n-    private static final char[] SPECIAL_CHARS = \" |<>&^,;()\\r\\n\".toCharArray();\n-    private static final char[] SLASH_ESCAPED_CHARS = \"\\\\[].*?\".toCharArray();\n+    private static final char[] SPECIAL_CHARS = \" |<>&^\\r\\n\".toCharArray();\n \n     private static final String WHITE_SPACE = \" \";\n \n@@ -46,9 +45,6 @@\n             if (contains(c, SPECIAL_CHARS)) {\n                 builder.append('^');\n             }\n-            if (contains(c, SLASH_ESCAPED_CHARS)) {\n-                builder.append('\\\\');\n-            }\n             builder.append(c);\n         }\n         return builder.toString();",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java\n@@ -24,7 +24,8 @@\n \n public class WindowsCommandLineArgsSanitizer {\n \n-    private static final char[] SPECIAL_CHARS = \" |<>&^\\r\\n\".toCharArray();\n+    private static final char[] SPECIAL_CHARS = \" |<>&^,;()\\r\\n\".toCharArray();\n+    private static final char[] SLASH_ESCAPED_CHARS = \"\\\\[].*?\".toCharArray();\n \n     private static final String WHITE_SPACE = \" \";\n \n@@ -39,9 +40,15 @@\n         StringBuilder builder = new StringBuilder();\n         for (int j = 0; j < str.length(); j++) {\n             char c = str.charAt(j);\n+            if (c == '%') {\n+                builder.append('%');\n+            }\n             if (contains(c, SPECIAL_CHARS)) {\n                 builder.append('^');\n             }\n+            if (contains(c, SLASH_ESCAPED_CHARS)) {\n+                builder.append('\\\\');\n+            }\n             builder.append(c);\n         }\n         return builder.toString();",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-58",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.zaxxer.hikari.pool.TestMetrics",
                "error": "java.lang.AssertionError",
                "message": "Expected exception: java.lang.IllegalArgumentException",
                "methodName": "testFakeMetricRegistryThrowsIllegalArgumentException"
            },
            {
                "className": "com.zaxxer.hikari.pool.TestMetrics",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Class must be instance of com.codahale.metrics.MetricRegistry or io.micrometer.core.instrument.MeterRegistry",
                "methodName": "testMetricRegistrySubclassIsAllowed"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 2,
            "files": 2,
            "linesAdd": 9,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 11
        },
        "program": "RegressionBug-58",
        "project": "RegressionBug-58",
        "repairOperators": [
            "condExpMod",
            "mcRem",
            "mcParRem",
            "mcAdd",
            "mcParAdd",
            "mdAdd",
            "exTryCatchAdd",
            "varAdd",
            "objInstAdd",
            "retBranchAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/zaxxer/hikari/HikariConfig.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/zaxxer/hikari/HikariConfig.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/zaxxer/hikari/HikariConfig.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/zaxxer/hikari/HikariConfig.java\n@@ -42,6 +42,7 @@\n import java.util.concurrent.ThreadLocalRandom;\n \n import static com.zaxxer.hikari.util.UtilityElf.getNullIfEmpty;\n+import static com.zaxxer.hikari.util.UtilityElf.safeIsAssignableFrom;\n import static java.util.concurrent.TimeUnit.MINUTES;\n import static java.util.concurrent.TimeUnit.SECONDS;\n \n@@ -758,8 +759,8 @@\n       if (metricRegistry != null) {\n          metricRegistry = getObjectOrPerformJndiLookup(metricRegistry);\n \n-         if (!(metricRegistry.getClass().getName().contains(\"MetricRegistry\"))\n-             && !(metricRegistry.getClass().getName().contains(\"MeterRegistry\"))) {\n+         if (!safeIsAssignableFrom(metricRegistry, \"com.codahale.metrics.MetricRegistry\")\n+             && !(safeIsAssignableFrom(metricRegistry, \"io.micrometer.core.instrument.MeterRegistry\"))) {\n             throw new IllegalArgumentException(\"Class must be instance of com.codahale.metrics.MetricRegistry or io.micrometer.core.instrument.MeterRegistry\");\n          }\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/zaxxer/hikari/util/UtilityElf.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/zaxxer/hikari/util/UtilityElf.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/zaxxer/hikari/util/UtilityElf.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/zaxxer/hikari/util/UtilityElf.java\n@@ -66,6 +66,21 @@\n     * @param className String class\n     * @return true if object is assignable from the type, false otherwise or when the class cannot be loaded\n     */\n+   public static boolean safeIsAssignableFrom(Object obj, String className) {\n+      try {\n+         Class<?> clazz = Class.forName(className);\n+         return clazz.isAssignableFrom(obj.getClass());\n+      } catch (ClassNotFoundException ignored) {\n+         return false;\n+      }\n+   }\n \n    /**\n     * Create and instance of the specified class using the constructor matching the specified",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/zaxxer/hikari/HikariConfig.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/zaxxer/hikari/HikariConfig.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/zaxxer/hikari/HikariConfig.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/zaxxer/hikari/HikariConfig.java\n@@ -551,7 +547,8 @@\n       if (metricRegistry != null) {\n          metricRegistry = getObjectOrPerformJndiLookup(metricRegistry);\n \n-         if (!(metricRegistry instanceof MetricRegistry) && !(metricRegistry instanceof MeterRegistry)) {\n+         if (!(metricRegistry.getClass().getName().contains(\"MetricRegistry\"))\n+             && !(metricRegistry.getClass().getName().contains(\"MeterRegistry\"))) {\n             throw new IllegalArgumentException(\"Class must be instance of com.codahale.metrics.MetricRegistry or io.micrometer.core.instrument.MeterRegistry\");\n          }\n       }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-59",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.esri.core.geometry.TestConvexHull",
                "error": "java.lang.NullPointerException",
                "message": "",
                "methodName": "testHullIssueGithub194"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-59",
        "project": "RegressionBug-59",
        "repairOperators": [
            "condExpMod",
            "assignExpChange",
            "mcAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java\n@@ -444,13 +444,13 @@\n \t\t}\n \n \t\tif (!polygon.isEmpty()) {\n-\t\t\tif (!resultGeom.isEmpty()) {\n+\t\t\tif (resultGeom != null && !resultGeom.isEmpty()) {\n \t\t\t\tGeometry[] geoms = { resultGeom, polygon };\n \t\t\t\tresultGeom = OperatorConvexHull.local().execute(\n \t\t\t\t\t\tnew SimpleGeometryCursor(geoms), true, null).next();\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tresultGeom = polygon;\n+\t\t\t\tresultGeom = OperatorConvexHull.local().execute(polygon, null);\n \t\t\t}\n \t\t}\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java\n@@ -377,6 +385,59 @@\n \t\t}\n \n \t}\n+\t@Override\n+\tpublic OGCGeometry convexHull() {\n+\t\tGeometryCursor cursor = OperatorConvexHull.local().execute(\n+\t\t\t\tgetEsriGeometryCursor(), false, null);\n+\t\tMultiPoint mp = new MultiPoint();\n+\t\tPolygon polygon = new Polygon();\n+\t\tVertexDescription vd = null;\n+\t\tfor (Geometry geom = cursor.next(); geom != null; geom = cursor.next()) {\n+\t\t\tvd = geom.getDescription();\n+\t\t\tif (geom.isEmpty())\n+\t\t\t\tcontinue;\n\n+\t\t\tif (geom.getType() == Geometry.Type.Polygon) {\n+\t\t\t\tpolygon.add((MultiPath) geom, false);\n+\t\t\t}\n+\t\t\telse if (geom.getType() == Geometry.Type.Polyline) {\n+\t\t\t\tmp.add((MultiVertexGeometry) geom, 0, -1);\n+\t\t\t}\n+\t\t\telse if (geom.getType() == Geometry.Type.Point) {\n+\t\t\t\tmp.add((Point) geom);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthrow new GeometryException(\"internal error\");\n+\t\t\t}\n+\t\t}\n\n+\t\tGeometry resultGeom = null;\n+\t\tif (!mp.isEmpty()) {\n+\t\t\tresultGeom = OperatorConvexHull.local().execute(mp, null);\n+\t\t}\n\n+\t\tif (!polygon.isEmpty()) {\n+\t\t\tif (!resultGeom.isEmpty()) {\n+\t\t\t\tGeometry[] geoms = { resultGeom, polygon };\n+\t\t\t\tresultGeom = OperatorConvexHull.local().execute(\n+\t\t\t\t\t\tnew SimpleGeometryCursor(geoms), true, null).next();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tresultGeom = polygon;\n+\t\t\t}\n+\t\t}\n\n+\t\tif (resultGeom == null) {\n+\t\t\tPoint pt = new Point();\n+\t\t\tif (vd != null)\n+\t\t\t\tpt.assignVertexDescription(vd);\n+\n+\t\t\treturn new OGCPoint(pt, getEsriSpatialReference());\n+\t\t}\n\n+\t\treturn OGCGeometry.createFromEsriGeometry(resultGeom, getEsriSpatialReference(), false);\n+\t}\n \n \tList<OGCGeometry> geometries;\n \n ",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-60",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jongo.query.BsonQueryFactoryTest",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Not enough parameters passed to query: {id:#!!}",
                "methodName": "shouldBindParameterWithCustomLongToken"
            }
        ],
        "metrics": {
            "chunks": 20,
            "classes": 4,
            "files": 4,
            "linesAdd": 159,
            "linesMod": 30,
            "linesRem": 67,
            "methods": 4,
            "sizeInLines": 189
        },
        "program": "RegressionBug-60",
        "project": "RegressionBug-60",
        "repairOperators": [
            "Uncategorized"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jongo/query/BsonQueryFactory.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jongo/query/BsonQueryFactory.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jongo/query/BsonQueryFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jongo/query/BsonQueryFactory.java\n@@ -26,7 +26,13 @@\n import org.jongo.marshall.Marshaller;\n import org.jongo.marshall.MarshallingException;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n\n+import static org.jongo.query.BsonSpecialChar.itIsABsonSpecialChar;\n+import static org.jongo.query.BsonSpecialChar.specialChar;\n \n public class BsonQueryFactory implements QueryFactory {\n \n@@ -43,6 +49,7 @@\n     private static final String MARSHALL_OPERATOR = \"8a6e4178-8fba-4d22-af43-840512e3a999-marshall\";\n \n     private final String token;\n+    private final boolean singleCharToken;\n     private final Marshaller marshaller;\n \n     private static class BsonQuery implements Query {\n@@ -66,6 +73,7 @@\n     }\n \n     public BsonQueryFactory(Marshaller marshaller, String token) {\n+        this.singleCharToken = token.length() == 1;\n         this.token = token;\n         this.marshaller = marshaller;\n     }\n@@ -105,89 +113,41 @@\n     }\n \n     private String addRequiredQuotesAndParameters(String query, Object[] parameters) {\n-        StringBuilder sb = new StringBuilder(query.length());\n+        StringBuilder result = new StringBuilder(query.length());\n \n         int position = 0;\n         int paramIndex = 0;\n-        Stack<Context> stack = new Stack<>(Context.NONE);\n-        Context ctx;\n-        String token = \"\";\n+        Stack<Context> ctxStack = new Stack<>(Context.NONE);\n+        StringBuilder currentToken = new StringBuilder();\n         String previousToken = \"\";\n         char currentStringStartingQuote = ' ';\n-        for (char c : query.toCharArray()) {\n-            ctx = stack.peek();\n-            if (ctx == Context.STRING) {\n-                token += c;\n-                if (c == currentStringStartingQuote) {\n-                    stack.pop();\n-                }\n-            } else if (c == '\\'' || c == '\"') {\n-                stack.push(Context.STRING);\n-                currentStringStartingQuote = c;\n-                token += c;\n-            } else if ((token + c).lastIndexOf(this.token) == token.length() - this.token.length() + 1) {\n\n+        for (char nextChar : query.toCharArray()) {\n+            if (ctxStack.peek() == Context.STRING) {\n+                currentToken.append(nextChar);\n+                if (nextChar == currentStringStartingQuote) {\n+                    ctxStack.pop();\n+                }\n+            } else if (isAQuote(nextChar)) {\n+                ctxStack.push(Context.STRING);\n+                currentStringStartingQuote = nextChar;\n+                currentToken.append(nextChar);\n+            } else if (currentTokenWithNextCharIsToken(currentToken, nextChar)) {\n                 if (paramIndex >= parameters.length) {\n                     throw new IllegalArgumentException(\"Not enough parameters passed to query: \" + query);\n                 }\n                 if (\"$oid\".equals(previousToken) ||\n                         !isValueToken(query, position)) {\n-                    token = \"\\\"\" + token.trim() + parameters[paramIndex] + \"\\\"\";\n+                    currentToken = trimAppendParamAndQuote(currentToken, parameters[paramIndex]);\n                 } else {\n-                    sb.append(\"{\\\"\")\n-                            .append(MARSHALL_OPERATOR)\n-                            .append(\"\\\":\")\n-                            .append(paramIndex).append(\"}\");\n+                    appendParamPlaceholder(result, paramIndex);\n+                    currentToken.setLength(0);\n                 }\n                 paramIndex++;\n-            } else if (c == '{') {\n-                stack.push(Context.OBJECT);\n-                sb.append(\"{\");\n-            } else if (c == '[') {\n-                stack.push(Context.ARRAY);\n-                sb.append(\"[\");\n-            } else if (c == '}') {\n-                ctx = stack.pop();\n-                if (ctx != Context.OBJECT) {\n-                    throw new IllegalArgumentException(\"Invalid token at position: \" + position);\n-                }\n\n-                if (!token.isEmpty()) {\n-                    sb.append(token);\n-                }\n\n-                previousToken = token;\n-                token = \"\";\n-                sb.append(\"}\");\n-            } else if (c == ']') {\n-                ctx = stack.pop();\n-                if (ctx != Context.ARRAY) {\n-                    throw new IllegalArgumentException(\"Invalid token at position: \" + position);\n-                }\n\n-                if (!token.isEmpty()) {\n-                    sb.append(token);\n-                }\n\n-                previousToken = token;\n-                token = \"\";\n-                sb.append(\"]\");\n-            } else if (c == ':') {\n-                String key = token.trim();\n-                if (key.isEmpty() || key.equals(\"\\\"\\\"\") || key.equals(\"''\")) {\n-                    throw new IllegalArgumentException(\"Invalid token at position: \" + position);\n-                }\n\n-                sb.append(isQuoted(key) ? key : quote(key));\n-                sb.append(\":\");\n-                previousToken = token;\n-                token = \"\";\n-            } else if (c == ',') {\n-                sb.append(token);\n-                sb.append(\",\");\n-                previousToken = token;\n-                token = \"\";\n+            } else if (itIsABsonSpecialChar(nextChar)) {\n+                previousToken = specialChar(nextChar).applySpecificBehaviour(result, currentToken, ctxStack, position);\n             } else {\n-                token += c;\n+                currentToken.append(nextChar);\n             }\n \n             position++;\n@@ -197,62 +157,35 @@\n             throw new IllegalArgumentException(\"Too many parameters passed to query: \" + query);\n         }\n \n-        return sb.toString().trim();\n-    }\n-\n-    public enum Context {\n-        NONE,\n-        OBJECT,\n-        ARRAY,\n-        STRING;\n+        return result.toString().trim();\n     }\n \n-    private static boolean isQuoted(String token) {\n-        char start = token.charAt(0);\n-        char end = token.charAt(token.length() - 1);\n-        if (start == '\\'' && end == '\\'') {\n-            return true;\n+    private boolean currentTokenWithNextCharIsToken(StringBuilder currentToken, char nextChar) {\n+        if (this.singleCharToken) {\n+            return this.token.charAt(0) == nextChar;\n         }\n-\n-        if (start == '\"' && end == '\"') {\n-            return true;\n-        }\n-\n-        return false;\n+        return (currentToken.toString().trim() + nextChar).lastIndexOf(this.token) >= 0;\n     }\n \n-    private static String quote(String token) {\n-        return \"\\\"\" + token + \"\\\"\";\n+    private void appendParamPlaceholder(StringBuilder result, int paramIndex) {\n+        result.append('{')\n+                .append('\"')\n+                .append(MARSHALL_OPERATOR)\n+                .append('\"')\n+                .append(':')\n+                .append(paramIndex)\n+                .append('}');\n     }\n \n-    private static class Stack<T> {\n-        private final LinkedList<T> stack;\n-        private final T noValue;\n-\n-        private Stack(T noValue) {\n-            this.stack = new LinkedList<>();\n-            this.noValue = noValue;\n-        }\n-\n-        public T peek() {\n-            if (stack.isEmpty()) {\n-                return noValue;\n-            }\n-\n-            return stack.peekLast();\n-        }\n-\n-        public T pop() {\n-            if (stack.isEmpty()) {\n-                return noValue;\n-            }\n-\n-            return this.stack.removeLast();\n-        }\n+    private StringBuilder trimAppendParamAndQuote(StringBuilder currentToken, Object parameter) {\n+        return new StringBuilder().append('\"')\n+                .append(currentToken.toString().trim())\n+                .append(parameter)\n+                .append('\"');\n+    }\n \n-        public void push(T value) {\n-            this.stack.addLast(value);\n-        }\n+    private boolean isAQuote(char c) {\n+        return c == '\\'' || c == '\"';\n     }\n \n     private Object replaceParams(DBObject dbo, Object[] params) {\nOnly in ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jongo/query: BsonSpecialChar.java\nOnly in ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jongo/query: Context.java\n+package org.jongo.query;\n\n+enum Context {\n+    NONE,\n+    OBJECT,\n+    ARRAY,\n+    STRING;\n+}\nOnly in ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jongo/query: Stack.java",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jongo/query/BsonQueryFactory.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jongo/query/BsonQueryFactory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jongo/query/BsonQueryFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jongo/query/BsonQueryFactory.java\n@@ -70,56 +70,13 @@\n             parameters = new Object[]{null};\n         }\n \n-        String quotedQuery = addRequiredQuotes(query);\n\n-        StringBuilder sb = new StringBuilder();\n-        int paramPos = 0;       // current position in the parameter list\n-        int start = 0;          // start of the current string segment\n-        int pos;                // position of the last token found\n-        while ((pos = quotedQuery.indexOf(token, start)) != -1) {\n-            if (paramPos >= parameters.length) {\n-                throw new IllegalArgumentException(\"Not enough parameters passed to query: \" + query);\n-            }\n\n-            sb.append(quotedQuery, start, pos);\n\n-            if (isValueToken(quotedQuery, pos)) {\n-                sb.append(\"{\\\"\").append(MARSHALL_OPERATOR).append(\"\\\":\").append(paramPos).append(\"}\");\n-            } else {\n-                sb.append(parameters[paramPos]);\n-            }\n-\n-            paramPos++;\n-            start = pos + token.length();\n-        }\n\n-        sb.append(quotedQuery, start, quotedQuery.length());\n\n-        if (paramPos < parameters.length) {\n-            throw new IllegalArgumentException(\"Too many parameters passed to query: \" + query);\n-        }\n\n+        String quotedQuery = addRequiredQuotesAndParameters(query, parameters);\n \n         final Object[] params = parameters;\n \n         DBObject dbo;\n         try {\n-            dbo = BasicDBObject.parse(sb.toString());\n+            dbo = BasicDBObject.parse(quotedQuery);\n             if (params.length != 0) {\n                 dbo = (DBObject) replaceParams(dbo, params);\n             }\n@@ -130,18 +87,41 @@\n         return new BsonQuery(dbo);\n     }\n \n-    private String addRequiredQuotes(String query) {\n-        if (query.trim().equals(\"#\")) {\n-            return query;\n-        }\n-\n+    private String addRequiredQuotesAndParameters(String query, Object[] parameters) {\n         StringBuilder sb = new StringBuilder(query.length());\n \n         int position = 0;\n+        int paramIndex = 0;\n         Stack<Context> stack = new Stack<>();\n         String token = \"\";\n+        String previousToken = \"\";\n+        char currentStringStartingQuote = ' ';\n         for (char c : query.toCharArray()) {\n-            if (c == '{') {\n+            if (stack.peek().isPresent() && stack.peek().get().equals(Context.STRING)) {\n+                token += c;\n+                if (c == currentStringStartingQuote) {\n+                    stack.pop();\n+                }\n+            } else if (c == '\\'' || c == '\"') {\n+                stack.push(Context.STRING);\n+                currentStringStartingQuote = c;\n+                token += c;\n+            } else if ((token + c).lastIndexOf(this.token) == token.length() - this.token.length() + 1) {\n+                if (paramIndex >= parameters.length) {\n+                    throw new IllegalArgumentException(\"Not enough parameters passed to query: \" + query);\n+                }\n+                if (\"$oid\".equals(previousToken) ||\n+                        \"$set\".equals(previousToken) ||\n+                        !isValueToken(query, position)) {\n+                    token = \"\\\"\" + token.trim() + parameters[paramIndex] + \"\\\"\";\n+                } else {\n+                    sb.append(\"{\\\"\")\n+                            .append(MARSHALL_OPERATOR)\n+                            .append(\"\\\":\")\n+                            .append(paramIndex).append(\"}\");\n+                }\n+                paramIndex++;\n+            } else if (c == '{') {\n                 stack.push(Context.OBJECT);\n                 sb.append(\"{\");\n             } else if (c == '[') {\n@@ -157,6 +137,7 @@\n                     sb.append(token);\n                 }\n \n+                previousToken = token;\n                 token = \"\";\n                 sb.append(\"}\");\n             } else if (c == ']') {\n@@ -169,6 +150,7 @@\n                     sb.append(token);\n                 }\n \n+                previousToken = token;\n                 token = \"\";\n                 sb.append(\"]\");\n             } else if (c == ':') {\n@@ -179,10 +161,12 @@\n \n                 sb.append(isQuoted(key) ? key : quote(key));\n                 sb.append(\":\");\n+                previousToken = token;\n                 token = \"\";\n             } else if (c == ',') {\n                 sb.append(token);\n                 sb.append(\",\");\n+                previousToken = token;\n                 token = \"\";\n             } else {\n                 token += c;\n@@ -191,12 +175,17 @@\n             position++;\n         }\n \n+        if (paramIndex < parameters.length) {\n+            throw new IllegalArgumentException(\"Too many parameters passed to query: \" + query);\n+        }\n\n         return sb.toString();\n     }\n \n     public enum Context {\n         OBJECT,\n         ARRAY,\n+        STRING;\n     }\n \n     private static boolean isQuoted(String token) {\n@@ -229,7 +218,7 @@\n                 return Optional.empty();\n             }\n \n-            return Optional.of(stack.peek());\n+            return Optional.of(stack.peekLast());\n         }\n \n         public Optional<T> pop() {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-61",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.gitlab4j.api.TestGitLabApiBeans",
                "error": "com.fasterxml.jackson.databind.exc.InvalidFormatException",
                "message": ": \nCannot deserialize value of type `java.lang.Integer` from String \"PROJECT-123\": not a valid Integer value",
                "methodName": "testIssuesClosedBy"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 15,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 15
        },
        "program": "RegressionBug-61",
        "project": "RegressionBug-61",
        "repairOperators": [
            "varAdd",
            "mdAdd",
            "retBranchAdd",
            "condBranIfElseAdd",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/gitlab4j/api/models/Issue.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/gitlab4j/api/models/Issue.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/gitlab4j/api/models/Issue.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/gitlab4j/api/models/Issue.java\n@@ -46,7 +52,14 @@\n     private User closedBy;\n     private String description;\n     private Date dueDate;\n\n+    @JsonProperty(\"id\")\n+    private ValueNode actualId;\n+    @JsonIgnore\n+    private String externalId;\n+    @JsonIgnore\n     private Integer id;\n\n     private Integer iid;\n     private Integer issueLinkId;\n     private List<String> labels;\n@@ -121,15 +134,44 @@\n+    public ValueNode getActualId() {\n+        return actualId;\n+    }\n\n+    public void setActualId(ValueNode id) {\n+        actualId = id;\n+        if (actualId instanceof TextNode) {\n+            externalId = actualId.asText();\n+        } else if (actualId instanceof IntNode) {\n+            this.id = actualId.asInt();\n+        }\n     } ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/gitlab4j/api/utils/JacksonJson.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/gitlab4j/api/utils/JacksonJson.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/gitlab4j/api/utils/JacksonJson.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/gitlab4j/api/utils/JacksonJson.java\n@@ -132,7 +134,8 @@\n      */\n     public <T> List<T> unmarshalList(Class<T> returnType, Reader reader) throws JsonParseException, JsonMappingException, IOException {\n         ObjectMapper objectMapper = getContext(null);\n-        return (objectMapper.readValue(reader, new TypeReference<List<T>>() {}));\n+        CollectionType javaType = objectMapper.getTypeFactory().constructCollectionType(List.class, returnType);\n+        return (objectMapper.readValue(reader, javaType));\n     }\n \n     /**",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-62",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.cactoos.func.RepeatedFuncTest",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Repeat counter is equal or less than zero: 2",
                "methodName": "repeatsNullsResults"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 5,
            "linesMod": 0,
            "linesRem": 8,
            "methods": 1,
            "sizeInLines": 5
        },
        "program": "RegressionBug-62",
        "project": "RegressionBug-62",
        "repairOperators": [
            "condBranIfAdd",
            "exThrowsAdd",
            "objInstAdd",
            "condBranRem",
            "exThrowsRem",
            "objInstRem",
            "mcRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/cactoos/func/RepeatedFunc.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/cactoos/func/RepeatedFunc.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/cactoos/func/RepeatedFunc.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/cactoos/func/RepeatedFunc.java\n@@ -75,18 +74,15 @@\n \n     @Override\n     public Y apply(final X input) throws Exception {\n+        if (this.times <= 0) {\n+            throw new IllegalArgumentException(\n+                \"The number of repetitions must be at least 1\"\n+            );\n+        }\n         Y result = null;\n         for (int idx = 0; idx < this.times; ++idx) {\n             result = this.func.apply(input);\n         }\n-        if (result == null) {\n-            throw new IllegalArgumentException(\n-                new FormattedText(\n-                    \"Repeat counter is equal or less than zero: %d\",\n-                    this.times\n-                ).asString()\n-            );\n-        }\n         return result;\n     }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/cactoos/func/RepeatedFunc.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/cactoos/func/RepeatedFunc.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/cactoos/func/RepeatedFunc.java\t2024-09-16 17:27:21.926378618 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/cactoos/func/RepeatedFunc.java\t2024-09-16 17:27:21.894378315 +1000\n@@ -67,6 +68,14 @@\n         for (int idx = 0; idx < this.times; ++idx) {\n             result = this.func.apply(input);\n         }\n+        if (result == null) {\n+            throw new IllegalArgumentException(\n+                new FormattedText(\n+                    \"Repeat counter is equal or less than zero: %d\",\n+                    this.times\n+                ).asString()\n+            );\n+        }\n         return result;\n     }\n ",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-63",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.cronutils.model.time.ExecutionTimeCustomDefinitionIntegrationTest",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Cron expression contains 4 parts but we expect one of [6, 7]",
                "methodName": "testThreeRequiredFieldsSupported"
            },
            {
                "className": "com.cronutils.model.time.ExecutionTimeCustomDefinitionIntegrationTest",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Cron expression contains 5 parts but we expect one of [6, 7]",
                "methodName": "testFiveRequiredFieldsSupported"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 6,
            "linesMod": 0,
            "linesRem": 2,
            "methods": 1,
            "sizeInLines": 6
        },
        "program": "RegressionBug-63",
        "project": "RegressionBug-63",
        "repairOperators": [
            "condBranRem",
            "mcRem",
            "varAdd",
            "assignAdd",
            "loopAdd",
            "mcAdd",
            "objInstAdd",
            "assignExpChange"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/cronutils/parser/CronParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/cronutils/parser/CronParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/cronutils/parser/CronParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/cronutils/parser/CronParser.java\n@@ -58,9 +58,16 @@\n                 .sorted(CronParserField.createFieldTypeComparator())\n                 .collect(Collectors.toList());\n \n-        if (lastFieldIsOptional(sortedExpression)) {\n-            expressions.put(sortedExpression.size() - 1, new ArrayList<>(sortedExpression.subList(0, sortedExpression.size() - 1)));\n+        List<CronParserField> tempExpression = sortedExpression;\n+        while(lastFieldIsOptional(tempExpression)) {\n+            int expressionLength = tempExpression.size() - 1;\n+            ArrayList<CronParserField> possibleExpression = new ArrayList<>(tempExpression.subList(0, expressionLength));\n+            expressions.put(expressionLength, possibleExpression);\n+            tempExpression = possibleExpression;\n         }\n\n         expressions.put(sortedExpression.size(), sortedExpression);\n     }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/parser/CronParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/parser/CronParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/parser/CronParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/parser/CronParser.java\n@@ -50,23 +49,23 @@\n      * @param cronDefinition - cron definition instance\n      */\n     private void buildPossibleExpressions(CronDefinition cronDefinition) {\n-        List<CronParserField> sortedExpression = new ArrayList<>();\n-        Set<FieldDefinition> fieldDefinitions = cronDefinition.getFieldDefinitions();\n-        for (FieldDefinition fieldDefinition : fieldDefinitions) {\n-            sortedExpression.add(new CronParserField(fieldDefinition.getFieldName(), fieldDefinition.getConstraints(), fieldDefinition.isOptional()));\n-        }\n-        sortedExpression.sort(CronParserField.createFieldTypeComparator());\n-        ImmutableList.Builder<CronParserField> expressionBuilder = ImmutableList.builder();\n-        for (CronParserField field : sortedExpression) {\n-            if (field.isOptional()) {\n-                List<CronParserField> possibleExpression = expressionBuilder.build();\n-                expressions.put(possibleExpression.size(), possibleExpression);\n-            }\n+        List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n+                .map(this::toCronParserField)\n+                .sorted(CronParserField.createFieldTypeComparator())\n+                .collect(Collectors.toList());\n \n-            expressionBuilder.add(field);\n+        if (lastFieldIsOptional(sortedExpression)) {\n+            expressions.put(sortedExpression.size() - 1, new ArrayList<>(sortedExpression.subList(0, sortedExpression.size() - 1)));\n         }\n-        List<CronParserField> longestPossibleExpression = expressionBuilder.build();\n-        expressions.put(longestPossibleExpression.size(), longestPossibleExpression);\n+        expressions.put(sortedExpression.size(), sortedExpression);\n+    }\n\n+    private CronParserField toCronParserField(FieldDefinition fieldDefinition) {\n+        return new CronParserField(fieldDefinition.getFieldName(), fieldDefinition.getConstraints(), fieldDefinition.isOptional());\n+    }\n\n+    private boolean lastFieldIsOptional(List<CronParserField> fields) {\n+        return !fields.isEmpty() && fields.get(fields.size() - 1).isOptional();\n     }\n \n     /**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-64",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_1500.Issue1529",
                "error": "com.alibaba.fastjson.JSONException",
                "message": ": cast error, field : Id, value false",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 5,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 6
        },
        "program": "RegressionBug-64",
        "project": "RegressionBug-64",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "assignExpChange",
            "condBranIfAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java\t2024-09-24 22:13:50.865629784 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java\t2024-09-24 22:13:44.293568322 +1000\n@@ -929,7 +929,8 @@\n             // smartMatchHashArrayMapping\n \n             int pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n+            boolean is = false;\n-            if (pos < 0 && key.startsWith(\"is\")) {\n+            if (pos < 0 && (is = key.startsWith(\"is\"))) {\n                 smartKeyHash = TypeUtils.fnv_64_lower(key.substring(2));\n                 pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n             }\n@@ -951,6 +952,10 @@\n                 int deserIndex = smartMatchHashArrayMapping[pos];\n                 if (deserIndex != -1) {\n                     fieldDeserializer = sortedFieldDeserializers[deserIndex];\n+                    Class fieldClass = fieldDeserializer.fieldInfo.fieldClass;\n+                    if (is && (fieldClass != boolean.class && fieldClass != Boolean.class)) {\n+                        fieldDeserializer = null;\n+                    }\n                 }\n             }\n         }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java\n@@ -31,6 +31,8 @@\n     public final JavaBeanInfo         beanInfo;\n     private ConcurrentMap<String, Object> extraFieldDeserializers;\n \n+    private transient long[] smartMatchHashArray;\n+\n     public JavaBeanDeserializer(ParserConfig config, Class<?> clazz, Type type){\n         this(config, clazz, type, JavaBeanInfo.build(clazz, clazz.getModifiers(), type, false, true, true, true, config.propertyNamingStrategy));\n     }\n@@ -882,34 +884,7 @@\n         return null;  // key not found.\n     }\n \n-    private static char[] buildSmartKey(String key) {\n-        final int key_len = key.length();\n-\n-        char[] buf = new char[key_len];\n-\n-        int buf_size = 0;\n-        for (int i = 0, j = 0; i < key_len; ++i) {\n-            char ch = key.charAt(i);\n-            if (ch == '_' || ch == '-') {\n-                continue;\n-            }\n-\n-            if (ch >= 'A' && ch <= 'Z') {\n-                ch = (char) (ch + 32);\n-            }\n-            buf[buf_size++] = ch;\n-        }\n-\n-        if (buf_size == buf.length) {\n-            return buf;\n-        }\n \n-        char[] buf2 = new char[buf_size];\n-        for (int i = 0; i < buf_size; ++i) {\n-            buf2[i] = buf[i];\n-        }\n-        return buf2;\n-    }\n \n     private boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType,\n                               Map<String, Object> fieldValues) {\n@@ -918,59 +893,27 @@\n         FieldDeserializer fieldDeserializer = getFieldDeserializer(key);\n \n         if (fieldDeserializer == null) {\n-            char[] smartKey = buildSmartKey(key);\n-            char[] smartKey_is = null;\n-            boolean startsWithIs = key.startsWith(\"is\");\n-            for (FieldDeserializer fieldDeser : sortedFieldDeserializers) {\n-                FieldInfo fieldInfo = fieldDeser.fieldInfo;\n-                Class<?> fieldClass = fieldInfo.fieldClass;\n-                String fieldName = fieldInfo.name;\n-                if (fieldName.equalsIgnoreCase(key)) {\n-                    fieldDeserializer = fieldDeser;\n-                    break;\n-                }\n-                char[] fieldSmartMatchKey = fieldDeser.smartMatchKey;\n-                if (fieldSmartMatchKey == null) {\n-                    fieldSmartMatchKey = buildSmartKey(fieldName);\n-                    fieldDeser.smartMatchKey = fieldSmartMatchKey;\n-                }\n-                boolean eq = smartKey.length == fieldSmartMatchKey.length;\n-                if (eq) {\n-                    for (int i = 0; i < smartKey.length; ++i) {\n-                        if (smartKey[i] != fieldSmartMatchKey[i]) {\n-                            eq = false;\n-                            break;\n-                        }\n-                    }\n-                }\n+            long smartKeyHash = TypeUtils.fnv_64_lower(key);\n+            if (this.smartMatchHashArray == null) {\n+                long[] hashArray = new long[sortedFieldDeserializers.length];\n+                for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n+                    hashArray[i] = TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name);\n+                }\n+                this.smartMatchHashArray = hashArray;\n+            }\n \n-                if (eq) {\n-                    fieldDeserializer = fieldDeser;\n+            for (int i = 0; i < this.smartMatchHashArray.length; i++) {\n+                if (this.smartMatchHashArray[i] == smartKeyHash) {\n+                    fieldDeserializer = sortedFieldDeserializers[i];\n                     break;\n                 }\n+            }\n \n-                if (startsWithIs //\n-                        && (fieldClass == boolean.class || fieldClass == Boolean.class)) {\n-                    if (smartKey_is == null) {\n-                        smartKey_is = buildSmartKey(key.substring(2));\n-                    }\n-                    eq = smartKey_is.length == fieldSmartMatchKey.length;\n-                    if (eq) {\n-                        for (int i = 0; i < smartKey_is.length; ++i) {\n-                            if (smartKey_is[i] != fieldSmartMatchKey[i]) {\n-                                eq = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    if (eq) {\n-                        fieldDeserializer = fieldDeser;\n+            if (fieldDeserializer == null && key.startsWith(\"is\")) {\n+                smartKeyHash = TypeUtils.fnv_64_lower(key.substring(2));\n+                for (int i = 0; i < this.smartMatchHashArray.length; i++) {\n+                    if (this.smartMatchHashArray[i] == smartKeyHash) {\n+                        fieldDeserializer = sortedFieldDeserializers[i];\n                         break;\n                     }\n                 }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/TypeUtils.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/TypeUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/TypeUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/TypeUtils.java\n@@ -1483,6 +1483,25 @@\n         return changed;\n     }\n \n+    public static long fnv_64_lower(String key) {\n+        long hashCode = 0x811c9dc5;\n+        for (int i = 0; i < key.length(); ++i) {\n+            char ch = key.charAt(i);\n+            if (ch == '_' || ch == '-') {\n+                continue;\n+            }\n+            if (ch >= 'A' && ch <= 'Z') {\n+                ch = (char) (ch + 32);\n+            }\n+            hashCode ^= ch;\n+            hashCode *= 0x1000193;\n+        }\n+        return hashCode;\n+    }\n\n //    public static long fnv_hash(char[] chars) {\n //        long hash = 0x811c9dc5;\n //        for (int i = 0; i < chars.length; ++i) {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-65",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.safety.CleanerTest",
                "error": "java.lang.NullPointerException",
                "message": "",
                "methodName": "handlesAttributesWithNoValue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-65",
        "project": "RegressionBug-65",
        "repairOperators": [
            "condBranIfElseAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/internal/Normalizer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/internal/Normalizer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/internal/Normalizer.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/internal/Normalizer.java\n@@ -8,7 +8,7 @@\n public final class Normalizer {\n \n     public static String lowerCase(final String input) {\n-        return input.toLowerCase(Locale.ENGLISH);\n+        return input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n     }\n \n     public static String normalize(final String input) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java\n@@ -10,8 +10,10 @@\n  * A minimal String utility class. Designed for internal jsoup use only.\n  */\n public final class StringUtil {\n-    private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\n     // memoised padding up to 21\n+    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n+        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n+        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n \n     /**\n      * Join a collection of strings by a separator\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attribute.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attribute.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attribute.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -20,7 +19,8 @@\n     };\n \n     private String key;\n     private String val;\n+    Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface\n \n     /**\n      * Create a new attribute from unencoded (raw) key and value.\n@@ -29,11 +29,21 @@\n      * @param val attribute value\n      * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n      * @see #createFromEncoded*/\n+    public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n-        Validate.notNull(val);\n         this.key = key.trim();\n         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n         this.val = val;\n+        this.parent = parent;\n     }\n \n     /**\n@@ -50,7 +60,13 @@\n      */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key.trim();\n+        key = key.trim();\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.keys[i] = key;\n+        }\n+        this.key = key;\n     }\n \n     /**\n@@ -58,18 +74,22 @@\n     public String setValue(String val) {\n-        Validate.notNull(value);\n-        String old = this.value;\n-        this.value = value;\n-        return old;\n+        String oldVal = parent.get(this.key);\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.vals[i] = val;\n+        }\n+        this.val = val;\n+        return oldVal;\n     }\n \n     /**\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attributes.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attributes.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attributes.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -29,83 +31,120 @@\n  */\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n+    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n+    private static final int GrowthFactor = 2;\n+    private static final String[] Empty = {};\n+    static final int NotFound = -1;\n+    private static final String EmptyString = \"\";\n\n+    private int size = 0; // number of slots used (not capacity, which is keys.length\n+    String[] keys = Empty;\n+    String[] vals = Empty;\n\n+    private void checkCapacity(int minNewSize) {\n+        Validate.isTrue(minNewSize >= size);\n+        int curSize = keys.length;\n+        if (curSize >= minNewSize)\n+            return;\n+\n+        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n+        if (minNewSize > newSize)\n+            newSize = minNewSize;\n \n-    private LinkedHashMap<String, Attribute> attributes = null;\n+        keys = Arrays.copyOf(keys, newSize);\n+        vals = Arrays.copyOf(vals, newSize);\n+    }\n+\n+    int indexOfKey(String key) {\n+        Validate.notNull(key);\n+        for (int i = 0; i < size; i++) {\n+            if (key.equals(keys[i]))\n+                return i;\n+        }\n+        return NotFound;\n+    }\n+\n+    private int indexOfKeyIgnoreCase(String key) {\n+        Validate.notNull(key);\n+        for (int i = 0; i < size; i++) {\n+            if (key.equalsIgnoreCase(keys[i]))\n+                return i;\n+        }\n+        return NotFound;\n+    }\n\n+    static final String checkNotNull(String val) {\n+        return val == null ? EmptyString : val;\n+    }\n \n     /**\n      Get an attribute value by key.\n      @param key the (case-sensitive) attribute key\n      @return the attribute value if set; or empty string if not set (or a boolean attribute).\n      @see #hasKey(String)\n      */\n     public String get(String key) {\n-        Validate.notEmpty(key);\n-\n-        if (attributes == null)\n-            return \"\";\n-\n-        Attribute attr = attributes.get(key);\n-        return attr != null ? attr.getValue() : \"\";\n+        int i = indexOfKey(key);\n+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n     }\n \n     /**\n      * Get an attribute's value by case-insensitive key\n      * @param key the attribute name\n      * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n      */\n     public String getIgnoreCase(String key) {\n-        Attribute attr = getAttributeIgnoreCase(key);\n-        return attr != null ? attr.getValue() : \"\";\n+        int i = indexOfKeyIgnoreCase(key);\n+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n     }\n \n-    private Attribute getAttributeIgnoreCase(String key) {\n-        Validate.notEmpty(key);\n-        if (attributes == null)\n-            return null;\n-\n-        Attribute attr = attributes.get(key);\n-        if (attr != null)\n-            return attr;\n-\n-        for (String attrKey : attributes.keySet()) {\n-            if (attrKey.equalsIgnoreCase(key))\n-                return attributes.get(attrKey);\n-        }\n-        return null;\n     // adds without checking if this key exists\n+    private void add(String key, String value) {\n+        checkCapacity(size + 1);\n+        keys[size] = key;\n+        vals[size] = value;\n+        size++;\n     }\n \n     /**\n      * Set a new attribute, or replace an existing one by key.\n      * @param key case sensitive attribute key\n      * @param value attribute value\n      * @return these attributes, for chaining\n      */\n     public Attributes put(String key, String value) {\n-        Attribute attr = new Attribute(key, value);\n-        put(attr);\n+        int i = indexOfKey(key);\n+        if (i != NotFound)\n+            vals[i] = value;\n+        else\n+            add(key, value);\n         return this;\n     }\n \n     /**\n      * Set a new boolean attribute, remove attribute if value is false.\n@@ -165,13 +210,7 @@\n      @return true if key exists, false otherwise\n      */\n     public boolean hasKeyIgnoreCase(String key) {\n-        if (attributes == null)\n-            return false;\n-        for (String attrKey : attributes.keySet()) {\n-            if (attrKey.equalsIgnoreCase(key))\n-                return true;\n-        }\n-        return false;\n+        return indexOfKeyIgnoreCase(key) != NotFound;\n     }\n \n     /**\n@@ -191,31 +228,49 @@\n     public Iterator<Attribute> iterator() {\n-        if (attributes == null || attributes.isEmpty()) {\n-            return Collections.<Attribute>emptyList().iterator();\n-        }\n+        return new Iterator<Attribute>() {\n+            int i = 0;\n \n-        return attributes.values().iterator();\n+            @Override\n+            public boolean hasNext() {\n+                return i < size;\n+            }\n+\n+            @Override\n+            public Attribute next() {\n+                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n+                i++;\n+                return attr;\n+            }\n+\n+            @Override\n+            public void remove() {\n+                Attributes.this.remove(--i); // next() advanced, so rewind\n+            }\n+        };\n     }\n \n@@ -281,31 +346,40 @@\n     /**\n      * Internal method. Lowercases all keys.\n      */\n+    public void normalize() {\n+        for (int i = 0; i < size; i++) {\n+            keys[i] = lowerCase(keys[i]);\n+        }\n+    }\n\n     private static class Dataset extends AbstractMap<String, String> {\n         private final Attributes attributes;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Document.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Document.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Document.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Document.java\n@@ -372,13 +372,9 @@\n \n         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\n         private Charset charset;\n-        private final ThreadLocal<CharsetEncoder> encoder = new ThreadLocal<CharsetEncoder>() {\n-            @Override\n-            protected CharsetEncoder initialValue() {\n-                return charset.newEncoder();\n-            }\n-        };\n+        CharsetEncoder encoder; // initialized by start of OuterHtmlVisitor and cleared at end\n+        Entities.CoreCharset coreCharset; // fast encoders for ascii and utf8\n\n         private boolean prettyPrint = true;\n         private boolean outline = false;\n         private int indentAmount = 1;\n@@ -430,7 +426,6 @@\n          */\n         public OutputSettings charset(Charset charset) {\n             this.charset = charset;\n-            encoder.remove();\n             return this;\n         }\n\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java\n@@ -69,7 +67,7 @@\n         String val = attributes().getIgnoreCase(attributeKey);\n         if (val.length() > 0)\n             return val;\n-        else if (lowerCase(attributeKey).startsWith(\"abs:\"))\n+        else if (attributeKey.startsWith(\"abs:\"))\n             return absUrl(attributeKey.substring(\"abs:\".length()));\n         else return \"\";\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/ParseSettings.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/ParseSettings.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/ParseSettings.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/ParseSettings.java\n@@ -52,9 +51,7 @@\n \n     Attributes normalizeAttributes(Attributes attributes) {\n         if (!preserveAttributeCase) {\n-            for (Attribute attr : attributes) {\n-                attr.setKey(lowerCase(attr.getKey()));\n-            }\n+            attributes.normalize();\n         }\n         return attributes;\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Token.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Token.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Token.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Token.java\n@@ -107,15 +105,14 @@\n                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                 pendingAttributeName = pendingAttributeName.trim();\n                 if (pendingAttributeName.length() > 0) {\n-                    Attribute attribute;\n+                    String value;\n                     if (hasPendingAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName,\n-                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                     else if (hasEmptyAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName, \"\");\n+                        value = \"\";\n                     else\n-                        attribute = new BooleanAttribute(pendingAttributeName);\n-                    attributes.put(attribute);\n+                        value = null;\n+                    attributes.put(pendingAttributeName, value);\n                 }\n             }\n             pendingAttributeName = null;",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-66",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.parser.HtmlParserTest",
                "error": "java.lang.StringIndexOutOfBoundsException",
                "message": ": String index out of range: -1",
                "methodName": "commentAtEnd"
            },
            {
                "className": "org.jsoup.parser.CharacterReaderTest",
                "error": "java.lang.StringIndexOutOfBoundsException",
                "message": ": String index out of range: -1",
                "methodName": "consumeToNonexistentEndWhenAtAnd"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-66",
        "project": "RegressionBug-66",
        "repairOperators": [
            "condBranIfAdd",
            "retBranchAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/parser/CharacterReader.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/parser/CharacterReader.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -424,6 +424,8 @@\n         // limit (no cache):\n         if (count > maxStringCacheLen)\n             return new String(charBuf, start, count);\n+        if (count < 1)\n+            return \"\";\n \n         // calculate hash:\n         int hash = 0;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/DataUtil.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/DataUtil.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/DataUtil.java\t2024-09-08 01:36:20.265851673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/DataUtil.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -1,15 +1,19 @@\n package org.jsoup.helper;\n \n+import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.XmlDeclaration;\n import org.jsoup.parser.Parser;\n import org.jsoup.select.Elements;\n \n+import java.io.BufferedReader;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.io.OutputStream;\n import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n@@ -25,9 +29,10 @@\n  *\n  */\n public final class DataUtil {\n-    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n+    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n-    private static final int bufferSize = 60000;\n+    private static final int firstReadBufferSize = 1024 * 5;\n+    static final int bufferSize = 1024 * 32;\n     private static final char[] mimeBoundaryChars =\n             \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n     static final int boundaryLength = 32;\n@@ -43,8 +48,7 @@\n      * @throws IOException on IO error\n      */\n     public static Document load(File in, String charsetName, String baseUri) throws IOException {\n-        ByteBuffer byteData = readFileToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n     }\n \n     /**\n@@ -56,8 +60,7 @@\n      * @throws IOException on IO error\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n-        ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n     }\n \n     /**\n@@ -70,8 +73,7 @@\n      * @throws IOException on IO error\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n-        ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, parser);\n+        return parseInputStream(in, charsetName, baseUri, parser);\n     }\n\n@@ -88,57 +90,70 @@\n         }\n     }\n \n-    // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n-    // todo - this is getting gnarly. needs a rewrite.\n-    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n-        String docData;\n+    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n+        if (input == null) // empty body\n+            return new Document(baseUri);\n+\n+        if (!(input instanceof ConstrainableInputStream))\n+            input = new ConstrainableInputStream(input, bufferSize, 0);\n+\n         Document doc = null;\n+        boolean fullyRead = false;\n+\n+        // read the start of the stream and look for a BOM or meta charset\n+        input.mark(firstReadBufferSize);\n+        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed\n+        fullyRead = input.read() == -1;\n+        input.reset();\n \n         // look for BOM - overrides any other header or input\n-        charsetName = detectCharsetFromBom(byteData, charsetName);\n+        BomCharset bomCharset = detectCharsetFromBom(firstBytes, charsetName);\n+        if (bomCharset != null) {\n+            charsetName = bomCharset.charset;\n+            input.skip(bomCharset.offset);\n+        }\n \n         if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n-            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n             doc = parser.parseInput(docData, baseUri);\n+\n+            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n             Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n             String foundCharset = null; // if not found, will keep utf-8 as best attempt\n             for (Element meta : metaElements) {\n-                if (meta.hasAttr(\"http-equiv\")) {\n+                if (meta.hasAttr(\"http-equiv\"))\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                }\n-                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n+                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                     foundCharset = meta.attr(\"charset\");\n-                }\n-                if (foundCharset != null) {\n+                if (foundCharset != null)\n                     break;\n-                }\n             }\n \n             // look for <?xml encoding='ISO-8859-1'?>\n             if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n                 XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-                if (prolog.name().equals(\"xml\")) {\n+                if (prolog.name().equals(\"xml\"))\n                     foundCharset = prolog.attr(\"encoding\");\n-                }\n             }\n             foundCharset = validateCharset(foundCharset);\n             if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n-                byteData.rewind();\n-                docData = Charset.forName(foundCharset).decode(byteData).toString();\n+                doc = null;\n+            } else if (!fullyRead) {\n                 doc = null;\n             }\n         } else { // specified by content type header (or by user on file load)\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n-            docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         if (doc == null) {\n-            doc = parser.parseInput(docData, baseUri);\n+            if (charsetName == null)\n+                charsetName = defaultCharset;\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+            doc = parser.parseInput(reader, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }\n+        input.close();\n         return doc;\n     }\n \n@@ -153,16 +168,17 @@\n     public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n         Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n         final boolean capped = maxSize > 0;\n-        byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n-        ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n+        final byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n+\n         int read;\n         int remaining = maxSize;\n \n-        while (!Thread.interrupted()) {\n+        while (true) {\n             read = inStream.read(buffer);\n             if (read == -1) break;\n             if (capped) {\n-                if (read > remaining) {\n+                if (read >= remaining) {\n                     outStream.write(buffer, 0, remaining);\n                     break;\n                 }\n@@ -170,7 +186,6 @@\n             }\n             outStream.write(buffer, 0, read);\n         }\n-\n         return ByteBuffer.wrap(outStream.toByteArray());\n     }\n \n@@ -237,7 +252,7 @@\n         return mime.toString();\n     }\n \n-    private static String detectCharsetFromBom(ByteBuffer byteData, String charsetName) {\n+    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData, final String charsetName) {\n         byteData.mark();\n         byte[] bom = new byte[4];\n         if (byteData.remaining() >= bom.length) {\n@@ -246,14 +261,24 @@\n         }\n         if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n             bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n-            charsetName = \"UTF-32\"; // and I hope it's on your system\n+            return new BomCharset(\"UTF-32\", 0); // and I hope it's on your system\n         } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n             bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n-            charsetName = \"UTF-16\"; // in all Javas\n+            return new BomCharset(\"UTF-16\", 0); // in all Javas\n         } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n-            charsetName = \"UTF-8\"; // in all Javas\n-            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n+            return new BomCharset(\"UTF-8\", 3); // in all Javas\n+            // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n+        }\n+        return null;\n+    }\n+\n+    private static class BomCharset {\n+        private final String charset;\n+        private final int offset;\n+\n+        public BomCharset(String charset, int offset) {\n+            this.charset = charset;\n+            this.offset = offset;\n         }\n-        return charsetName;\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/HttpConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/HttpConnection.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/HttpConnection.java\t2024-09-08 01:36:20.265851673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/HttpConnection.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -1,20 +1,46 @@\n package org.jsoup.helper;\n \n-import org.jsoup.*;\n+import org.jsoup.Connection;\n+import org.jsoup.HttpStatusException;\n+import org.jsoup.UncheckedIOException;\n+import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n-import javax.net.ssl.*;\n-import java.io.*;\n-import java.net.*;\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n import java.security.KeyManagementException;\n import java.security.NoSuchAlgorithmException;\n import java.security.cert.X509Certificate;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n \n@@ -26,7 +52,7 @@\n  * @see org.jsoup.Jsoup#connect(String)\n  */\n public class HttpConnection implements Connection {\n-    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n+    public static final String CONTENT_ENCODING = \"Content-Encoding\";\n     /**\n      * Many users would get caught by not setting a user-agent and therefore getting different responses on their desktop\n      * vs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.*/\n@@ -65,10 +91,12 @@\n         }\n \t}\n \n-\tprivate static URL encodeUrl(URL u) {\n+    static URL encodeUrl(URL u) {\n         try {\n             //  odd way to encode urls, but it works!\n-            final URI uri = new URI(u.toExternalForm());\n+            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)\n+            urlS = urlS.replaceAll(\" \", \"%20\");\n+            final URI uri = new URI(urlS);\n             return new URL(uri.toASCIIString());\n         } catch (Exception e) {\n             return u;\n@@ -601,9 +629,11 @@\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n+        private InputStream bodyStream;\n         private String charset;\n         private String contentType;\n         private boolean executed = false;\n+        private boolean inputStreamRead = false;\n         private int numRedirects = 0;\n         private Connection.Request req;\n \n@@ -701,23 +731,19 @@\n \n                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                 if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n-                    InputStream bodyStream = null;\n-                    try {\n-                        bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                        if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n-                            bodyStream = new GZIPInputStream(bodyStream);\n-\n-                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n-                    } finally {\n-                        if (bodyStream != null) bodyStream.close();\n-                    }\n+                    res.bodyStream = null;\n+                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n+                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n+                    res.bodyStream = new ConstrainableInputStream(res.bodyStream, DataUtil.bufferSize, req.maxBodySize());\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n                 }\n-            } finally {\n+            } catch (IOException e){\n                 // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                 // connection errors will not be released quickly enough and can cause a too many open files error.\n                 conn.disconnect();\n+                throw e;\n             }\n \n             res.executed = true;\n@@ -747,14 +773,32 @@\n \n         public Document parse() throws IOException {\n             Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n-            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n-            byteData.rewind();\n+            if (byteData != null) { // bytes have been read in to the buffer, parse that\n+                bodyStream = new ByteArrayInputStream(byteData.array());\n+                inputStreamRead = false; // ok to reparse if in bytes\n+            }\n+            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n+            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n+            // todo - disconnect here?\n+            inputStreamRead = true;\n             return doc;\n         }\n \n-        public String body() {\n+        private void prepareByteData() {\n             Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            if (byteData == null) {\n+                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n+                try {\n+                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        }\n+\n+        public String body() {\n+            prepareByteData();\n             // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n             String body;\n             if (charset == null)\n@@ -766,7 +810,7 @@\n         }\n \n         public byte[] bodyAsBytes() {\n-            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            prepareByteData();\n             return byteData.array();\n         }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/W3CDom.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/W3CDom.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/W3CDom.java\t2024-09-08 01:36:20.265851673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/W3CDom.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -120,7 +120,7 @@\n             for (Attribute attribute : source.attributes()) {\n                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n-                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n+                if (key.matches(\"[a-zA-Z_:][-a-zA-Z0-9_:.]*\"))\n                     el.setAttribute(key, attribute.getValue());\n             }\n         }\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/internal: ConstrainableInputStream.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Entities.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Entities.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Entities.java\t2024-09-08 01:36:20.265851673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Entities.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -1,14 +1,15 @@\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.DataUtil;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n import org.jsoup.parser.CharacterReader;\n import org.jsoup.parser.Parser;\n \n+import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.ByteBuffer;\n+import java.io.InputStreamReader;\n import java.nio.charset.Charset;\n import java.nio.charset.CharsetEncoder;\n import java.util.Arrays;\n@@ -26,6 +27,7 @@\n     private static final int empty = -1;\n     private static final String emptyName = \"\";\n     static final int codepointRadix = 36;\n+    private static final Charset ASCII = Charset.forName(\"ascii\");\n \n     public enum EscapeMode {\n@@ -301,48 +303,42 @@\n             throw new IllegalStateException(\"Could not read resource \" + file + \". Make sure you copy resources for \" + Entities.class.getCanonicalName());\n \n         int i = 0;\n-        try {\n-            ByteBuffer bytes = DataUtil.readToByteBuffer(stream, 0);\n-            String contents = Charset.forName(\"ascii\").decode(bytes).toString();\n-            CharacterReader reader = new CharacterReader(contents);\n+        BufferedReader input = new BufferedReader(new InputStreamReader(stream, ASCII));\n+        CharacterReader reader = new CharacterReader(input);\n \n-            while (!reader.isEmpty()) {\n-                // NotNestedLessLess=10913,824;1887\n+        while (!reader.isEmpty()) {\n+            // NotNestedLessLess=10913,824;1887\n \n-                final String name = reader.consumeTo('=');\n-                reader.advance();\n-                final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n-                final char codeDelim = reader.current();\n-                reader.advance();\n-                final int cp2;\n-                if (codeDelim == ',') {\n-                    cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n-                    reader.advance();\n-                } else {\n-                    cp2 = empty;\n-                }\n-                String indexS = reader.consumeTo('\\n');\n-                // default git checkout on windows will add a \\r there, so remove\n-                if (indexS.charAt(indexS.length() - 1) == '\\r') {\n-                    indexS = indexS.substring(0, indexS.length() - 1);\n-                }\n-                final int index = Integer.parseInt(indexS, codepointRadix);\n+            final String name = reader.consumeTo('=');\n+            reader.advance();\n+            final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n+            final char codeDelim = reader.current();\n+            reader.advance();\n+            final int cp2;\n+            if (codeDelim == ',') {\n+                cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n                 reader.advance();\n+            } else {\n+                cp2 = empty;\n+            }\n+            String indexS = reader.consumeTo('\\n');\n+            // default git checkout on windows will add a \\r there, so remove\n+            if (indexS.charAt(indexS.length() - 1) == '\\r') {\n+                indexS = indexS.substring(0, indexS.length() - 1);\n+            }\n+            final int index = Integer.parseInt(indexS, codepointRadix);\n+            reader.advance();\n \n-                e.nameKeys[i] = name;\n-                e.codeVals[i] = cp1;\n-                e.codeKeys[index] = cp1;\n-                e.nameVals[index] = name;\n-\n-                if (cp2 != empty) {\n-                    multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n-                }\n-                i++;\n-\n+            e.nameKeys[i] = name;\n+            e.codeVals[i] = cp1;\n+            e.codeKeys[index] = cp1;\n+            e.nameVals[index] = name;\n \n+            if (cp2 != empty) {\n+                multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n             }\n-        } catch (IOException err) {\n-            throw new IllegalStateException(\"Error reading resource \" + file);\n+            i++;\n         }\n+        Validate.isTrue(i == size, \"Unexpected count of entities loaded for \" + file);\n     }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/CharacterReader.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/CharacterReader.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/CharacterReader.java\t2024-09-08 01:36:20.265851673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/CharacterReader.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -1,7 +1,11 @@\n package org.jsoup.parser;\n \n+import org.jsoup.UncheckedIOException;\n import org.jsoup.helper.Validate;\n \n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.Arrays;\n import java.util.Locale;\n \n@@ -10,18 +14,51 @@\n  */\n public final class CharacterReader {\n     static final char EOF = (char) -1;\n-    private static final int maxCacheLen = 12;\n-\n-    private final char[] input;\n-    private final int length;\n-    private int pos = 0;\n-    private int mark = 0;\n+    private static final int maxStringCacheLen = 12;\n+    private static final int maxBufferLen = 1024 * 32;\n+    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n+\n+    private final char[] charBuf;\n+    private final Reader reader;\n+    private int bufLength;\n+    private int bufSplitPoint;\n+    private int bufPos;\n+    private int readerPos;\n+    private int bufMark;\n     private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n-    public CharacterReader(String input) {\n+    public CharacterReader(Reader input, int sz) {\n         Validate.notNull(input);\n-        this.input = input.toCharArray();\n-        this.length = this.input.length;\n+        Validate.isTrue(input.markSupported());\n+        reader = input;\n+        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n+        bufferUp();\n+    }\n+\n+    public CharacterReader(Reader input) {\n+        this(input, maxBufferLen);\n+    }\n+\n+    public CharacterReader(String input) {\n+        this(new StringReader(input), input.length());\n+    }\n+\n+    private void bufferUp() {\n+        if (bufPos < bufSplitPoint)\n+            return;\n+\n+        try {\n+            readerPos += bufPos;\n+            reader.skip(bufPos);\n+            reader.mark(maxBufferLen);\n+            bufLength = reader.read(charBuf);\n+            reader.reset();\n+            bufPos = 0;\n+            bufMark = 0;\n+            bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /**\n@@ -29,7 +66,7 @@\n      * @return current position\n      */\n     public int pos() {\n-        return pos;\n+        return readerPos + bufPos;\n     }\n \n     /**\n@@ -37,7 +74,7 @@\n      * @return true if nothing left to read.\n      */\n     public boolean isEmpty() {\n-        return pos >= length;\n+        return bufPos >= bufLength;\n     }\n \n     /**\n@@ -45,36 +82,34 @@\n      * @return char\n      */\n     public char current() {\n-        return pos >= length ? EOF : input[pos];\n+        bufferUp();\n+        return isEmpty() ? EOF : charBuf[bufPos];\n     }\n \n     char consume() {\n-        char val = pos >= length ? EOF : input[pos];\n-        pos++;\n+        bufferUp();\n+        char val = isEmpty() ? EOF : charBuf[bufPos];\n+        bufPos++;\n         return val;\n     }\n \n     void unconsume() {\n-        pos--;\n+        bufPos--;\n     }\n \n     /**\n      * Moves the current position by one.\n      */\n     public void advance() {\n-        pos++;\n+        bufPos++;\n     }\n \n     void mark() {\n-        mark = pos;\n+        bufMark = bufPos;\n     }\n \n     void rewindToMark() {\n-        pos = mark;\n-    }\n-\n-    String consumeAsString() {\n-        return new String(input, pos++, 1);\n+        bufPos = bufMark;\n     }\n \n     /**\n@@ -84,9 +119,10 @@\n      */\n     int nextIndexOf(char c) {\n         // doesn't handle scanning for surrogates\n-        for (int i = pos; i < length; i++) {\n-            if (c == input[i])\n-                return i - pos;\n+        bufferUp();\n+        for (int i = bufPos; i < bufLength; i++) {\n+            if (c == charBuf[i])\n+                return i - bufPos;\n         }\n         return -1;\n     }\n@@ -98,18 +134,19 @@\n      * @return offset between current position and next instance of target. -1 if not found.\n      */\n     int nextIndexOf(CharSequence seq) {\n+        bufferUp();\n         // doesn't handle scanning for surrogates\n         char startChar = seq.charAt(0);\n-        for (int offset = pos; offset < length; offset++) {\n+        for (int offset = bufPos; offset < bufLength; offset++) {\n             // scan to first instance of startchar:\n-            if (startChar != input[offset])\n-                while(++offset < length && startChar != input[offset]) { /* empty */ }\n+            if (startChar != charBuf[offset])\n+                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length && last <= length) {\n-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n+            if (offset < bufLength && last <= bufLength) {\n+                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                 if (i == last) // found full sequence\n-                    return offset - pos;\n+                    return offset - bufPos;\n             }\n         }\n         return -1;\n@@ -123,8 +160,8 @@\n     public String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = cacheString(pos, offset);\n-            pos += offset;\n+            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n+            bufPos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n@@ -134,8 +171,8 @@\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = cacheString(pos, offset);\n-            pos += offset;\n+            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n+            bufPos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n@@ -148,154 +185,165 @@\n      * @return characters read up to the matched delimiter.\n      */\n     public String consumeToAny(final char... chars) {\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n \n-        OUTER: while (pos < remaining) {\n+        OUTER: while (bufPos < remaining) {\n             for (char c : chars) {\n-                if (val[pos] == c)\n+                if (val[bufPos] == c)\n                     break OUTER;\n             }\n-            pos++;\n+            bufPos++;\n         }\n \n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeToAnySorted(final char... chars) {\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n \n-        while (pos < remaining) {\n-            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n+        while (bufPos < remaining) {\n+            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n                 break;\n-            pos++;\n+            bufPos++;\n         }\n \n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeData() {\n         // &, <, null\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n \n-        while (pos < remaining) {\n-            final char c = val[pos];\n+        while (bufPos < remaining) {\n+            final char c = val[bufPos];\n             if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                 break;\n-            pos++;\n+            bufPos++;\n         }\n \n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeTagName() {\n         // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n \n-        while (pos < remaining) {\n-            final char c = val[pos];\n+        while (bufPos < remaining) {\n+            final char c = val[bufPos];\n             if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                 break;\n-            pos++;\n+            bufPos++;\n         }\n \n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = cacheString(pos, length-pos);\n-        pos = length;\n+        bufferUp();\n+        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n+        bufPos = bufLength;\n         return data;\n     }\n \n     String consumeLetterSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n \n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n         while (!isEmpty()) {\n-            char c = input[pos];\n+            char c = charBuf[bufPos];\n             if (c >= '0' && c <= '9')\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n \n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeHexSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeDigitSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if (c >= '0' && c <= '9')\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     boolean matches(char c) {\n-        return !isEmpty() && input[pos] == c;\n+        return !isEmpty() && charBuf[bufPos] == c;\n \n     }\n \n     boolean matches(String seq) {\n+        bufferUp();\n         int scanLength = seq.length();\n-        if (scanLength > length - pos)\n+        if (scanLength > bufLength - bufPos)\n             return false;\n \n         for (int offset = 0; offset < scanLength; offset++)\n-            if (seq.charAt(offset) != input[pos+offset])\n+            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                 return false;\n         return true;\n     }\n \n     boolean matchesIgnoreCase(String seq) {\n+        bufferUp();\n         int scanLength = seq.length();\n-        if (scanLength > length - pos)\n+        if (scanLength > bufLength - bufPos)\n             return false;\n \n         for (int offset = 0; offset < scanLength; offset++) {\n             char upScan = Character.toUpperCase(seq.charAt(offset));\n-            char upTarget = Character.toUpperCase(input[pos + offset]);\n+            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n             if (upScan != upTarget)\n                 return false;\n         }\n@@ -306,7 +354,8 @@\n         if (isEmpty())\n             return false;\n \n-        char c = input[pos];\n+        bufferUp();\n+        char c = charBuf[bufPos];\n         for (char seek : seq) {\n             if (seek == c)\n                 return true;\n@@ -315,26 +364,28 @@\n     }\n \n     boolean matchesAnySorted(char[] seq) {\n-        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+        bufferUp();\n+        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n     }\n \n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n-        char c = input[pos];\n+        char c = charBuf[bufPos];\n         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n     }\n \n     boolean matchesDigit() {\n         if (isEmpty())\n             return false;\n-        char c = input[pos];\n+        char c = charBuf[bufPos];\n         return (c >= '0' && c <= '9');\n     }\n \n     boolean matchConsume(String seq) {\n+        bufferUp();\n         if (matches(seq)) {\n-            pos += seq.length();\n+            bufPos += seq.length();\n             return true;\n         } else {\n             return false;\n@@ -343,7 +394,7 @@\n \n     boolean matchConsumeIgnoreCase(String seq) {\n         if (matchesIgnoreCase(seq)) {\n-            pos += seq.length();\n+            bufPos += seq.length();\n             return true;\n         } else {\n             return false;\n@@ -359,7 +410,7 @@\n \n     @Override\n     public String toString() {\n-        return new String(input, pos, length - pos);\n+        return new String(charBuf, bufPos, bufLength - bufPos);\n     }\n \n     /**\n@@ -369,34 +420,31 @@\n      * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n      * some more duplicates.\n      */\n-    private String cacheString(final int start, final int count) {\n-        final char[] val = input;\n-        final String[] cache = stringCache;\n-\n+    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n         // limit (no cache):\n-        if (count > maxCacheLen)\n-            return new String(val, start, count);\n+        if (count > maxStringCacheLen)\n+            return new String(charBuf, start, count);\n \n         // calculate hash:\n         int hash = 0;\n         int offset = start;\n         for (int i = 0; i < count; i++) {\n-            hash = 31 * hash + val[offset++];\n+            hash = 31 * hash + charBuf[offset++];\n         }\n \n         // get from cache\n-        final int index = hash & cache.length - 1;\n-        String cached = cache[index];\n+        final int index = hash & stringCache.length - 1;\n+        String cached = stringCache[index];\n \n         if (cached == null) { // miss, add\n-            cached = new String(val, start, count);\n-            cache[index] = cached;\n+            cached = new String(charBuf, start, count);\n+            stringCache[index] = cached;\n         } else { // hashcode hit, check equality\n-            if (rangeEquals(start, count, cached)) { // hit\n+            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                 return cached;\n             } else { // hashcode conflict\n-                cached = new String(val, start, count);\n-                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n+                cached = new String(charBuf, start, count);\n+                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n             }\n         }\n         return cached;\n@@ -405,17 +453,21 @@\n     /**\n      * Check if the value of the provided range equals the string.\n      */\n-    boolean rangeEquals(final int start, int count, final String cached) {\n+    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n         if (count == cached.length()) {\n-            char one[] = input;\n             int i = start;\n             int j = 0;\n             while (count-- != 0) {\n-                if (one[i++] != cached.charAt(j++))\n+                if (charBuf[i++] != cached.charAt(j++))\n                     return false;\n             }\n             return true;\n         }\n         return false;\n     }\n+\n+    // just used for testing\n+    boolean rangeEquals(final int start, final int count, final String cached) {\n+        return rangeEquals(charBuf, start, count, cached);\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2024-09-08 01:36:20.265851673 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -11,6 +11,8 @@\n import org.jsoup.nodes.TextNode;\n import org.jsoup.select.Elements;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.List;\n \n@@ -56,7 +58,7 @@\n     }\n \n     @Override\n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         super.initialiseParse(input, baseUri, errors, settings);\n \n         // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n@@ -77,7 +79,7 @@\n     List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         // context may be null\n         state = HtmlTreeBuilderState.Initial;\n-        initialiseParse(inputFragment, baseUri, errors, settings);\n+        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Parser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Parser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Parser.java\t2024-09-08 01:36:20.269851701 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Parser.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -4,6 +4,8 @@\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n\n@@ -29,7 +31,12 @@\n     \n     public Document parseInput(String html, String baseUri) {\n         errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        return treeBuilder.parse(html, baseUri, errors, settings);\n+        return treeBuilder.parse(new StringReader(html), baseUri, errors, settings);\n+    }\n+\n+    public Document parseInput(Reader inputHtml, String baseUri) {\n+        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n+        return treeBuilder.parse(inputHtml, baseUri, errors, settings);\n     }\n \n     // gets & sets\n@@ -97,7 +104,7 @@\n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+        return treeBuilder.parse(new StringReader(html), baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/TokeniserState.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/TokeniserState.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/TokeniserState.java\t2024-09-08 01:36:20.269851701 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/TokeniserState.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -1678,7 +1678,7 @@\n                 t.emit(new Token.EOF());\n                 break;\n             default:\n-                String data = r.consumeToAny('<', nullChar);\n+                String data = r.consumeToAny('<', nullChar); // todo - why hunt for null here? Just consumeTo'<'?\n                 t.emit(data);\n                 break;\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/TreeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/TreeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/TreeBuilder.java\t2024-09-08 01:36:20.269851701 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/TreeBuilder.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -5,6 +5,7 @@\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n+import java.io.Reader;\n import java.util.ArrayList;\n \n\n@@ -25,7 +26,7 @@\n \n     abstract ParseSettings defaultSettings();\n \n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         Validate.notNull(input, \"String input must not be null\");\n         Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n@@ -39,7 +40,7 @@\n         this.baseUri = baseUri;\n     }\n \n-    Document parse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         initialiseParse(input, baseUri, errors, settings);\n         runParser();\n         return doc;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/XmlTreeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\t2024-09-08 01:36:20.269851701 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -4,6 +4,8 @@\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n \n\n@@ -18,12 +20,16 @@\n         return ParseSettings.preserveCase;\n     }\n \n-    Document parse(String input, String baseUri) {\n+    Document parse(Reader input, String baseUri) {\n         return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n     }\n \n+    Document parse(String input, String baseUri) {\n+        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n+    }\n+\n     @Override\n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         super.initialiseParse(input, baseUri, errors, settings);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n         doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n@@ -130,7 +136,7 @@\n     }\n \n     List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n-        initialiseParse(inputFragment, baseUri, errors, settings);\n+        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n         runParser();\n         return doc.childNodes();\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/select/QueryParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/select/QueryParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/select/QueryParser.java\t2024-09-08 01:36:20.269851701 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/select/QueryParser.java\t2024-09-08 01:36:20.253851589 +1000\n@@ -286,8 +286,8 @@\n     }\n     \n     //pseudo selectors :first-child, :last-child, :nth-child, ...\n-    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n-    private static final Pattern NTH_B  = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\");\n+    private static final Pattern NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\");\n \n \tprivate void cssNthChild(boolean backwards, boolean ofType) {\n \t\tString argS = normalize(tq.chompTo(\")\"));\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup: UncheckedIOException.java",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-67",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.jsoup.nodes.TextNodeTest",
                "error": "java.lang.UnsupportedOperationException",
                "message": ": Leaf Nodes do not have child nodes.",
                "methodName": "testLeadNodesHaveNoChildren"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 3
        },
        "program": "RegressionBug-67",
        "project": "RegressionBug-67",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "mcAdd",
            "exThrowsRem",
            "retBranchAdd",
            "objInstRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/nodes/LeafNode.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/nodes/LeafNode.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/jsoup/nodes/LeafNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/jsoup/nodes/LeafNode.java\n@@ -2,9 +2,12 @@\n \n import org.jsoup.helper.Validate;\n \n+import java.util.Collections;\n import java.util.List;\n \n abstract class LeafNode extends Node {\n+    private static final List<Node> EmptyNodes = Collections.emptyList();\n\n     Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)\n \n     protected final boolean hasAttributes() {\n@@ -90,6 +93,6 @@\n \n     @Override\n     protected List<Node> ensureChildNodes() {\n-        throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n+        return EmptyNodes;\n     }\n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Element.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Element.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Element.java\t2024-09-08 01:36:20.341852205 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Element.java\t2024-09-08 01:36:20.333852149 +1000\n@@ -37,10 +38,13 @@\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Element extends Node {\n+    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n+    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n     private Tag tag;\n     private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\n\n-    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n+    List<Node> childNodes;\n+    private Attributes attributes;\n+    private String baseUri;\n \n     /**\n      * Create a new, standalone element.\n@@ -60,9 +64,11 @@\n      * @see #appendElement(String)\n      */\n     public Element(Tag tag, String baseUri, Attributes attributes) {\n-        super(baseUri, attributes);\n         Validate.notNull(tag);    \n+        Validate.notNull(baseUri);\n+        childNodes = EMPTY_NODES;\n+        this.baseUri = baseUri;\n+        this.attributes = attributes;\n         this.tag = tag;\n     }\n     \n@@ -75,7 +81,41 @@\n      * @see Tag#valueOf(String, ParseSettings)\n      */\n     public Element(Tag tag, String baseUri) {\n-        this(tag, baseUri, new Attributes());\n+        this(tag, baseUri, null);\n+    }\n\n+    protected List<Node> ensureChildNodes() {\n+        if (childNodes == EMPTY_NODES) {\n+            childNodes = new NodeList(4);\n+        }\n+        return childNodes;\n+    }\n\n     @Override\n     protected boolean hasAttributes() {\n         return attributes != null;\n     }\n\n     @Override\n     public Attributes attributes() {\n         if (!hasAttributes())\n             attributes = new Attributes();\n         return attributes;\n     }\n\n     @Override\n     public String baseUri() {\n         return baseUri;\n     }\n \n     @Override\n     protected void doSetBaseUri(String baseUri) {\n         this.baseUri = baseUri;\n     }\n\n+    @Override\n+    public int childNodeSize() {\n+        return childNodes.size();\n     }\n \n     @Override\n@@ -1344,4 +1385,26 @@\n         return clone;\n     }\n \n+    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n+        NodeList(int initialCapacity) {\n+            super(initialCapacity);\n+        }\n+\n+        public void onContentsChanged() {\n+            nodelistChanged();\n+        }\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/LeafNode.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/LeafNode.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/LeafNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/LeafNode.java\n+   @Override\n+    public int childNodeSize() {\n+        return 0;\n+    }\n\n+    @Override\n+    protected List<Node> ensureChildNodes() {\n+        throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n+    }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java\t2024-09-08 01:36:20.345852233 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java\t2024-09-08 01:36:20.333852149 +1000\n@@ -201,17 +190,19 @@\n         }\n     }\n \n+    protected abstract List<Node> ensureChildNodes();\n\n     /**\n      Get a child node by its 0-based index.\n      @param index index of child node\n      @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.\n      */\n     public Node childNode(int index) {\n-        return childNodes.get(index);\n+        return ensureChildNodes().get(index);\n     }\n \n     /**\n@@ -240,12 +232,10 @@\n      * Get the number of child nodes that this node holds.\n      * @return the number of child nodes that this node holds.\n      */\n-    public final int childNodeSize() {\n-        return childNodes.size();\n-    }\n \n+    public abstract int childNodeSize();\n\n     protected Node[] childNodesAsArray() {\n-        return childNodes.toArray(new Node[childNodeSize()]);\n+        return ensureChildNodes().toArray(new Node[childNodeSize()]);\n     }\n\n@@ -520,8 +508,8 @@\n     public Node nextSibling() {\n         if (parentNode == null)\n             return null; // root\n        \n-        final List<Node> siblings = parentNode.childNodes;\n+        final List<Node> siblings = parentNode.ensureChildNodes();\n         final int index = siblingIndex+1;\n         if (siblings.size() > index)\n             return siblings.get(index);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/TextNode.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/TextNode.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/TextNode.java\t2024-09-08 01:36:20.345852233 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/TextNode.java\t2024-09-08 01:36:20.333852149 +1000\n@@ -1,33 +1,36 @@ \n      @param text raw text\n      @see #createFromEncoded(String)\n\n+    public TextNode(String text) {\n+        value = text;\n+    }\n \n     /**\n      Create a new TextNode representing the supplied (unencoded) text).",
        "bugType": "Unmask"
    },
    {
        "bugId": "RegressionBug-68",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_2500.Issue2516",
                "error": "com.alibaba.fastjson.JSONException",
                "message": ": can not get javaBeanDeserializer. com.alibaba.fastjson.JSONObject",
                "methodName": "test_for_issue"
            },
            {
                "className": "com.alibaba.json.bvt.bug.bug2019.Bug20190729_01",
                "error": "com.alibaba.fastjson.JSONException",
                "message": ": Can not set java.lang.Integer field com.alibaba.json.bvt.bug.bug2019.Bug20190729_01$BucketInfo.bucketId to (int)123",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 7,
            "classes": 3,
            "files": 3,
            "linesAdd": 4,
            "linesMod": 6,
            "linesRem": 0,
            "methods": 3,
            "sizeInLines": 10
        },
        "program": "RegressionBug-68",
        "project": "RegressionBug-68",
        "repairOperators": [
            "condBranIfAdd",
            "retBranchAdd",
            "condExpExpand",
            "varAdd",
            "mcAdd",
            "assignExpChange",
            "condExpMod"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSON.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSON.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSON.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSON.java\n@@ -1107,6 +1107,10 @@\n      * @since 1.2.9\n      */\n     public <T> T toJavaObject(Class<T> clazz) {\n+        if (clazz == JSONArray.class || clazz == JSON.class || clazz == Collection.class || clazz == List.class) {\n+            return (T) this;\n+        }\n\n         return TypeUtils.cast(this, clazz, ParserConfig.getGlobalInstance());\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSONObject.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSONObject.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/JSONObject.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/JSONObject.java\n@@ -588,7 +588,7 @@\n     }\n \n     public <T> T toJavaObject(Class<T> clazz) {\n-        if (clazz == Map.class) {\n+        if (clazz == Map.class || clazz == JSONObject.class || clazz == JSON.class) {\n             return (T) this;\n         }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -1335,7 +1335,8 @@\n                 Type paramType = fieldInfo.fieldType;\n \n                 if (field != null) {\n-                    if (paramType == boolean.class) {\n+                    Class fieldType = field.getType();\n+                    if (fieldType == boolean.class) {\n                         if (value == Boolean.FALSE) {\n                             field.setBoolean(object, false);\n                             continue;\n@@ -1345,17 +1346,17 @@\n                             field.setBoolean(object, true);\n                             continue;\n                         }\n-                    } else if (paramType == int.class) {\n+                    } else if (fieldType == int.class) {\n                         if (value instanceof Number) {\n                             field.setInt(object, ((Number) value).intValue());\n                             continue;\n                         }\n-                    } else if (paramType == long.class) {\n+                    } else if (fieldType == long.class) {\n                         if (value instanceof Number) {\n                             field.setLong(object, ((Number) value).longValue());\n                             continue;\n                         }\n-                    } else if (paramType == float.class) {\n+                    } else if (fieldType == float.class) {\n                         if (value instanceof Number) {\n                             field.setFloat(object, ((Number) value).floatValue());\n                             continue;\n@@ -1371,7 +1372,7 @@\n                             field.setFloat(object, floatValue);\n                             continue;\n                         }\n-                    } else if (paramType == double.class) {\n+                    } else if (fieldType == double.class) {\n                         if (value instanceof Number) {\n                             field.setDouble(object, ((Number) value).doubleValue());\n                             continue;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -1284,12 +1284,59 @@\n                 }\n \n                 final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n+                Field field = fieldDeser.fieldInfo.field;\n                 Type paramType = fieldInfo.fieldType;\n\n+                if (paramType == boolean.class) {\n+                    if (value == Boolean.FALSE) {\n+                        field.setBoolean(object, false);\n+                        continue;\n+                    }\n+                    if (value == Boolean.TRUE) {\n+                        field.setBoolean(object, true);\n+                        continue;\n+                    }\n+                } else if (paramType == int.class) {\n+                    if (value instanceof Number) {\n+                        field.setInt(object, ((Number) value).intValue());\n+                        continue;\n+                    }\n+                } else if (paramType == long.class) {\n+                    if (value instanceof Number) {\n+                        field.setLong(object, ((Number) value).longValue());\n+                        continue;\n+                    }\n+                } else if (paramType == float.class) {\n+                    if (value instanceof Number) {\n+                        field.setFloat(object, ((Number) value).floatValue());\n+                        continue;\n+                    }\n+                } else if (paramType == double.class) {\n+                    if (value instanceof Number) {\n+                        field.setDouble(object, ((Number) value).doubleValue());\n+                        continue;\n+                    } else if (value instanceof String) {\n+                        double doubleValue = Double.parseDouble((String) value);\n+                        field.setDouble(object, doubleValue);\n+                        continue;\n+                    }\n+                } else if (value != null && paramType == value.getClass()) {\n+                    field.set(object, value);\n+                    continue;\n+                }\n\n                 String format = fieldInfo.format;\n                 if (format != null && paramType == java.util.Date.class) {\n                     value = TypeUtils.castToDate(value, format);\n                 } else {\n-                    value = TypeUtils.cast(value, paramType, config);\n+                    if (paramType instanceof ParameterizedType) {\n+                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n+                    } else {\n+                        value = TypeUtils.cast(value, paramType, config);\n+                    }\n                 }\n \n                 fieldDeser.setValue(object, value);",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-69",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.bug.bug2019.Bug20190729_01",
                "error": "com.alibaba.fastjson.JSONException",
                "message": ": Can not set java.lang.Integer field com.alibaba.json.bvt.bug.bug2019.Bug20190729_01$BucketInfo.bucketId to (int)123",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 5,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 5,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 6
        },
        "program": "RegressionBug-69",
        "project": "RegressionBug-69",
        "repairOperators": [
            "varReplVar",
            "varAdd",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -1335,7 +1335,8 @@\n                 Type paramType = fieldInfo.fieldType;\n \n                 if (field != null) {\n-                    if (paramType == boolean.class) {\n+                    Class fieldType = field.getType();\n+                    if (fieldType == boolean.class) {\n                         if (value == Boolean.FALSE) {\n                             field.setBoolean(object, false);\n                             continue;\n@@ -1345,17 +1346,17 @@\n                             field.setBoolean(object, true);\n                             continue;\n                         }\n-                    } else if (paramType == int.class) {\n+                    } else if (fieldType == int.class) {\n                         if (value instanceof Number) {\n                             field.setInt(object, ((Number) value).intValue());\n                             continue;\n                         }\n-                    } else if (paramType == long.class) {\n+                    } else if (fieldType == long.class) {\n                         if (value instanceof Number) {\n                             field.setLong(object, ((Number) value).longValue());\n                             continue;\n                         }\n-                    } else if (paramType == float.class) {\n+                    } else if (fieldType == float.class) {\n                         if (value instanceof Number) {\n                             field.setFloat(object, ((Number) value).floatValue());\n                             continue;\n@@ -1371,7 +1372,7 @@\n                             field.setFloat(object, floatValue);\n                             continue;\n                         }\n-                    } else if (paramType == double.class) {\n+                    } else if (fieldType == double.class) {\n                         if (value instanceof Number) {\n                             field.setDouble(object, ((Number) value).doubleValue());\n                             continue;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java\n@@ -1284,12 +1284,59 @@\n                 }\n \n                 final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n+                Field field = fieldDeser.fieldInfo.field;\n                 Type paramType = fieldInfo.fieldType;\n\n+                if (paramType == boolean.class) {\n+                    if (value == Boolean.FALSE) {\n+                        field.setBoolean(object, false);\n+                        continue;\n+                    }\n+                    if (value == Boolean.TRUE) {\n+                        field.setBoolean(object, true);\n+                        continue;\n+                    }\n+                } else if (paramType == int.class) {\n+                    if (value instanceof Number) {\n+                        field.setInt(object, ((Number) value).intValue());\n+                        continue;\n+                    }\n+                } else if (paramType == long.class) {\n+                    if (value instanceof Number) {\n+                        field.setLong(object, ((Number) value).longValue());\n+                        continue;\n+                    }\n+                } else if (paramType == float.class) {\n+                    if (value instanceof Number) {\n+                        field.setFloat(object, ((Number) value).floatValue());\n+                        continue;\n+                    }\n+                } else if (paramType == double.class) {\n+                    if (value instanceof Number) {\n+                        field.setDouble(object, ((Number) value).doubleValue());\n+                        continue;\n+                    } else if (value instanceof String) {\n+                        double doubleValue = Double.parseDouble((String) value);\n+                        field.setDouble(object, doubleValue);\n+                        continue;\n+                    }\n+                } else if (value != null && paramType == value.getClass()) {\n+                    field.set(object, value);\n+                    continue;\n+                }\n\n                 String format = fieldInfo.format;\n                 if (format != null && paramType == java.util.Date.class) {\n                     value = TypeUtils.castToDate(value, format);\n                 } else {\n-                    value = TypeUtils.cast(value, paramType, config);\n+                    if (paramType instanceof ParameterizedType) {\n+                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n+                    } else {\n+                        value = TypeUtils.cast(value, paramType, config);\n+                    }\n                 }\n \n                 fieldDeser.setValue(object, value);",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-70",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_1300.Issue1320",
                "error": "java.lang.ClassCastException",
                "message": ": java.lang.reflect.Method cannot be cast to java.lang.Class",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 1,
            "files": 1,
            "linesAdd": 4,
            "linesMod": 3,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 7
        },
        "program": "RegressionBug-70",
        "project": "RegressionBug-70",
        "repairOperators": [
            "varTyChange",
            "varAdd",
            "assignAdd",
            "condBranIfAdd",
            "mcAdd",
            "assignExpChange",
            "condExpMod",
            "loopCondChange"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/util/FieldInfo.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n@@ -343,16 +343,21 @@\n     }\n \n     private static Type getInheritGenericType(Class<?> clazz, Type type, TypeVariable<?> tv) {\n-        Class<?> gd = (Class<?>) tv.getGenericDeclaration();\n+        GenericDeclaration gd = tv.getGenericDeclaration();\n+        Class<?> class_gd = null;\n+        if (gd instanceof Class) {\n+            class_gd = (Class<?>) tv.getGenericDeclaration();\n+        }\n \n         Type[] arguments = null;\n-        if (gd == clazz) {\n+        if (class_gd == clazz) {\n             if (type instanceof ParameterizedType) {\n                 ParameterizedType ptype = (ParameterizedType) type;\n                 arguments = ptype.getActualTypeArguments();\n             }\n         } else {\n-            for (Class<?> c = clazz; c != null && c != Object.class && c != gd; c = c.getSuperclass()) {\n+            for (Class<?> c = clazz; c != null && c != Object.class && c != class_gd; c = c.getSuperclass()) {\n                 Type superType = c.getGenericSuperclass();\n \n                 if (superType instanceof ParameterizedType) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/FieldInfo.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n@@ -192,7 +192,7 @@\n \n         if (clazz != null && fieldClass == Object.class && fieldType instanceof TypeVariable) {\n             TypeVariable<?> tv = (TypeVariable<?>) fieldType;\n-            Type genericFieldType = getInheritGenericType(clazz, tv);\n+            Type genericFieldType = getInheritGenericType(clazz, type, tv);\n             if (genericFieldType != null) {\n                 this.fieldClass = TypeUtils.getClass(genericFieldType);\n                 this.fieldType = genericFieldType;\n@@ -330,35 +310,71 @@\n         return fieldType;\n     }\n \n-    public static Type getInheritGenericType(Class<?> clazz, TypeVariable<?> tv) {\n-        Type type = null;\n-        GenericDeclaration gd = tv.getGenericDeclaration();\n-        Type superGenericType = clazz.getGenericSuperclass();\n-        do {\n-            type = clazz.getGenericSuperclass();\n-            if (type == null) {\n-                return null;\n+    private static Type getInheritGenericType(Class<?> clazz, Type type, TypeVariable<?> tv) {\n+        Class<?> gd = (Class<?>) tv.getGenericDeclaration();\n+        Type[] arguments = null;\n+        if (gd == clazz) {\n             if (type instanceof ParameterizedType) {\n                 ParameterizedType ptype = (ParameterizedType) type;\n\n-                Type rawType = ptype.getRawType();\n-                boolean eq = gd.equals(rawType) || (gd instanceof Class && rawType instanceof Class && ((Class) gd).isAssignableFrom((Class) rawType));\n-                if (eq) {\n-                    TypeVariable<?>[] tvs = gd.getTypeParameters();\n-                    Type[] types = ptype.getActualTypeArguments();\n-                    for (int i = 0; i < tvs.length; i++) {\n-                        if (tv.equals(tvs[i])) {\n-                            return types[i];\n-                        }\n-                    }\n-                    return null;\n+                arguments = ptype.getActualTypeArguments();\n+            }\n+        } else {\n+            for (Class<?> c = clazz; c != null && c != Object.class && c != gd; c = c.getSuperclass()) {\n+                Type superType = c.getGenericSuperclass();\n+\n+                if (superType instanceof ParameterizedType) {\n+                    ParameterizedType p_superType = (ParameterizedType) superType;\n+                    Type[] p_superType_args = p_superType.getActualTypeArguments();\n+                    getArgument(p_superType_args, c.getTypeParameters(), arguments);\n+                    arguments = p_superType_args;\n                 }\n             }\n-            clazz = TypeUtils.getClass(type);\n-        } while (type != null);\n-        return null;\n+        }\n+        if (arguments == null) {\n+            return null;\n+        }\n+        Type actualType = null;\n+        TypeVariable<?>[] typeVariables = gd.getTypeParameters();\n+        for (int j = 0; j < typeVariables.length; ++j) {\n+            if (tv.equals(typeVariables[j])) {\n+                actualType = arguments[j];\n+                break;\n+            }\n+        }\n+        return actualType;\n     }\n \n     public String toString() {",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-71",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_1400.Issue1422",
                "error": "com.alibaba.fastjson.JSONException",
                "message": ": unclosed.str",
                "methodName": "test_for_issue_1"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 3,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-71",
        "project": "RegressionBug-71",
        "repairOperators": [
            "varAdd",
            "assignAdd",
            "assignExpChange",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n@@ -1438,6 +1438,7 @@\n             return false;\n         }\n \n+        int startPos = bp;\n         int index = bp + fieldName.length;\n \n         char ch = charAt(index++);\n@@ -1553,6 +1554,8 @@\n             } else if (isWhitespace(ch)) {\n                 ch = charAt(++bp);\n             } else {\n+                bp = startPos;\n+                ch = charAt(bp);\n                 matchStat = NOT_MATCH;\n                 return false;\n             }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java\n@@ -1249,6 +1278,11 @@\n \n         char ch = charAt(index++);\n \n+        final boolean quote = ch == '\"';\n+        if (quote) {\n+            ch = charAt(index++);\n+        }\n\n         boolean value;\n         if (ch == 't') {\n             if (charAt(index++) != 'r') {\n@@ -1285,9 +1324,32 @@\n                 return false;\n             }\n \n+            if (quote && charAt(index++) != '\"') {\n+                matchStat = NOT_MATCH;\n+                return false;\n+            }\n\n             bp = index;\n             ch = charAt(bp);\n             value = false;\n+        } else if (ch == '1') {\n+                if (quote && charAt(index++) != '\"') {\n+                    matchStat = NOT_MATCH;\n+                    return false;\n+                }\n+                bp = index;\n+                ch = charAt(bp);\n+                value = true;\n+        } else if (ch == '0') {\n+            if (quote && charAt(index++) != '\"') {\n+                matchStat = NOT_MATCH;\n+                return false;\n+            }\n+            bp = index;\n+            ch = charAt(bp);\n+            value = true;\n         } else {\n             matchStat = NOT_MATCH;\n             return false;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-72",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_2700.Issue2736",
                "error": "java.lang.ClassCastException",
                "message": ": java.lang.Integer cannot be cast to java.lang.String",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-72",
        "project": "RegressionBug-72",
        "repairOperators": [
            "condExpExpand"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n@@ -264,7 +265,7 @@\n                         } else {\n                             key = lexer.decimalValue(true);\n                         }\n-                        if (lexer.isEnabled(Feature.NonStringKeyAsString)) {\n+                        if (lexer.isEnabled(Feature.NonStringKeyAsString) || isJsonObjectMap) {\n                             key = key.toString();\n                         }\n                     } catch (NumberFormatException e) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/JSONObject.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/JSONObject.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/JSONObject.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/JSONObject.java\n@@ -464,4 +470,8 @@ \n         throw new UnsupportedOperationException(method.toGenericString());\n     }\n\n+    public Map<String, Object> getInnerMap() {\n+        return this.map;\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n@@ -203,6 +194,8 @@\n \n        ParseContext context = this.context;\n         try {\n+            Map map = object instanceof JSONObject ? ((JSONObject) object).getInnerMap() : object;\n\n             boolean setContextFlag = false;\n             for (;;) {\n                 lexer.skipWhitespace();\n@@ -446,7 +441,7 @@\n                         value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                     }\n \n-                    object.put(key, value);\n+                    map.put(key, value);\n                 } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                     lexer.nextToken();\n ",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-73",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_3000.Issue3031",
                "error": "java.lang.UnsupportedOperationException",
                "message": "",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 1,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-73",
        "project": "RegressionBug-73",
        "repairOperators": [
            "condExpExpand",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n@@ -398,6 +398,7 @@\n \n                 if (key == \"$ref\"\n                         && context != null\n+                        && (object == null || object.size() == 0)\n                         && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                     lexer.nextToken(JSONToken.LITERAL_STRING);\n                     if (lexer.token() == JSONToken.LITERAL_STRING) {",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java\n@@ -1446,10 +1446,21 @@\n             Object refValue;\n             if (ref.startsWith(\"$\")) {\n                 refValue = getObject(ref);\n+                if (refValue == null) {\n+                    try {\n+                        refValue = JSONPath.eval(value, ref);\n+                    } catch (JSONPathException ex) {\n+                        // skip\n+                    }\n+                }\n             } else {\n                 refValue = task.context.object;\n             }",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-74",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.JSONTypeTest_orders_arrayMapping",
                "error": "com.alibaba.fastjson.JSONException",
                "message": ": not close json text, token : string",
                "methodName": "test_2"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 5,
            "linesMod": 0,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-74",
        "project": "RegressionBug-74",
        "repairOperators": [
            "condBranIfAdd",
            "assignExpChange",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java\n@@ -1413,7 +1413,11 @@\n                 chLocal = charAt(bp + (offset++));\n                 continue;\n             } else {\n+                if (chLocal == ']') {\n+                    bp += offset;\n+                    this.ch = charAt(bp);\n                     matchStat = NOT_MATCH;\n+                }\n                 return strVal;\n             }\n         }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/JavaBeanInfo.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/JavaBeanInfo.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/JavaBeanInfo.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/JavaBeanInfo.java\n@@ -45,6 +41,8 @@\n     public final String         typeName;\n     public final String         typeKey;\n \n+    public String[]             orders;\n\n     public JavaBeanInfo(Class<?> clazz, //\n                         Class<?> builderClass, //\n                         Constructor<?> defaultConstructor, //\n@@ -72,17 +70,38 @@\n             } else {\n                 this.typeName = clazz.getName();\n             }\n+            String[] orders = jsonType.orders();\n+            this.orders = orders.length == 0 ? null : orders;\n         } else {\n             this.typeName = clazz.getName();\n             this.typeKey = null;\n+            this.orders = null;\n         }\n \n         fields = new FieldInfo[fieldList.size()];\n         fieldList.toArray(fields);\n \n         FieldInfo[] sortedFields = new FieldInfo[fields.length];\n+        if (orders != null) {\n+            LinkedHashMap<String, FieldInfo> map = new LinkedHashMap<String, FieldInfo>(fieldList.size());\n+            for (FieldInfo field : fields) {\n+                map.put(field.name, field);\n+            }\n+            int i = 0;\n+            for (String item : orders) {\n+                FieldInfo field = map.get(item);\n+                if (field != null) {\n+                    sortedFields[i++] = field;\n+                    map.remove(item);\n+                }\n+            }\n+            for (FieldInfo field : map.values()) {\n+                sortedFields[i++] = field;\n+            }\n+        } else {\n             System.arraycopy(fields, 0, sortedFields, 0, fields.length);\n             Arrays.sort(sortedFields);\n+        }\n \n         if (Arrays.equals(fields, sortedFields)) {\n             sortedFields = fields;",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-75",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_1300.Issue1306",
                "error": "java.lang.NullPointerException",
                "message": "",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-75",
        "project": "RegressionBug-75",
        "repairOperators": [
            "assignExpChange",
            "varReplVar",
            "varReplMc",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/util/FieldInfo.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n@@ -289,8 +289,8 @@\n             ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;\n \n             Type[] arguments = parameterizedFieldType.getActualTypeArguments();\n-            TypeVariable<?>[] typeVariables = null;\n+            TypeVariable<?>[] typeVariables = type.getClass().getTypeParameters();\n-            ParameterizedType paramType = null;\n+            ParameterizedType paramType = parameterizedFieldType;\n             if (type instanceof ParameterizedType) {\n                 paramType = (ParameterizedType) type;\n                 typeVariables = clazz.getTypeParameters();",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/FieldInfo.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/util/FieldInfo.java\n@@ -301,25 +298,8 @@\n                 paramType = (ParameterizedType) clazz.getGenericSuperclass();\n                 typeVariables = clazz.getSuperclass().getTypeParameters();\n             }\n         \n-            for (int i = 0; i < arguments.length && paramType != null; ++i) {\n-                Type feildTypeArguement = arguments[i];\n-                if (feildTypeArguement instanceof TypeVariable) {\n-                    TypeVariable<?> typeVar = (TypeVariable<?>) feildTypeArguement;\n-                    for (int j = 0; j < typeVariables.length; ++j) {\n-                        if (typeVariables[j].getName().equals(typeVar.getName())) {\n-                            if (actualTypes == null) {\n-                                actualTypes = paramType.getActualTypeArguments();\n-                            }\n-                            if (arguments[i] != actualTypes[j]) {\n-                                arguments[i] = actualTypes[j];\n-                                changed = true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n\n+            boolean changed = getArgument(arguments, typeVariables, paramType.getActualTypeArguments());\n             if (changed) {\n                 fieldType = new ParameterizedTypeImpl(arguments, parameterizedFieldType.getOwnerType(),\n                                                       parameterizedFieldType.getRawType());",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-76",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.cronutils.validator.CronValidatorQuartzIntegrationTest",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Failed to parse '20-10 0 0 ? * 3'. Invalid range! [20,10]",
                "methodName": "testOverflowRange"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 4,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-76",
        "project": "RegressionBug-76",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n@@ -258,10 +258,10 @@\n      */\n     private static CronDefinition quartz() {\n         return CronDefinitionBuilder.defineCron()\n-                .withSeconds().withStrictRange().and()\n+                .withSeconds().and()\n-                .withMinutes().withStrictRange().and()\n+                .withMinutes().and()\n-                .withHours().withStrictRange().and()\n+                .withHours().and()\n-                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().withStrictRange().and()\n+                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n                 .withMonth().withValidRange(1, 13).and()\n                 .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                 .withYear().withValidRange(1970, 2099).withStrictRange().optional().and()",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n@@ -34,7 +34,6 @@\n public class CronDefinitionBuilder {\n     private final Map<CronFieldName, FieldDefinition> fields = new EnumMap<>(CronFieldName.class);\n     private final Set<CronConstraint> cronConstraints = new HashSet<>();\n-    private boolean enforceStrictRanges;\n     private boolean matchDayOfWeekAndDayOfMonth;\n \n     /**\n@@ -124,16 +123,6 @@\n      *\n      * @return this CronDefinitionBuilder instance\n      */\n-    public CronDefinitionBuilder enforceStrictRanges() {\n-        enforceStrictRanges = true;\n-        return this;\n-    }\n \n     /**\n      * Sets matchDayOfWeekAndDayOfMonth value to true.*/\n@@ -183,7 +172,7 @@\n         validations.addAll(cronConstraints);\n         final List<FieldDefinition> values = new ArrayList<>(fields.values());\n         values.sort(FieldDefinition.createFieldDefinitionComparator());\n-        return new CronDefinition(values, validations, enforceStrictRanges, matchDayOfWeekAndDayOfMonth);\n+        return new CronDefinition(values, validations, matchDayOfWeekAndDayOfMonth);\n     }\n \n     /**\n@@ -193,12 +182,11 @@\n      */\n     private static CronDefinition cron4j() {\n         return CronDefinitionBuilder.defineCron()\n-                .withMinutes().and()\n-                .withHours().and()\n-                .withDayOfMonth().supportsL().and()\n-                .withMonth().and()\n-                .withDayOfWeek().withValidRange(0, 6).withMondayDoWValue(1).and()\n-                .enforceStrictRanges()\n+                .withMinutes().withStrictRange().and()\n+                .withHours().withStrictRange().and()\n+                .withDayOfMonth().supportsL().withStrictRange().and()\n+                .withMonth().withStrictRange().and()\n+                .withDayOfWeek().withValidRange(0, 6).withMondayDoWValue(1).withStrictRange().and()\n                 .matchDayOfWeekAndDayOfMonth()\n                 .instance();\n     }\n@@ -270,13 +258,13 @@\n      */\n     private static CronDefinition quartz() {\n         return CronDefinitionBuilder.defineCron()\n-                .withSeconds().and()\n-                .withMinutes().and()\n-                .withHours().and()\n-                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n+                .withSeconds().withStrictRange().and()\n+                .withMinutes().withStrictRange().and()\n+                .withHours().withStrictRange().and()\n+                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().withStrictRange().and()\n                 .withMonth().withValidRange(1, 13).and()\n                 .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n-                .withYear().withValidRange(1970, 2099).optional().and()\n+                .withYear().withValidRange(1970, 2099).withStrictRange().optional().and()\n                 .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                 .instance();\n     }\n@@ -342,9 +330,9 @@\n      */\n     private static CronDefinition spring() {\n         return CronDefinitionBuilder.defineCron()\n-                .withSeconds().and()\n-                .withMinutes().and()\n-                .withHours().and()\n+                .withSeconds().withStrictRange().and()\n+                .withMinutes().withStrictRange().and()\n+                .withHours().withStrictRange().and()\n                 .withDayOfMonth().supportsQuestionMark().and()\n                 .withMonth().and()\n                 .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsQuestionMark().and()\n@@ -358,12 +346,11 @@\n      */\n     private static CronDefinition unixCrontab() {\n         return CronDefinitionBuilder.defineCron()\n-                .withMinutes().and()\n-                .withHours().and()\n-                .withDayOfMonth().and()\n-                .withMonth().and()\n-                .withDayOfWeek().withValidRange(0, 7).withMondayDoWValue(1).withIntMapping(7, 0).and()\n-                .enforceStrictRanges()\n+                .withMinutes().withStrictRange().and()\n+                .withHours().withStrictRange().and()\n+                .withDayOfMonth().withStrictRange().and()\n+                .withMonth().withStrictRange().and()\n+                .withDayOfWeek().withValidRange(0, 7).withMondayDoWValue(1).withIntMapping(7, 0).withStrictRange().and()\n                 .instance();\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/definition/CronDefinition.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/definition/CronDefinition.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/definition/CronDefinition.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/definition/CronDefinition.java\n@@ -33,7 +33,6 @@\n     private static final long serialVersionUID = 7067112327461432170L;\n     private final Map<CronFieldName, FieldDefinition> fieldDefinitions;\n     private final Set<CronConstraint> cronConstraints;\n-    private final boolean strictRanges;\n     private final boolean matchDayOfWeekAndDayOfMonth;\n \n     /**\n@@ -43,8 +42,7 @@\n      *                         Throws a NullPointerException if a null values is received\n      *                         Throws an IllegalArgumentException if an empty list is received\n      */\n-    public CronDefinition(final List<FieldDefinition> fieldDefinitions, final Set<CronConstraint> cronConstraints,\n-            final boolean strictRanges, final boolean matchDayOfWeekAndDayOfMonth) {\n+    public CronDefinition(final List<FieldDefinition> fieldDefinitions, final Set<CronConstraint> cronConstraints, final boolean matchDayOfWeekAndDayOfMonth) {\n         Preconditions.checkNotNull(fieldDefinitions, \"Field definitions must not be null\");\n         Preconditions.checkNotNull(cronConstraints, \"Cron validations must not be null\");\n         Preconditions.checkNotNullNorEmpty(fieldDefinitions, \"Field definitions must not be empty\");\n@@ -54,20 +52,10 @@\n             this.fieldDefinitions.put(field.getFieldName(), field);\n         }\n         this.cronConstraints = Collections.unmodifiableSet(cronConstraints);\n-        this.strictRanges = strictRanges;\n         this.matchDayOfWeekAndDayOfMonth = matchDayOfWeekAndDayOfMonth;\n     }\n \n     /**\n-     * If ranges for field values should be strictly enforced ('from' greater than 'to').\n-     *\n-     * @return true if should be enforced, false otherwise.\n-     */\n-    public boolean isStrictRanges() {\n-        return strictRanges;\n-    }\n-\n-    /**\n      * If both the day of the week and day of the month should be matched.\n      *\n      * @return true if both should be matched, false otherwise\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/constraint/FieldConstraintsBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/constraint/FieldConstraintsBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/constraint/FieldConstraintsBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/constraint/FieldConstraintsBuilder.java\n@@ -30,6 +30,7 @@\n     private final Map<Integer, Integer> intMapping;\n     private int startRange;\n     private int endRange;\n+    private boolean strictRange;\n     private final Set<SpecialChar> specialChars;\n\n@@ -40,6 +41,7 @@\n         intMapping = new HashMap<>();\n         startRange = 0;//no negatives!\n         endRange = Integer.MAX_VALUE;\n+        strictRange = false;\n         specialChars = new HashSet<>();\n         specialChars.add(SpecialChar.NONE);\n     }\n@@ -157,6 +159,16 @@\n     }\n \n     /**\n+     * With strict range.\n+     *\n+     * @return same FieldConstraintsBuilder instance\n+     */\n+    public FieldConstraintsBuilder withStrictRange() {\n+        this.strictRange = true;\n+        return this;\n+    }\n+\n+    /**\n      * Shifts integer representation of weekday/month names.\n      *\n      * @param shiftSize - size of the shift\n@@ -184,7 +196,7 @@\n      * @return new FieldConstraints instance\n      */\n     public FieldConstraints createConstraintsInstance() {\n-        return new FieldConstraints(stringMapping, intMapping, specialChars, startRange, endRange);\n+        return new FieldConstraints(stringMapping, intMapping, specialChars, startRange, endRange, strictRange);\n     }\n \n     /**\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java\n@@ -34,6 +34,7 @@\n     private final Set<SpecialChar> specialChars;\n     private final Integer startRange;\n     private final Integer endRange;\n+    private final boolean strictRange;\n \n     /**\n      * Constructor.\n@@ -41,14 +42,16 @@\n      * @param specialChars - allowed special chars.\n      * @param startRange   - lowest possible value\n      * @param endRange     - highest possible value\n+     * @param strictRange  - if we shall consider strict ranges for this field - regardless global strict ranges criteria\n      */\n     public FieldConstraints(final Map<String, Integer> stringMapping, final Map<Integer, Integer> intMapping, final Set<SpecialChar> specialChars, final int startRange,\n-            final int endRange) {\n+            final int endRange, final boolean strictRange) {\n         this.stringMapping = Collections.unmodifiableMap(Preconditions.checkNotNull(stringMapping, \"String mapping must not be null\"));\n         this.intMapping = Collections.unmodifiableMap(Preconditions.checkNotNull(intMapping, \"Integer mapping must not be null\"));\n         this.specialChars = Collections.unmodifiableSet(Preconditions.checkNotNull(specialChars, \"Special (non-standard) chars set must not be null\"));\n         this.startRange = startRange;\n         this.endRange = endRange;\n+        this.strictRange = strictRange;\n     }\n \n     public int getStartRange() {\n@@ -94,4 +97,7 @@\n         return intMapping.get(exp);\n     }\n \n+    public boolean isStrictRange() {\n+        return strictRange;\n+    }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/definition/FieldDefinitionBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/definition/FieldDefinitionBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/definition/FieldDefinitionBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/definition/FieldDefinitionBuilder.java\n@@ -67,6 +67,16 @@\n      *\n      * @return same FieldDefinitionBuilder instance\n      */\n+    public FieldDefinitionBuilder withStrictRange() {\n+        constraints.withStrictRange();\n+        return this;\n+    }\n \n     /**\n      * Allows to tag a field as optional.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java\n@@ -35,18 +35,15 @@\n \n     private final FieldConstraints constraints;\n     private final StringValidations stringValidations;\n-    private final boolean strictRanges;\n \n-    public ValidationFieldExpressionVisitor(final FieldConstraints constraints, final boolean strictRanges) {\n+    public ValidationFieldExpressionVisitor(final FieldConstraints constraints) {\n         this.constraints = constraints;\n         stringValidations = new StringValidations(constraints);\n-        this.strictRanges = strictRanges;\n     }\n \n-    protected ValidationFieldExpressionVisitor(final FieldConstraints constraints, final StringValidations stringValidation, final boolean strictRanges) {\n+    protected ValidationFieldExpressionVisitor(final FieldConstraints constraints, final StringValidations stringValidation) {\n         this.constraints = constraints;\n         stringValidations = stringValidation;\n-        this.strictRanges = strictRanges;\n     }\n \n     @Override\n@@ -95,7 +92,7 @@\n     public Between visit(final Between between) {\n         preConditions(between);\n \n-        if (strictRanges && between.getFrom() instanceof IntegerFieldValue && between.getTo() instanceof IntegerFieldValue) {\n+        if ((constraints.isStrictRange()) && between.getFrom() instanceof IntegerFieldValue && between.getTo() instanceof IntegerFieldValue) {\n             final int from = ((IntegerFieldValue) between.getFrom()).getValue();\n             final int to = ((IntegerFieldValue) between.getTo()).getValue();\n             if (from > to) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/SingleCron.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/SingleCron.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/SingleCron.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/SingleCron.java\n@@ -81,7 +81,7 @@\n         for (final Map.Entry<CronFieldName, CronField> field : retrieveFieldsAsMap().entrySet()) {\n             final CronFieldName fieldName = field.getKey();\n             field.getValue().getExpression().accept(\n-                    new ValidationFieldExpressionVisitor(getCronDefinition().getFieldDefinition(fieldName).getConstraints(), cronDefinition.isStrictRanges())\n+                    new ValidationFieldExpressionVisitor(getCronDefinition().getFieldDefinition(fieldName).getConstraints())\n             );\n         }\n         for (final CronConstraint constraint : getCronDefinition().getCronConstraints()) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/parser/CronParserField.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/parser/CronParserField.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/parser/CronParserField.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/parser/CronParserField.java\n@@ -79,8 +79,8 @@\n      * @return parse result as CronFieldParseResult instance - never null. May throw a RuntimeException if cron expression is bad.\n      */\n     public CronField parse(final String expression) {\n-        String newExpression = expression.toUpperCase();\n-        if(getField().equals(CronFieldName.DAY_OF_WEEK) && newExpression.endsWith(\"L\")){\n+        String newExpression = expression;\n+        if(getField().equals(CronFieldName.DAY_OF_WEEK) && newExpression.endsWith(\"L\") && newExpression.length()>1){\n             newExpression = \"\"+constraints.getStringMappingValue(newExpression.replaceAll(\"L\", \"\"));\n         }\n         return new CronField(field, parser.parse(newExpression), constraints);",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-77",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.cronutils.utils.descriptor.Issue281Test",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Failed to parse '0 0 0 1/31 7 ?'. Period 31 not in range (0, 30]",
                "methodName": "shouldAcceptLastDayOfMonth"
            },
            {
                "className": "com.cronutils.utils.descriptor.Issue281Test",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Failed to parse '0 0 0 24/1 1/12 ?'. Period 12 not in range (0, 11]",
                "methodName": "shouldAcceptFirstDayOfMonth"
            },
            {
                "className": "com.cronutils.utils.descriptor.Issue281Test",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Failed to parse '0 0 0 24 1/12 ?'. Period 12 not in range (0, 11]",
                "methodName": "shouldAcceptLastMonth"
            },
            {
                "className": "com.cronutils.utils.descriptor.Issue281Test",
                "error": "java.lang.IllegalArgumentException",
                "message": ": Failed to parse '0 0 0 24/1 1/12 ?'. Period 12 not in range (0, 11]",
                "methodName": "shouldAcceptFirstMonth"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-77",
        "project": "RegressionBug-77",
        "repairOperators": [
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java\n@@ -273,8 +273,8 @@\n                 .withSeconds().and()\n                 .withMinutes().and()\n                 .withHours().and()\n-                .withDayOfMonth().supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n+                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n-                .withMonth().and()\n+                .withMonth().withValidRange(1, 13).and()\n                 .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                 .withYear().withValidRange(1970, 2099).optional().and()\n                 .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/constraint/FieldConstraints.java\n@@ -72,6 +72,17 @@\n \tpublic boolean isInRange(int value) {\n \t\treturn value >= getStartRange() && value <= getEndRange();\n \t}\n \t\n \n     /**\n      * Check if given period is compatible with the given range\n      * \n      * @param period - to be checked\n      * @return {@code true} if period is compatible, {@code false} otherwise.\n      */\n+    public boolean isPeriodInRange(int period) {\n+        return period > 0 && period <= getEndRange() - getStartRange();\n+    }\n \n \tpublic Set<String> getStringMappingKeySet() {\n \t\treturn stringMapping.keySet();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java\n \t/**\n      * Check if given period is compatible with range\n      * \n      * @param fieldValue\n      *            - to be validated\n      * @throws IllegalArgumentException\n      *             - if not in range\n      */\n+    @VisibleForTesting\n+    protected void isPeriodInRange(FieldValue<?> fieldValue) {\n+        if (fieldValue instanceof IntegerFieldValue) {\n+            int value = ((IntegerFieldValue) fieldValue).getValue();\n+            if (!constraints.isPeriodInRange(value)) {\n+                throw new IllegalArgumentException(String.format(\"Period %s not in range (0, %s]\", value, constraints.getEndRange()-constraints.getStartRange()));\n+            }\n+        }\n+    }",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-78",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.springframework.hateoas.server.mvc.WebMvcLinkBuilderUnitTest",
                "error": "java.lang.NullPointerException",
                "message": "",
                "methodName": "usesFallbackConversionServiceIfNoContextIsCurrentlyPresent"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 3,
            "linesRem": 1,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-78",
        "project": "RegressionBug-78",
        "repairOperators": [
            "mdModChange",
            "condExpExpand",
            "retExpChange"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java\t2024-09-08 01:36:25.113885627 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java\t2024-09-08 01:36:25.089885459 +1000\n@@ -148,15 +148,14 @@\n \t\treturn WebMvcLinkBuilder.linkTo(method, parameters);\n \t}\n \n-\t@SuppressWarnings(\"null\")\n-\tprivate Supplier<ConversionService> getConversionService() {\n+\tprivate static Supplier<ConversionService> getConversionService() {\n \n \t\treturn () -> {\n \t\t\tRequestAttributes attributes = RequestContextHolder.getRequestAttributes();\n-\t\t\tif (!ServletRequestAttributes.class.isInstance(attributes)) {\n-\t\t\t\treturn null;\n+\t\t\tif (attributes == null || !ServletRequestAttributes.class.isInstance(attributes)) {\n+\t\t\t\treturn FALLBACK_CONVERSION_SERVICE;\n \t\t\t}\n \t\t\tServletContext servletContext = ((ServletRequestAttributes) attributes).getRequest().getServletContext();",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/hateoas/server/core/WebHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/hateoas/server/core/WebHandler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/hateoas/server/core/WebHandler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/hateoas/server/core/WebHandler.java\n@@ -104,7 +104,7 @@\n \n \t\tString mapping = DISCOVERER.getMapping(invocation.getTargetType(), invocation.getMethod());\n \n-\t\treturn finisher -> {\n+\t\treturn (finisher, conversionService) -> {\n \n \t\t\tUriComponentsBuilder builder = finisher.apply(mapping);\n \t\t\tUriTemplate template = UriTemplateFactory.templateFor(mapping == null ? \"/\" : mapping);\n@@ -120,16 +120,18 @@\n \n \t\t\tHandlerMethodParameters parameters = HandlerMethodParameters.of(invocation.getMethod());\n \t\t\tObject[] arguments = invocation.getArguments();\n+\t\t\tConversionService resolved = conversionService;\n\n \t\t\tfor (HandlerMethodParameter parameter : parameters.getParameterAnnotatedWith(PathVariable.class, arguments)) {\n-\t\t\t\tvalues.put(parameter.getVariableName(), encodePath(parameter.getValueAsString(arguments)));\n+\t\t\t\tvalues.put(parameter.getVariableName(),\n+\t\t\t\t\t\tencodePath(parameter.getValueAsString(arguments, resolved)));\n \t\t\t}\n \n \t\t\tList<String> optionalEmptyParameters = new ArrayList<>();\n \n@@ -335,7 +337,6 @@\n \n \tprivate abstract static class HandlerMethodParameter {\n \n-\t\tprivate static final ConversionService CONVERSION_SERVICE = new DefaultFormattingConversionService();\n \t\tprivate static final TypeDescriptor STRING_DESCRIPTOR = TypeDescriptor.valueOf(String.class);\n \t\tprivate static final Map<Class<? extends Annotation>, Function<MethodParameter, ? extends HandlerMethodParameter>> FACTORY;\n \t\tprivate static final String NO_PARAMETER_NAME = \"Could not determine name of parameter %s! Make sure you compile with parameter information or explicitly define a parameter name in %s.\";\n@@ -400,7 +401,7 @@\n \t\t\treturn variableName;\n \t\t}\n \n-\t\tpublic String getValueAsString(Object[] values) {\n+\t\tpublic String getValueAsString(Object[] values, ConversionService conversionService) {\n \n \t\t\tObject value = values[parameter.getParameterIndex()];\n \n@@ -414,11 +415,9 @@\n\t\t\t// Try to lookup ConversionService from the request's context\n\t\t\t// Guard with \u2026.canConvert(\u2026)\n\t\t\t// if not, fall back to \u2026.toString();\n-\t\t\tObject result = CONVERSION_SERVICE.convert(value, typeDescriptor, STRING_DESCRIPTOR);\n+\t\t\tObject result = conversionService.canConvert(typeDescriptor, STRING_DESCRIPTOR)\n+\t\t\t\t\t? conversionService.convert(value, typeDescriptor, STRING_DESCRIPTOR)\n+\t\t\t\t\t: value == null ? null : value.toString();\n \n \t\t\tif (result == null) {\n \t\t\t\tthrow new IllegalArgumentException(String.format(\"Conversion of value %s resulted in null!\", value));\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java\n@@ -47,6 +57,8 @@\n  */\n public class WebMvcLinkBuilderFactory implements MethodLinkBuilderFactory<WebMvcLinkBuilder> {\n \n+\tprivate static ConversionService FALLBACK_CONVERSION_SERVICE = new DefaultFormattingConversionService();\n\n \tprivate List<UriComponentsContributor> uriComponentsContributors = new ArrayList<>();\n\n@@ -124,7 +136,7 @@\n \n \t\t\treturn builder;\n \n-\t\t}, builderFactory);\n+\t\t}, builderFactory, getConversionService());\n \t}\n\n@@ -135,4 +147,24 @@\n \tpublic WebMvcLinkBuilder linkTo(Method method, Object... parameters) {\n \t\treturn WebMvcLinkBuilder.linkTo(method, parameters);\n \t}\n\n+\t@SuppressWarnings(\"null\")\n+\tprivate Supplier<ConversionService> getConversionService() {\n+\t\treturn () -> {\n+\t\t\tRequestAttributes attributes = RequestContextHolder.getRequestAttributes();\n+\t\t\tif (!ServletRequestAttributes.class.isInstance(attributes)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tServletContext servletContext = ((ServletRequestAttributes) attributes).getRequest().getServletContext();\n+\t\t\tWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n+\t\t\treturn context == null || !context.containsBean(\"mvcConversionService\")\n+\t\t\t\t\t? FALLBACK_CONVERSION_SERVICE\n+\t\t\t\t\t: context.getBean(\"mvcConversionService\", ConversionService.class);\n+\t\t};\n+\t}\n }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-79",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.univocity.parsers.common.processor.AnnotatedBeanProcessorTest",
                "error": "java.lang.IllegalArgumentException",
                "message": "Duplicate field index '1' found in attribute 'title' of class com.univocity.parsers.common.processor.AnnotatedBeanProcessorTest$MetaData",
                "methodName": "testRepeatedIndexInAnnotation"
            }
        ],
        "metrics": {
            "chunks": 3,
            "classes": 2,
            "files": 2,
            "linesAdd": 0,
            "linesMod": 2,
            "linesRem": 3,
            "methods": 2,
            "sizeInLines": 3
        },
        "program": "RegressionBug-79",
        "project": "RegressionBug-79",
        "repairOperators": [
            "condExpExpand",
            "condBranRem",
            "objInstRem",
            "exThrowsRem"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java\n@@ -527,7 +527,7 @@\n \t\t\tint index = header.getHeaderIndex();\n \n \t\t\tif (index != -1) {\n-\t\t\t\tif (indexes.contains(index)) {\n+\t\t\t\tif (filter == MethodFilter.ONLY_GETTERS && indexes.contains(index)) { //allows the same column to be mapped to multiple fields when parsing, but not when writing.\n \t\t\t\t\tthrow new IllegalArgumentException(\"Duplicate field index '\" + index + \"' found in attribute '\" + header.getTargetName() + \"' of class \" + beanClass.getName());\n \t\t\t\t}\n \t\t\t\tindexes.add(index);\n@@ -637,7 +637,9 @@\n \t\tParsed annotation = findAnnotation(element, Parsed.class);\n \t\tif (annotation != null) {\n \t\t\tTransformedHeader header = new TransformedHeader(element, transformer);\n-\t\t\tif (header.getHeaderIndex() >= 0 && indexes.contains(header.getHeaderIndex())) {\n+\t\t\tif (filter == MethodFilter.ONLY_GETTERS && header.getHeaderIndex() >= 0 && indexes.contains(header.getHeaderIndex())) {\n \t\t\t\tthrow new IllegalArgumentException(\"Duplicate field index '\" + header.getHeaderIndex() + \"' found in \" + describeElement(element));\n \t\t\t}\n \t\t\ttmp.add(header);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/fields/FieldSet.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/fields/FieldSet.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/univocity/parsers/common/fields/FieldSet.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/univocity/parsers/common/fields/FieldSet.java\n@@ -100,9 +100,6 @@\n \t * @param field information that uniquely identifies a field\n \t */\n \tprivate void addElement(T field) {\n-\t\tif (this.fields.contains(field)) {\n-\t\t\tthrow new IllegalArgumentException(\"Field '\" + field + \"' is already selected\");\n-\t\t}\n \t\tfields.add(field);\n \t}\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/annotations/helpers/AnnotationHelper.java\n@@ -432,7 +432,12 @@\n \n \tprivate static boolean allFieldsIndexOrNameBased(boolean searchName, Class<?> beanClass) {\n \t\tboolean hasAnnotation = false;\n-\t\tfor (Field field : getAllFields(beanClass).keySet()) {\n\n+\t\tfor (TransformedHeader header : getFieldSequence(beanClass, true, null)) {\n+\t\t\tif (header == null || header.getField() == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tField field = header.getField();\n \t\t\tParsed annotation = findAnnotation(field, Parsed.class);\n \t\t\tif (annotation != null) {\n \t\t\t\thasAnnotation = true;\n@@ -477,18 +482,19 @@\n \t */\n \tpublic static Integer[] getSelectedIndexes(Class<?> beanClass) {\n \t\tList<Integer> indexes = new ArrayList<Integer>();\n-\t\tfor (Field field : getAllFields(beanClass).keySet()) {\n-\t\t\tParsed annotation = findAnnotation(field, Parsed.class);\n-\t\t\tif (annotation != null) {\n-\t\t\t\tif (annotation.index() != -1) {\n-\t\t\t\t\tif (indexes.contains(annotation.index())) {\n-\t\t\t\t\t\tthrow new IllegalArgumentException(\"Duplicate field index '\" + annotation.index() + \"' found in attribute '\" + field.getName() + \"' of class \" + beanClass.getName());\n-\t\t\t\t\t}\n-\t\t\t\t\tindexes.add(annotation.index());\n+\t\tfor (TransformedHeader header : getFieldSequence(beanClass, true, null)) {\n+\t\t\tif(header == null){\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tint index = header.getHeaderIndex();\n+\n+\t\t\tif (index != -1) {\n+\t\t\t\tif (indexes.contains(index)) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"Duplicate field index '\" + index + \"' found in attribute '\" + header.getAttributeName() + \"' of class \" + beanClass.getName());\n \t\t\t\t}\n+\t\t\t\tindexes.add(index);\n \t\t\t}\n \t\t}\n \t\treturn indexes.toArray(new Integer[indexes.size()]);\n \t}\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/annotations/helpers/TransformedHeader.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/annotations/helpers/TransformedHeader.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/annotations/helpers/TransformedHeader.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/annotations/helpers/TransformedHeader.java\n@@ -4,6 +4,8 @@\n \n import java.lang.reflect.*;\n \n+import static com.univocity.parsers.annotations.helpers.AnnotationHelper.*;\n\n /**\n  * A pair associating a Field of an annotated class to an optional {@likn HeaderTransformer} obtained from\n  * {@link Nested#headerTransformer()} when nested classes are used to process beans.*/\n@@ -49,11 +51,30 @@\n\t *\n\t * @return the current header index.\n\t */\n+\tpublic int getHeaderIndex() {\n+\t\tParsed annotation = findAnnotation(field, Parsed.class);\n+\t\tif (annotation != null) {\n+\t\t\tint index = annotation.index();\n+\t\t\tif (index != -1) {\n+\t\t\t\tif (transformer != null) {\n+\t\t\t\t\treturn transformer.transformIndex(field, index);\n+\t\t\t\t}\n+\t\t\t\treturn index;\n+\t\t\t}\n+\t\t}\n+\t\treturn -1;\n+\t}\n\n\t/**\n \t /* Returns the original attribute name of the field in its containing class.\n \t *\n \t * @return the original attribute name of the field\n \t */\n-\tpublic String attributeName() {\n+\tpublic String getAttributeName() {\n \t\tif (field == null) {\n \t\t\treturn null;\n \t\t}",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-80",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "org.springframework.hateoas.UriTemplateUnitTest",
                "error": "java.lang.NullPointerException",
                "message": "",
                "methodName": "expandsTemplateWithAddedVariable"
            }
        ],
        "metrics": {
            "chunks": 4,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 2,
            "linesRem": 0,
            "methods": 2,
            "sizeInLines": 4
        },
        "program": "RegressionBug-80",
        "project": "RegressionBug-80",
        "repairOperators": [
            "mcAdd",
            "assignAdd",
            "mdAdd",
            "mcParAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/hateoas/UriTemplate.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/hateoas/UriTemplate.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/org/springframework/hateoas/UriTemplate.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/org/springframework/hateoas/UriTemplate.java\n@@ -106,18 +107,21 @@\n \t * @param variables must not be {@literal null}.\n\t * @param factory must not be {@literal null}.\n \t */\n-\tUriTemplate(String baseUri, TemplateVariables variables) {\n+\tprivate UriTemplate(String baseUri, TemplateVariables variables, UriBuilderFactory factory) {\n \n \t\tAssert.hasText(baseUri, \"Base URI must not be null or empty!\");\n \t\tAssert.notNull(variables, \"Template variables must not be null!\");\n+\t\tAssert.notNull(factory, \"UriBuilderFactory must not be null!\");\n \n \t\tthis.baseUri = baseUri;\n \t\tthis.variables = variables;\n+\t\tthis.factory = factory;\n \t}\n\n@@ -179,7 +183,7 @@\n \t\t\tresult.add(variable);\n \t\t}\n \n-\t\treturn new UriTemplate(baseUri, this.variables.concat(result));\n+\t\treturn new UriTemplate(baseUri, this.variables.concat(result), this.factory);\n \t}\n \n \t/**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/hateoas/UriTemplate.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/hateoas/UriTemplate.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/springframework/hateoas/UriTemplate.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/springframework/hateoas/UriTemplate.java\n@@ -52,6 +60,7 @@\n \tprivate final TemplateVariables variables;\n \tprivate String toString;\n \tprivate String baseUri;\n+\tprivate transient UriBuilderFactory factory;\n \n \t/**\n \t * Creates a new {@link UriTemplate} using the given template string.*/\n@@ -93,6 +102,7 @@\n \n \t\tthis.variables = variables.isEmpty() ? TemplateVariables.NONE : new TemplateVariables(variables);\n \t\tthis.baseUri = template.substring(0, baseUriEndIndex);\n+\t\tthis.factory = createFactory(baseUri);\n \t}\n\n@@ -314,13 +329,32 @@\n\t * @param baseUri must not be {@literal null} or empty.\n\t * @return\n\t */\n+\tprivate static UriBuilderFactory createFactory(String baseUri) {\n+\t\tEncodingMode mode = UriUtils.decode(baseUri, StandardCharsets.UTF_8).length() < baseUri.length() //\n+\t\t\t\t? EncodingMode.VALUES_ONLY //\n+\t\t\t\t: EncodingMode.TEMPLATE_AND_VALUES;\n+\t\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory();\n+\t\tfactory.setEncodingMode(mode);\n+\t\treturn factory;\n+\t}\n\n",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-81",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.msgs.restricted.RenderOnlySoyMsgBundleImplTest",
                "error": "java.lang.OutOfMemoryError",
                "message": ": Java heap space",
                "methodName": "testEmptyBundlesDontOverAllocate"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-81",
        "project": "RegressionBug-81",
        "repairOperators": [
            "assignExpChange",
            "condBranIfElseAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n@@ -142,7 +142,7 @@\n \n     // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n     int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n-    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n+    this.bucketMask = maskHigh == 0 ? 0 : (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n     int numBuckets = this.bucketMask + 1;\n \n     // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n@@ -72,6 +73,55 @@\n    *   <li>24 - 128ns (low memory footprint, binary search everything)\n    * </ul>\n    */\n+  private static final int BUCKET_SHIFT = 6;\n\n   /** This is both the mask used to map IDs to buckets. It's also the number of buckets-1. */\n+  private final int bucketMask;\n\n   /** The bucket is the range [bucketBoundaries[bucketKey], bucketBoundaries[bucketKey]) in ids. */\n+  private final ImmutableIntArray bucketBoundaries;\n\n   /** Returns the bucket index of the given ID. */\n+  private int bucketOf(long msgId) {\n+    return ((int) msgId) & bucketMask;\n+  }\n\n@@ -88,8 +138,26 @@\n     this.locale = localeString == null ? null : new ULocale(localeString);\n     this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n \n-    ImmutableList<SoyMsg> sortedMsgs =\n-        ImmutableList.sortedCopyOf(Comparator.comparingLong(SoyMsg::getId), msgs);\n     // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n+    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n+    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n+    int numBuckets = this.bucketMask + 1;\n\n     // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n+    Comparator<SoyMsg> bucketComparator =\n+        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n+    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n     // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n+    ImmutableIntArray.Builder bucketBoundariesBuilder = ImmutableIntArray.builder(numBuckets + 1);\n+    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n+      bucketBoundariesBuilder.add(idx);\n+      for (;\n+          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n+          idx++) {}\n+    }\n+    bucketBoundariesBuilder.add(sortedMsgs.size());\n+    this.bucketBoundaries = bucketBoundariesBuilder.build();\n \n     ImmutableLongArray.Builder idsBuilder = ImmutableLongArray.builder(sortedMsgs.size());\n     ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-82",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.msgs.restricted.RenderOnlySoyMsgBundleImplTest",
                "error": "java.lang.OutOfMemoryError",
                "message": ": Java heap space",
                "methodName": "testEmptyBundlesDontOverAllocate"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-82",
        "project": "RegressionBug-82",
        "repairOperators": [
            "assignExpChange",
            "condBranIfElseAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n@@ -143,7 +143,7 @@\n     // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n     int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n     this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n-    int numBuckets = this.bucketMask + 1;\n+    int numBuckets = maskHigh == 0 ? 0 : this.bucketMask + 1;\n \n     // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n     Comparator<SoyMsg> bucketComparator =",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java\n@@ -72,6 +73,55 @@\n    *   <li>24 - 128ns (low memory footprint, binary search everything)\n    * </ul>\n    */\n+  private static final int BUCKET_SHIFT = 6;\n\n   /** This is both the mask used to map IDs to buckets. It's also the number of buckets-1. */\n+  private final int bucketMask;\n\n   /** The bucket is the range [bucketBoundaries[bucketKey], bucketBoundaries[bucketKey]) in ids. */\n+  private final ImmutableIntArray bucketBoundaries;\n\n   /** Returns the bucket index of the given ID. */\n+  private int bucketOf(long msgId) {\n+    return ((int) msgId) & bucketMask;\n+  }\n\n@@ -88,8 +138,26 @@\n     this.locale = localeString == null ? null : new ULocale(localeString);\n     this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n \n-    ImmutableList<SoyMsg> sortedMsgs =\n-        ImmutableList.sortedCopyOf(Comparator.comparingLong(SoyMsg::getId), msgs);\n     // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n+    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n+    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n+    int numBuckets = this.bucketMask + 1;\n\n     // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n+    Comparator<SoyMsg> bucketComparator =\n+        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n+    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n     // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n+    ImmutableIntArray.Builder bucketBoundariesBuilder = ImmutableIntArray.builder(numBuckets + 1);\n+    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n+      bucketBoundariesBuilder.add(idx);\n+      for (;\n+          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n+          idx++) {}\n+    }\n+    bucketBoundariesBuilder.add(sortedMsgs.size());\n+    this.bucketBoundaries = bucketBoundariesBuilder.build();\n \n     ImmutableLongArray.Builder idsBuilder = ImmutableLongArray.builder(sortedMsgs.size());\n     ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-83",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.passes.CombineConsecutiveRawTextNodesPassTest",
                "error": "java.lang.IndexOutOfBoundsException",
                "message": ": Index: 5, Size: 5",
                "methodName": "testForConcurrentModificationBug"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 2,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 2
        },
        "program": "RegressionBug-83",
        "project": "RegressionBug-83",
        "repairOperators": [
            "condBranIfAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CombineConsecutiveRawTextNodesPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CombineConsecutiveRawTextNodesPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CombineConsecutiveRawTextNodesPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CombineConsecutiveRawTextNodesPass.java\n@@ -101,10 +101,14 @@\n     }\n     // general case, there are N rawtextnodes to merge where n > 1\n     // merge all the nodes together, then drop all the raw text nodes from the end\n+    if (start < lastNonEmptyRawTextNode) {\n          RawTextNode newNode =\n               RawTextNode.concat(\n                    (List<RawTextNode>) parent.getChildren().subList(start, lastNonEmptyRawTextNode + 1));\n                    ((ParentSoyNode) parent).replaceChild(start, newNode);\n+    }\n\n     for (int i = end - 1; i > start; i--) {\n       parent.removeChild(i);\n     }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/PassManager.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/PassManager.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/PassManager.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/PassManager.java\n@@ -285,6 +285,7 @@\n       // meaning that errors reported in earlier passes do not prevent running subsequent passes.\n       building = true;\n       ImmutableList.Builder<CompilerFilePass> singleFilePassesBuilder = ImmutableList.builder();\n+      addPass(new StripSoyCommentsPass(), singleFilePassesBuilder);\n       // Needs to run after htmlrewriting, before ResolveNames, ResolveTemplateParamTypes and\n       // autoescaping.\n       addPass(new ContentSecurityPolicyNonceInjectionPass(errorReporter), singleFilePassesBuilder);\nOnly in ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes: StripSoyCommentsPass.java\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soyparse/HtmlRewriter.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n@@ -1250,6 +1251,12 @@\n     }\n \n     @Override\n+    protected void visitLineCommentNode(LineCommentNode node) {\n+      processNonPrintableNode(\n+          node); // otherwise InferenceEngine is unable to correctly infer escaping mode.\n+    }\n\n+    @Override\n     protected void visitCallParamContentNode(CallParamContentNode node) {\n       visitScopedBlock(node.getContentKind(), node, \"param\");\n     }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/AbstractSoyNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/AbstractSoyNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/AbstractSoyNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/AbstractSoyNodeVisitor.java\n@@ -197,6 +197,10 @@\n         visitDebuggerNode((DebuggerNode) node);\n         break;\n \n+      case LINE_COMMENT_NODE:\n+        visitLineCommentNode((LineCommentNode) node);\n+        break;\n\n       default:\n         visitSoyNode(node);\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/LineCommentNode.java ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/LineCommentNode.java\n--- ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/LineCommentNode.java\n+++ ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/LineCommentNode.java\n@@ -0,0 +36,2 @@\n+  public LineCommentNode(int id, String comment, SourceLocation sourceLocation) {\n+    super(id, sourceLocation);\n+    String trimmed = whitespace().trimLeadingFrom(comment);\n+    checkArgument(\n+      trimmed.length() < comment.length() && trimmed.startsWith(\"//\"),\n+      \"Line comment must start with ' //': %s\",\n+      comment);\n+    this.comment = whitespace().trimFrom(trimmed.substring(2));\n+  }\n@@ -0,0 +60,2 @@\n   /** Escapes `*\\/` in the commment text. */\n+   public String getEscapedCommentText() {\n+    return comment.replace(\"*/\", \"*&#47;\");\n+  }\n\n+  @Override\n+  public Kind getKind() {\n+    return Kind.LINE_COMMENT_NODE;\n+  }\n\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public ParentSoyNode<StandaloneNode> getParent() {\n+    return (ParentSoyNode<StandaloneNode>) super.getParent();\n+  }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/RawTextNode.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/RawTextNode.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/RawTextNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/RawTextNode.java\n@@ -138,6 +138,25 @@\n    * @throws IndexOutOfBoundsException if index is out of range.\n    * @return {@code true} if command executed\n    */\n+  public boolean commandAt(int index) {\n+    return offsets == null ? false : offsets.getReasonAt(index) == SourceOffsets.Reason.COMMAND;\n+  }\n \n   @Nullable\n   public Reason getReasonAt(int index) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/SoyNode.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/SoyNode.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/SoyNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/SoyNode.java\n@@ -100,8 +100,9 @@\n \n     LOG_NODE,\n     DEBUGGER_NODE,\n-  }\n \n+    LINE_COMMENT_NODE,\n+  }\n \n   /** Returns this node's kind (corresponding to this node's specific type). */\n   Kind getKind();",
        "bugType": "Remote"
    },
    {
        "bugId": "RegressionBug-84",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "expected:\n    \u2026.$$strContains('' + gooData8, 'goo')) {\n      $tmp =\u2026\nbut was:\n    \u2026.$$strContains('' + (gooData8), 'goo')) {\n      $tmp =\u2026",
                "methodName": "testIf"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.JsCodeBuilderTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of:\n    getCode()\nexpected:\n    var output = '' + boo;\n    \nbut was:\n    var output = '' + (boo);\n    ",
                "methodName": "testOutputVarWithConcat"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-84",
        "project": "RegressionBug-84",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java\n@@ -79,7 +79,7 @@\n       return concatChunks(chunks);\n     } else {\n       return concatChunks(\n-          ImmutableList.of(LITERAL_EMPTY_STRING, Group.create(concatChunks(chunks))));\n+          ImmutableList.<Expression>builder().add(LITERAL_EMPTY_STRING).addAll(chunks).build());\n     }\n   }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java\n@@ -79,7 +79,7 @@\n    return concatChunks(chunks);\n  } else {\n    return concatChunks(\n-     ImmutableList.<Expression>builder().add(LITERAL_EMPTY_STRING).addAll(chunks).build());\n+     ImmutableList.of(LITERAL_EMPTY_STRING, Group.create(concatChunks(chunks))));\n  }\n\n ",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-85",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.jssrc.internal.TranslateExprNodeVisitorTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "expected: goog.DEBUG ? new soy.velog.$$VisualElement(8675309, 'MyVe') : new soy.velog.$$VisualElement(8675309);\nbut was : goog.DEBUG ? new soy.velog.$$VisualElement(8675309, undefined, 'MyVe') : new soy.velog.$$VisualElement(8675309, undefined);",
                "methodName": "testVeLiteral"
            }
        ],
        "metrics": {
            "chunks": 5,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 16,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-85",
        "project": "RegressionBug-85",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java\n@@ -100,7 +100,6 @@\n import com.google.template.soy.internal.proto.ProtoUtils;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n import com.google.template.soy.jssrc.dsl.Expression;\n-import com.google.template.soy.jssrc.dsl.GoogRequire;\n import com.google.template.soy.jssrc.dsl.JsDoc;\n import com.google.template.soy.jssrc.dsl.SoyJsPluginUtils;\n import com.google.template.soy.jssrc.internal.NullSafeAccumulator.FieldAccess;\n@@ -108,7 +107,6 @@\n import com.google.template.soy.jssrc.restricted.JsExpr;\n import com.google.template.soy.jssrc.restricted.SoyJsSrcFunction;\n import com.google.template.soy.logging.LoggingFunction;\n-import com.google.template.soy.logging.ValidatedLoggingConfig.ValidatedLoggableElement;\n import com.google.template.soy.plugin.javascript.restricted.SoyJavaScriptSourceFunction;\n import com.google.template.soy.shared.internal.BuiltinFunction;\n import com.google.template.soy.shared.internal.BuiltinMethod;\n@@ -973,26 +971,13 @@\n \n   @Override\n   protected Expression visitVeLiteralNode(VeLiteralNode node) {\n-    ValidatedLoggableElement element = node.getLoggableElement();\n-    Expression metadata;\n-    if (element.hasMetadata()) {\n-      metadata =\n-          GoogRequire.create(element.getJsPackage())\n-              .googModuleGet()\n-              .dotAccess(element.getClassName())\n-              .dotAccess(element.getGeneratedVeMetadataMethodName())\n-              .call();\n-    } else {\n-      metadata = Expression.LITERAL_UNDEFINED;\n-    }\n     return Expression.ifExpression(\n             GOOG_DEBUG,\n             construct(\n                 SOY_VISUAL_ELEMENT,\n                 Expression.number(node.getId()),\n-                metadata,\n                 Expression.stringLiteral(node.getName().identifier())))\n-        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId()), metadata))\n+        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId())))\n         .build(codeGenerator);\n   }\n ",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java\n@@ -100,6 +100,7 @@\n import com.google.template.soy.internal.proto.ProtoUtils;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n import com.google.template.soy.jssrc.dsl.Expression;\n+import com.google.template.soy.jssrc.dsl.GoogRequire;\n import com.google.template.soy.jssrc.dsl.JsDoc;\n import com.google.template.soy.jssrc.dsl.SoyJsPluginUtils;\n import com.google.template.soy.jssrc.internal.NullSafeAccumulator.FieldAccess;\n@@ -107,6 +108,7 @@\n import com.google.template.soy.jssrc.restricted.JsExpr;\n import com.google.template.soy.jssrc.restricted.SoyJsSrcFunction;\n import com.google.template.soy.logging.LoggingFunction;\n+import com.google.template.soy.logging.ValidatedLoggingConfig.ValidatedLoggableElement;\n import com.google.template.soy.plugin.javascript.restricted.SoyJavaScriptSourceFunction;\n import com.google.template.soy.shared.internal.BuiltinFunction;\n import com.google.template.soy.shared.internal.BuiltinMethod;\n@@ -971,13 +973,26 @@\n \n   @Override\n   protected Expression visitVeLiteralNode(VeLiteralNode node) {\n+    ValidatedLoggableElement element = node.getLoggableElement();\n+    Expression metadata;\n+    if (element.hasMetadata()) {\n+      metadata =\n+          GoogRequire.create(element.getJsPackage())\n+              .googModuleGet()\n+              .dotAccess(element.getClassName())\n+              .dotAccess(element.getGeneratedVeMetadataMethodName())\n+              .call();\n+    } else {\n+      metadata = Expression.LITERAL_UNDEFINED;\n+    }\n     return Expression.ifExpression(\n             GOOG_DEBUG,\n             construct(\n                 SOY_VISUAL_ELEMENT,\n                 Expression.number(node.getId()),\n+                metadata,\n                 Expression.stringLiteral(node.getName().identifier())))\n-        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId())))\n+        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId()), metadata))\n         .build(codeGenerator);\n   }\n ",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-86",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.passes.ResolveExpressionTypesVisitorTest",
                "error": "java.lang.AssertionError",
                "message": "Unexpected error: Using arithmetic operators on Soy types 'string' and 'float' is illegal. at no-path:27:17",
                "methodName": "testArithmeticOps"
            }
        ],
        "metrics": {
            "chunks": 6,
            "classes": 2,
            "files": 2,
            "linesAdd": 14,
            "linesMod": 1,
            "linesRem": 16,
            "methods": 3,
            "sizeInLines": 15
        },
        "program": "RegressionBug-86",
        "project": "RegressionBug-86",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java\n@@ -17,6 +17,7 @@\n package com.google.template.soy.passes;\n \n import com.google.common.base.Equivalence.Wrapper;\n+import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n import com.google.template.soy.base.SourceLocation;\n@@ -565,7 +566,18 @@\n \n     @Override\n     protected void visitDivideByOpNode(DivideByOpNode node) {\n-      visitArithmeticOpNode(node);\n+      visitChildren(node);\n+      SoyType left = node.getChild(0).getType();\n+      SoyType right = node.getChild(1).getType();\n+      if (SoyTypes.isNumericOrUnknown(left) && SoyTypes.isNumericOrUnknown(right)) {\n+        node.setType(FloatType.getInstance());\n+      } else {\n+        node.setType(UnknownType.getInstance());\n+      }\n+      tryApplySubstitution(node);\n     }\n \n     @Override\n@@ -921,21 +933,18 @@\n \n     private void visitArithmeticOpNode(AbstractOperatorNode node) {\n       visitChildren(node);\n-      boolean isDivide = node instanceof DivideByOpNode;\n       SoyType left = node.getChild(0).getType();\n       SoyType right = node.getChild(1).getType();\n-      SoyType result =\n-          SoyTypes.getSoyTypeForBinaryOperator(\n-              left, right, new SoyTypes.SoyTypeArithmeticOperator());\n-      if (result == null) {\n-        errorReporter.report(node.getSourceLocation(), INCOMPATIBLE_AIRTHMETIC_OP, left, right);\n-        result = UnknownType.getInstance();\n+      Optional<SoyType> arithmeticType = SoyTypes.computeLowestCommonTypeArithmetic(left, right);\n+      if (arithmeticType.isPresent()) {\n+        node.setType(arithmeticType.get());\n+      } else {\n+        node.setType(SoyTypes.NUMBER_TYPE);\n       }\n-      node.setType(isDivide ? FloatType.getInstance() : result);\n       tryApplySubstitution(node);\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SoyTypes.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SoyTypes.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SoyTypes.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SoyTypes.java\n@@ -291,17 +291,4 @@\n-  public static final class SoyTypeArithmeticOperator implements SoyTypeBinaryOperator {\n-    @Override\n-    @Nullable\n-    public SoyType resolve(SoyType left, SoyType right) {\n-      Optional<SoyType> arithmeticType = SoyTypes.computeLowestCommonTypeArithmetic(left, right);\n-      return arithmeticType.orNull();\n-    }\n-  }\n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java\t2024-09-08 01:36:27.605903080 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesVisitor.java\t2024-09-08 01:36:27.561902772 +1000\n@@ -17,7 +17,6 @@\n package com.google.template.soy.passes;\n \n import com.google.common.base.Equivalence.Wrapper;\n-import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n import com.google.template.soy.base.SourceLocation;\n@@ -566,18 +565,7 @@\n \n     @Override\n     protected void visitDivideByOpNode(DivideByOpNode node) {\n+      visitArithmeticOpNode(node);\n-      visitChildren(node);\n-      SoyType left = node.getChild(0).getType();\n-      SoyType right = node.getChild(1).getType();\n-      if (SoyTypes.isNumericOrUnknown(left) && SoyTypes.isNumericOrUnknown(right)) {\n-        node.setType(FloatType.getInstance());\n-      } else {\n-        node.setType(UnknownType.getInstance());\n-      }\n-      tryApplySubstitution(node);\n     }\n \n     @Override\n@@ -933,18 +921,21 @@\n \n     private void visitArithmeticOpNode(AbstractOperatorNode node) {\n       visitChildren(node);\n+      boolean isDivide = node instanceof DivideByOpNode;\n       SoyType left = node.getChild(0).getType();\n       SoyType right = node.getChild(1).getType();\n-      Optional<SoyType> arithmeticType = SoyTypes.computeLowestCommonTypeArithmetic(left, right);\n-      if (arithmeticType.isPresent()) {\n-        node.setType(arithmeticType.get());\n-      } else {\n-        node.setType(SoyTypes.NUMBER_TYPE);\n+      SoyType result =\n+          SoyTypes.getSoyTypeForBinaryOperator(\n+              left, right, new SoyTypes.SoyTypeArithmeticOperator());\n+      if (result == null) {\n+        errorReporter.report(node.getSourceLocation(), INCOMPATIBLE_AIRTHMETIC_OP, left, right);\n+        result = UnknownType.getInstance();\n       }\n+      node.setType(isDivide ? FloatType.getInstance() : result);\n       tryApplySubstitution(node);\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SoyTypes.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SoyTypes.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SoyTypes.java\t2024-09-08 01:36:27.609903108 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SoyTypes.java\t2024-09-08 01:36:27.565902801 +1000\n@@ -291,4 +291,17 @@\n+  public static final class SoyTypeArithmeticOperator implements SoyTypeBinaryOperator {\n+    @Override\n+    @Nullable\n+    public SoyType resolve(SoyType left, SoyType right) {\n+      Optional<SoyType> arithmeticType = SoyTypes.computeLowestCommonTypeArithmetic(left, right);\n+      return arithmeticType.orNull();\n+    }\n+  }\n }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-87",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...o.foo.__deltemplate_[s2_b66e4cb3 = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return 'Blah';\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate_s2_b66e4cb3.soyTemplateName = 'boo.foo.__deltemplate_s2_b66e4cb3';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), 'moo', 1, boo.foo.__deltemplate_s2_b66e4cb3]);\n> but was:<...o.foo.__deltemplate_[MySecretFeature_myDelegates_goo_moo = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return 'Blah';\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate_MySecretFeature_myDelegates_goo_moo.soyTemplateName = 'boo.foo.__deltemplate_MySecretFeature_myDelegates_goo_moo';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), 'moo', 1, boo.foo.__deltemplate_MySecretFeature_myDelegates_goo_moo]);\n>",
                "methodName": "testDelTemplateWithVariant"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "java.lang.AssertionError",
                "message": "Not true that <\"// This file was automatically generated from no-path.\n// Please don't edit this file by hand.\n\n/**\n * @fileoverview Templates in namespace boo.foo.\n * @hassoydeltemplate {myDelegates.goo}\n * @public\n */\n\ngoog.provide('boo.foo');\n\ngoog.require('soy');\n\n\nboo.foo.__deltemplate__myDelegates_goo_ = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return 'Blah';\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate__myDelegates_goo_.soyTemplateName = 'boo.foo.__deltemplate__myDelegates_goo_';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), '', 0, boo.foo.__deltemplate__myDelegates_goo_);\n\"> ends with <\"goog.provide('boo.foo');\n\ngoog.require('soy');\n\n\nboo.foo.__deltemplate_s2_ad618961 = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return 'Blah';\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate_s2_ad618961.soyTemplateName = 'boo.foo.__deltemplate_s2_ad618961';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), '', 0, boo.foo.__deltemplate_s2_ad618961);\n\">",
                "methodName": "testDelTemplate"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...o.foo.__deltemplate_[s2_34da4ced = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return '' + soy.$$getDelegateFn(soy.$$getDelTemplateId('myDelegates.soo'), '', false)(null, null, opt_ijData);\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate_s2_34da4ced.soyTemplateName = 'boo.foo.__deltemplate_s2_34da4ced';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), '', 1, boo.foo.__deltemplate_s2_34da4ced]);\n> but was:<...o.foo.__deltemplate_[MySecretFeature_myDelegates_goo_ = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return '' + soy.$$getDelegateFn(soy.$$getDelTemplateId('myDelegates.soo'), '', false)(null, null, opt_ijData);\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate_MySecretFeature_myDelegates_goo_.soyTemplateName = 'boo.foo.__deltemplate_MySecretFeature_myDelegates_goo_';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), '', 1, boo.foo.__deltemplate_MySecretFeature_myDelegates_goo_]);\n>",
                "methodName": "testSoyFileInDelegatePackage"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...o.foo.__deltemplate_[s2_784ed7a8 = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return '' + soy.$$getDelegateFn(soy.$$getDelTemplateId('myDelegates.moo'), 'moomoo', false)(null, null, opt_ijData);\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate_s2_784ed7a8.soyTemplateName = 'boo.foo.__deltemplate_s2_784ed7a8';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), 'googoo', 0, boo.foo.__deltemplate_s2_784ed7a8]);\n> but was:<...o.foo.__deltemplate_[_myDelegates_goo_googoo = function(opt_data, opt_ijData, opt_ijData_deprecated) {\n  opt_ijData = opt_ijData_deprecated || opt_ijData;\n  return '' + soy.$$getDelegateFn(soy.$$getDelTemplateId('myDelegates.moo'), 'moomoo', false)(null, null, opt_ijData);\n};\nif (goog.DEBUG) {\n  boo.foo.__deltemplate__myDelegates_goo_googoo.soyTemplateName = 'boo.foo.__deltemplate__myDelegates_goo_googoo';\n}\nsoy.$$registerDelegateFn(soy.$$getDelTemplateId('myDelegates.goo'), 'googoo', 0, boo.foo.__deltemplate__myDelegates_goo_googoo]);\n>",
                "methodName": "testDelegateVariantProvideRequiresJsDocAnnotations"
            }
        ],
        "metrics": {
            "chunks": 7,
            "classes": 3,
            "files": 3,
            "linesAdd": 16,
            "linesMod": 6,
            "linesRem": 9,
            "methods": 5,
            "sizeInLines": 22
        },
        "program": "RegressionBug-87",
        "project": "RegressionBug-87",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/BaseUtils.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/BaseUtils.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/BaseUtils.java\t2024-09-08 01:36:27.885905042 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/BaseUtils.java\t2024-09-08 01:36:27.817904565 +1000\n@@ -16,7 +16,11 @@\n \n package com.google.template.soy.base.internal;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n+import com.google.common.hash.Hashing;\n import java.io.File;\n import java.util.Set;\n import java.util.regex.Pattern;\n@@ -260,4 +264,19 @@\n           .append(HEX_DIGITS[codePoint & 0xF]);\n     }\n   }\n\n+  public static String computePartialSha1AsHexString(String strToHash, int numBits) {\n+    Preconditions.checkArgument(numBits > 0 && numBits <= 160 && numBits % 8 == 0);\n+    int numBytes = numBits / 8;\n+    return Hashing.sha1().hashString(strToHash, UTF_8).toString().substring(0, numBytes * 2);\n+  }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java\t2024-09-08 01:36:27.893905097 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java\t2024-09-08 01:36:27.829904649 +1000\n@@ -18,13 +18,11 @@\n \n import com.google.template.soy.base.internal.IdGenerator;\n import com.google.template.soy.data.SanitizedContent.ContentKind;\n-import com.google.template.soy.msgs.internal.MsgUtils;\n import com.google.template.soy.passes.BuildAllDependeesMapVisitor;\n import com.google.template.soy.soytree.AbstractSoyNodeVisitor;\n import com.google.template.soy.soytree.HtmlAttributeNode;\n import com.google.template.soy.soytree.LetContentNode;\n import com.google.template.soy.soytree.MsgFallbackGroupNode;\n-import com.google.template.soy.soytree.MsgNode;\n import com.google.template.soy.soytree.SoyFileSetNode;\n import com.google.template.soy.soytree.SoyNode;\n import com.google.template.soy.soytree.SoyNode.BlockNode;\n@@ -55,8 +55,6 @@\n \n   private Map<SoyNode, List<SoyNode>> allDependeesMap;\n \n-  private int counter;\n\n   @Override\n   public Void exec(SoyNode node) {\n     msgFbGrpNodes = new ArrayList<>();\n@@ -69,7 +67,7 @@\n \n   @Override\n   protected void visitSoyFileSetNode(SoyFileSetNode node) {\n-    counter = 0;\n     // We find all the MsgFallbackGroupNodes before replacing them because we don't want the\n     // modifications to interfere with the traversal.\n \n@@ -107,13 +105,7 @@\n \n   protected void wrapMsgFallbackGroupNodeHelper(\n       MsgFallbackGroupNode msgFbGrpNode, IdGenerator nodeIdGen) {\n-    String varName = \"msg_\" + ++counter;\n-    for (MsgNode msg : msgFbGrpNode.getChildren()) {\n-      varName += \"_\" + MsgUtils.computeMsgIdForDualFormat(msg);\n-    }\n+    String varName = \"msg_\" + nodeIdGen.genId();\n \n     // Find the actual content kind that this node prints in.\n     RenderUnitNode container = msgFbGrpNode.getNearestAncestor(RenderUnitNode.class);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\t2024-09-08 01:36:27.897905125 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\t2024-09-08 01:36:27.841904733 +1000\n@@ -223,20 +223,26 @@\n     String delPackageAndDelTemplateStr =\n-        (soyFileHeaderInfo.delPackageName == null\n-                ? \"\"\n-                : soyFileHeaderInfo.delPackageName.replace('.', '_'))\n-            + \"_\"\n-            + delTemplateName.replace('.', '_')\n-            + \"_\"\n+        (soyFileHeaderInfo.delPackageName == null ? \"\" : soyFileHeaderInfo.delPackageName)\n+            + \"~\"\n+            + delTemplateName\n+            + \"~\"\n             + delTemplateVariant;\n+    String collisionPreventionStr =\n+        BaseUtils.computePartialSha1AsHexString(delPackageAndDelTemplateStr, 32);\n \n     // Generate the actual internal-use template name.\n-    String generatedPartialTemplateName = \".__deltemplate_\" + delPackageAndDelTemplateStr;\n+    String generatedPartialTemplateName = \".__deltemplate_s\" + id + \"_\" + collisionPreventionStr;\n     String generatedTemplateName = soyFileHeaderInfo.namespace + generatedPartialTemplateName;\n     setTemplateNames(generatedTemplateName, nameLocation, generatedPartialTemplateName);\n   }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/BaseUtils.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/BaseUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/BaseUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/BaseUtils.java\n@@ -16,11 +16,7 @@\n \n package com.google.template.soy.base.internal;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n-import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n-import com.google.common.hash.Hashing;\n import java.io.File;\n import java.util.Set;\n import java.util.regex.Pattern;\n@@ -264,19 +260,4 @@\n           .append(HEX_DIGITS[codePoint & 0xF]);\n     }\n   }\n\n-  public static String computePartialSha1AsHexString(String strToHash, int numBits) {\n-    Preconditions.checkArgument(numBits > 0 && numBits <= 160 && numBits % 8 == 0);\n-    int numBytes = numBits / 8;\n-    return Hashing.sha1().hashString(strToHash, UTF_8).toString().substring(0, numBytes * 2);\n-  }\n }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/ExtractMsgVariablesVisitor.java\n@@ -18,11 +18,13 @@\n \n import com.google.template.soy.base.internal.IdGenerator;\n import com.google.template.soy.data.SanitizedContent.ContentKind;\n+import com.google.template.soy.msgs.internal.MsgUtils;\n import com.google.template.soy.passes.BuildAllDependeesMapVisitor;\n import com.google.template.soy.soytree.AbstractSoyNodeVisitor;\n import com.google.template.soy.soytree.HtmlAttributeNode;\n import com.google.template.soy.soytree.LetContentNode;\n import com.google.template.soy.soytree.MsgFallbackGroupNode;\n+import com.google.template.soy.soytree.MsgNode;\n import com.google.template.soy.soytree.SoyFileSetNode;\n import com.google.template.soy.soytree.SoyNode;\n import com.google.template.soy.soytree.SoyNode.BlockNode;\n@@ -55,6 +55,8 @@\n \n   private Map<SoyNode, List<SoyNode>> allDependeesMap;\n \n+  private int counter;\n\n   @Override\n   public Void exec(SoyNode node) {\n     msgFbGrpNodes = new ArrayList<>();\n@@ -67,7 +69,7 @@\n \n   @Override\n   protected void visitSoyFileSetNode(SoyFileSetNode node) {\n+    counter = 0;\n     // We find all the MsgFallbackGroupNodes before replacing them because we don't want the\n     // modifications to interfere with the traversal.\n \n@@ -105,7 +107,13 @@\n \n   protected void wrapMsgFallbackGroupNodeHelper(\n       MsgFallbackGroupNode msgFbGrpNode, IdGenerator nodeIdGen) {\n-    String varName = \"msg_\" + nodeIdGen.genId();\n+    String varName = \"msg_\" + ++counter;\n+    for (MsgNode msg : msgFbGrpNode.getChildren()) {\n+      varName += \"_\" + MsgUtils.computeMsgIdForDualFormat(msg);\n+    }\n \n     // Find the actual content kind that this node prints in.\n     RenderUnitNode container = msgFbGrpNode.getNearestAncestor(RenderUnitNode.class);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n@@ -223,26 +223,20 @@\n     String delPackageAndDelTemplateStr =\n-        (soyFileHeaderInfo.delPackageName == null ? \"\" : soyFileHeaderInfo.delPackageName)\n-            + \"~\"\n-            + delTemplateName\n-            + \"~\"\n+        (soyFileHeaderInfo.delPackageName == null\n+                ? \"\"\n+                : soyFileHeaderInfo.delPackageName.replace('.', '_'))\n+            + \"_\"\n+            + delTemplateName.replace('.', '_')\n+            + \"_\"\n             + delTemplateVariant;\n-    String collisionPreventionStr =\n-        BaseUtils.computePartialSha1AsHexString(delPackageAndDelTemplateStr, 32);\n \n     // Generate the actual internal-use template name.\n-    String generatedPartialTemplateName = \".__deltemplate_s\" + id + \"_\" + collisionPreventionStr;\n+    String generatedPartialTemplateName = \".__deltemplate_\" + delPackageAndDelTemplateStr;\n     String generatedTemplateName = soyFileHeaderInfo.namespace + generatedPartialTemplateName;\n     setTemplateNames(generatedTemplateName, nameLocation, generatedPartialTemplateName);\n   }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-88",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.jssrc.internal.NullSafeAccumulatorTest",
                "error": "java.lang.AssertionError",
                "message": "Not true that <com.google.template.soy.jssrc.internal.NullSafeAccumulator@27f0a71d> generates <a == null ? null : a.b == null ? null : a.b[c];>. It generates <var $tmp$$1;\nif (a == null) {\n  $tmp$$1 = null;\n} else {\n  var $tmp = a.b;\n  $tmp$$1 = $tmp == null ? null : $tmp[c];\n}>",
                "methodName": "testNullSafeChain"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.NullSafeAccumulatorTest",
                "error": "java.lang.AssertionError",
                "message": "Not true that <com.google.template.soy.jssrc.internal.NullSafeAccumulator@26647ac8> generates <a.b(c) == null ? null : a.b(c).d(e);>. It generates <var $tmp = a.b(c);\n$tmp == null ? null : $tmp.d(e);>",
                "methodName": "testCallPreservesChain"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.NullSafeAccumulatorTest",
                "error": "java.lang.AssertionError",
                "message": "Not true that <com.google.template.soy.jssrc.internal.NullSafeAccumulator@54dd2962> generates <a == null ? null : a.b[c] == null ? null : a.b[c].d;>. It generates <var $tmp$$1;\nif (a == null) {\n  $tmp$$1 = null;\n} else {\n  var $tmp = a.b[c];\n  $tmp$$1 = $tmp == null ? null : $tmp.d;\n}>",
                "methodName": "testMixedChains"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.JspbTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[($$temp = opt_data.proto == null ? null : opt_data.proto].getSomeEmbeddedMess...> but was:<[var $tmp = opt_data.proto;\n($$temp = $tmp == null ? null : $tmp].getSomeEmbeddedMess...>",
                "methodName": "testNullSafeReference"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.JspbTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[opt_data.proto == null ? null : opt_data.proto.getSomeEmbeddedMessage() == null ? null : opt_data.proto.getSomeEmbeddedMessage().getSomeEmbeddedString();]> but was:<[var $tmp$$2;\nvar $tmp = opt_data.proto;\nif ($tmp == null) {\n  $tmp$$2 = null;\n} else {\n  var $tmp$$1 = $tmp.getSomeEmbeddedMessage();\n  $tmp$$2 = $tmp$$1 == null ? null : $tmp$$1.getSomeEmbeddedString();\n}]>",
                "methodName": "testMathOnNullableValues"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.JspbTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[opt_data.proto == null ? null : opt_data.proto].getAnotherValue();> but was:<[var $tmp = opt_data.proto;\n$tmp == null ? null : $tmp].getAnotherValue();>",
                "methodName": "testNullSafePrimitive"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsExprsVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<var $tmp[ = null];\nif (opt_data.boo) ...> but was:<var $tmp[];\nif (opt_data.boo) ...>",
                "methodName": "testIf"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsExprsVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<var $tmp[ = null];\nif (opt_data.boo) ...> but was:<var $tmp[];\nif (opt_data.boo) ...>",
                "methodName": "testIfNoElse"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<var $tmp[ = null];\nif (opt_data.boo) ...> but was:<var $tmp[];\nif (opt_data.boo) ...>",
                "methodName": "testIf"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.TranslateExprNodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<[opt_data.boo == null ? null : opt_data.boo].goo;> but was:<[var $tmp = opt_data.boo;\n$tmp == null ? null : $tmp].goo;>",
                "methodName": "testDataRef"
            }
        ],
        "metrics": {
            "chunks": 23,
            "classes": 4,
            "files": 4,
            "linesAdd": 18,
            "linesMod": 20,
            "linesRem": 24,
            "methods": 9,
            "sizeInLines": 38
        },
        "program": "RegressionBug-88",
        "project": "RegressionBug-88",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n@@ -63,8 +63,8 @@\n   public static final WithValue LITERAL_TRUE = id(\"true\");\n   public static final WithValue LITERAL_FALSE = id(\"false\");\n   public static final WithValue LITERAL_NULL = id(\"null\");\n-  public static final WithValue LITERAL_EMPTY_STRING = Leaf.create(\"''\", /* isCheap= */ true);\n-  public static final WithValue EMPTY_OBJECT_LITERAL = Leaf.create(\"{}\", /* isCheap= */ false);\n+  public static final WithValue LITERAL_EMPTY_STRING = Leaf.create(\"''\");\n+  public static final WithValue EMPTY_OBJECT_LITERAL = Leaf.create(\"{}\");\n \n   /** Creates a new code chunk representing the concatenation of the given chunks. */\n   public static CodeChunk statements(CodeChunk first, CodeChunk... rest) {\n@@ -93,7 +93,7 @@\n   public static WithValue fromExpr(JsExpr expr, Iterable<GoogRequire> requires) {\n-    return Leaf.create(expr, /* isCheap= */ false, requires);\n+    return Leaf.create(expr, requires);\n   }\n \n   /**\n@@ -103,7 +103,7 @@\n    */\n   public static WithValue id(String id) {\n     CodeChunkUtils.checkId(id);\n-    return Leaf.create(id, /* isCheap= */ true);\n+    return Leaf.create(id);\n   }\n   /**\n    * Creates a code chunk representing a JavaScript identifier.\n@@ -112,7 +112,7 @@\n    */\n   static WithValue id(String id, Iterable<GoogRequire> requires) {\n     CodeChunkUtils.checkId(id);\n-    return Leaf.create(id, /* isCheap= */ true, requires);\n+    return Leaf.create(id, requires);\n   }\n \n   /**\n@@ -162,19 +162,19 @@\n     // forward slash in the string to get around this issue.\n     escaped = escaped.replace(\"</script\", \"<\\\\/script\");\n \n-    return Leaf.create(escaped, /* isCheap= */ true);\n+    return Leaf.create(escaped);\n   }\n \n   /** Creates a code chunk representing a JavaScript number literal. */\n   public static WithValue number(long value) {\n     Preconditions.checkArgument(\n         IntegerNode.isInRange(value), \"Number is outside JS safe integer range: %s\", value);\n-    return Leaf.create(Long.toString(value), /* isCheap= */ true);\n+    return Leaf.create(Long.toString(value));\n   }\n \n   /** Creates a code chunk representing a JavaScript number literal. */\n   public static WithValue number(double value) {\n-    return Leaf.create(Double.toString(value), /* isCheap= */ true);\n+    return Leaf.create(Double.toString(value));\n   }\n \n   /** Creates a code chunk that assigns value to a preexisting variable with the given name. */\n@@ -489,16 +489,6 @@\n      *\n      * <p>The default is {@code false}, only certain special code chunks return {@code true}.\n      */\n-    public boolean isCheap() {\n-      return false;\n-    }\n   }\n \n   /**\n@@ -676,11 +666,6 @@\n       return CodeChunk.declare(newVarName(), rhs);\n     }\n \n     /** Creates a code chunk declaring an automatically-named variable with no initializer. */\n-    public VariableDeclaration declare() {\n-      return VariableDeclaration.create(newVarName(), /*initializer=*/ null);\n-    }\n-\n     /**\n      * Returns a code chunk representing an if-then-else condition.\n      *\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/Conditional.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/Conditional.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/Conditional.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/Conditional.java\n@@ -144,7 +144,7 @@\n    */\n   CodeChunk.WithValue asConditionalExpression(CodeChunk.Generator codeGenerator) {\n     Preconditions.checkState(everyBranchHasAValue());\n-    VariableDeclaration decl = codeGenerator.declare();\n+    VariableDeclaration decl = codeGenerator.declare(WithValue.LITERAL_NULL);\n     CodeChunk.WithValue var = decl.ref();\n     ConditionalBuilder builder = null;\n     for (IfThenPair oldCondition : conditions()) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/Leaf.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/Leaf.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/Leaf.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/Leaf.java\n@@ -28,24 +28,22 @@\n @AutoValue\n @Immutable\n abstract class Leaf extends CodeChunk.WithValue {\n-  static WithValue create(String text, boolean isCheap, Iterable<GoogRequire> require) {\n-    return create(new JsExpr(text, Integer.MAX_VALUE), isCheap, ImmutableSet.copyOf(require));\n+  static WithValue create(String text, Iterable<GoogRequire> require) {\n+    return create(new JsExpr(text, Integer.MAX_VALUE), ImmutableSet.copyOf(require));\n   }\n \n-  static Leaf create(String text, boolean isCheap) {\n-    return create(new JsExpr(text, Integer.MAX_VALUE), isCheap, ImmutableSet.<GoogRequire>of());\n+  static Leaf create(String text) {\n+    return create(new JsExpr(text, Integer.MAX_VALUE), ImmutableSet.<GoogRequire>of());\n   }\n \n-  static Leaf create(JsExpr value, boolean isCheap, Iterable<GoogRequire> requires) {\n-    return new AutoValue_Leaf(value, ImmutableSet.copyOf(requires), isCheap);\n+  static Leaf create(JsExpr value, Iterable<GoogRequire> requires) {\n+    return new AutoValue_Leaf(value, ImmutableSet.copyOf(requires));\n   }\n\n   abstract JsExpr value();\n \n   abstract ImmutableSet<GoogRequire> requires();\n \n-  @Override\n-  public abstract boolean isCheap();\n \n   @Override\n   void doFormatInitialStatements(FormattingContext ctx) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java\n@@ -22,11 +22,11 @@\n \n import com.google.auto.value.AutoValue;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.ForOverride;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n import com.google.template.soy.jssrc.dsl.CodeChunk.WithValue;\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import javax.annotation.Nullable;\n \n@@ -106,51 +106,52 @@\n    * generate code to make sure the chain is non-null before performing the access.\n    */\n   CodeChunk.WithValue result(CodeChunk.Generator codeGenerator) {\n-    CodeChunk.WithValue accessChain = buildAccessChain(base, codeGenerator, chain.iterator());\n     // First generate a list of every partial evaluation of the chain.\n+    ImmutableList<CodeChunk.WithValue> intermediateValues = buildIntermediateValues();\n+    Preconditions.checkState(intermediateValues.size() == chain.size() + 1);\n\n+    CodeChunk.WithValue cur = intermediateValues.get(intermediateValues.size() - 1);\n+    for (int i = intermediateValues.size() - 2; i >= 0; --i) {\n+      CodeChunk.WithValue chunk = intermediateValues.get(i);\n+      boolean nullSafe = chain.get(i).nullSafe;\n+      if (nullSafe) {\n+        cur = ifExpression(chunk.doubleEqualsNull(), LITERAL_NULL).else_(cur).build(codeGenerator);\n+      }\n+    }\n \n     if (unpackFunction == null) {\n-      return accessChain;\n+      return cur;\n     } else if (!isRepeated) {\n       // It's okay if the whole chain evals to null. The unpack functions accept null.\n-      return unpackFunction.call(accessChain);\n+      return unpackFunction.call(cur);\n     } else {\n-      return GOOG_ARRAY_MAP.call(accessChain, unpackFunction);\n+      return GOOG_ARRAY_MAP.call(cur, unpackFunction);\n     }\n   }\n \n-  private static CodeChunk.WithValue buildAccessChain(\n-      CodeChunk.WithValue base, CodeChunk.Generator generator, Iterator<ChainAccess> chain) {\n-    if (!chain.hasNext()) {\n-      return base; // base case\n-    }\n-    ChainAccess link = chain.next();\n-    if (link.nullSafe) {\n-      if (!base.isCheap()) {\n-        base = generator.declare(base).ref();\n-      }\n-      return ifExpression(base.doubleEqualsNull(), LITERAL_NULL)\n-          .else_(buildAccessChain(link.extend(base), generator, chain))\n-          .build(generator);\n+  private ImmutableList<CodeChunk.WithValue> buildIntermediateValues() {\n+    ImmutableList.Builder<CodeChunk.WithValue> builder = ImmutableList.builder();\n+    CodeChunk.WithValue prev = base;\n+    builder.add(prev);\n+    for (ChainAccess link : chain) {\n+      prev = link.extend(prev);\n+      builder.add(prev);\n     }\n-    return buildAccessChain(link.extend(base), generator, chain);\n+    return builder.build();\n   }\n \n   /**",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n@@ -63,8 +63,8 @@\n   public static final WithValue LITERAL_TRUE = id(\"true\");\n   public static final WithValue LITERAL_FALSE = id(\"false\");\n   public static final WithValue LITERAL_NULL = id(\"null\");\n-  public static final WithValue LITERAL_EMPTY_STRING = Leaf.create(\"''\");\n-  public static final WithValue EMPTY_OBJECT_LITERAL = Leaf.create(\"{}\");\n+  public static final WithValue LITERAL_EMPTY_STRING = Leaf.create(\"''\", /* isCheap= */ true);\n+  public static final WithValue EMPTY_OBJECT_LITERAL = Leaf.create(\"{}\", /* isCheap= */ false);\n \n   /** Creates a new code chunk representing the concatenation of the given chunks. */\n   public static CodeChunk statements(CodeChunk first, CodeChunk... rest) {\n@@ -93,7 +93,7 @@\n   public static WithValue fromExpr(JsExpr expr, Iterable<GoogRequire> requires) {\n-    return Leaf.create(expr, requires);\n+    return Leaf.create(expr, /* isCheap= */ false, requires);\n   }\n \n   /**\n@@ -103,7 +103,7 @@\n    */\n   public static WithValue id(String id) {\n     CodeChunkUtils.checkId(id);\n-    return Leaf.create(id);\n+    return Leaf.create(id, /* isCheap= */ true);\n   }\n   /**\n    * Creates a code chunk representing a JavaScript identifier.\n@@ -112,7 +112,7 @@\n    */\n   static WithValue id(String id, Iterable<GoogRequire> requires) {\n     CodeChunkUtils.checkId(id);\n-    return Leaf.create(id, requires);\n+    return Leaf.create(id, /* isCheap= */ true, requires);\n   }\n \n   /**\n@@ -162,19 +162,19 @@\n     // forward slash in the string to get around this issue.\n     escaped = escaped.replace(\"</script\", \"<\\\\/script\");\n \n-    return Leaf.create(escaped);\n+    return Leaf.create(escaped, /* isCheap= */ true);\n   }\n \n   /** Creates a code chunk representing a JavaScript number literal. */\n   public static WithValue number(long value) {\n     Preconditions.checkArgument(\n         IntegerNode.isInRange(value), \"Number is outside JS safe integer range: %s\", value);\n-    return Leaf.create(Long.toString(value));\n+    return Leaf.create(Long.toString(value), /* isCheap= */ true);\n   }\n \n   /** Creates a code chunk representing a JavaScript number literal. */\n   public static WithValue number(double value) {\n-    return Leaf.create(Double.toString(value));\n+    return Leaf.create(Double.toString(value), /* isCheap= */ true);\n   }\n \n   /** Creates a code chunk that assigns value to a preexisting variable with the given name. */\n@@ -489,6 +489,16 @@\n      *\n      * <p>The default is {@code false}, only certain special code chunks return {@code true}.\n      */\n+    public boolean isCheap() {\n+      return false;\n+    }\n   }\n \n   /**\n@@ -666,6 +676,11 @@\n       return CodeChunk.declare(newVarName(), rhs);\n     } \n \n     /** Creates a code chunk declaring an automatically-named variable with no initializer. */\n+    public VariableDeclaration declare() {\n+      return VariableDeclaration.create(newVarName(), /*initializer=*/ null);\n+    }\n+\n     /**\n      * Returns a code chunk representing an if-then-else condition.\n      *\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/Conditional.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/Conditional.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/Conditional.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/Conditional.java\n@@ -144,7 +144,7 @@\n    */\n   CodeChunk.WithValue asConditionalExpression(CodeChunk.Generator codeGenerator) {\n     Preconditions.checkState(everyBranchHasAValue());\n-    VariableDeclaration decl = codeGenerator.declare(WithValue.LITERAL_NULL);\n+    VariableDeclaration decl = codeGenerator.declare();\n     CodeChunk.WithValue var = decl.ref();\n     ConditionalBuilder builder = null;\n     for (IfThenPair oldCondition : conditions()) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/Leaf.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/Leaf.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/Leaf.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/Leaf.java\n@@ -28,22 +28,24 @@\n @AutoValue\n @Immutable\n abstract class Leaf extends CodeChunk.WithValue {\n-  static WithValue create(String text, Iterable<GoogRequire> require) {\n-    return create(new JsExpr(text, Integer.MAX_VALUE), ImmutableSet.copyOf(require));\n+  static WithValue create(String text, boolean isCheap, Iterable<GoogRequire> require) {\n+    return create(new JsExpr(text, Integer.MAX_VALUE), isCheap, ImmutableSet.copyOf(require));\n   }\n \n-  static Leaf create(String text) {\n-    return create(new JsExpr(text, Integer.MAX_VALUE), ImmutableSet.<GoogRequire>of());\n+  static Leaf create(String text, boolean isCheap) {\n+    return create(new JsExpr(text, Integer.MAX_VALUE), isCheap, ImmutableSet.<GoogRequire>of());\n   }\n \n-  static Leaf create(JsExpr value, Iterable<GoogRequire> requires) {\n-    return new AutoValue_Leaf(value, ImmutableSet.copyOf(requires));\n+  static Leaf create(JsExpr value, boolean isCheap, Iterable<GoogRequire> requires) {\n+    return new AutoValue_Leaf(value, ImmutableSet.copyOf(requires), isCheap);\n   }  \n\n   abstract JsExpr value();\n \n   abstract ImmutableSet<GoogRequire> requires();\n \n+  @Override\n+  public abstract boolean isCheap();\n \n   @Override\n   void doFormatInitialStatements(FormattingContext ctx) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/NullSafeAccumulator.java\n@@ -22,11 +22,11 @@\n \n import com.google.auto.value.AutoValue;\n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.ForOverride;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n import com.google.template.soy.jssrc.dsl.CodeChunk.WithValue;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import javax.annotation.Nullable;\n \n@@ -106,52 +106,51 @@\n    * generate code to make sure the chain is non-null before performing the access.\n    */\n   CodeChunk.WithValue result(CodeChunk.Generator codeGenerator) {\n     // First generate a list of every partial evaluation of the chain.\n-    ImmutableList<CodeChunk.WithValue> intermediateValues = buildIntermediateValues();\n-    Preconditions.checkState(intermediateValues.size() == chain.size() + 1);\n\n-    CodeChunk.WithValue cur = intermediateValues.get(intermediateValues.size() - 1);\n-    for (int i = intermediateValues.size() - 2; i >= 0; --i) {\n-      CodeChunk.WithValue chunk = intermediateValues.get(i);\n-      boolean nullSafe = chain.get(i).nullSafe;\n-      if (nullSafe) {\n-        cur = ifExpression(chunk.doubleEqualsNull(), LITERAL_NULL).else_(cur).build(codeGenerator);\n-      }\n-    }\n+    CodeChunk.WithValue accessChain = buildAccessChain(base, codeGenerator, chain.iterator());\n \n     if (unpackFunction == null) {\n-      return cur;\n+      return accessChain;\n     } else if (!isRepeated) {\n       // It's okay if the whole chain evals to null. The unpack functions accept null.\n-      return unpackFunction.call(cur);\n+      return unpackFunction.call(accessChain);\n     } else {\n-      return GOOG_ARRAY_MAP.call(cur, unpackFunction);\n+      return GOOG_ARRAY_MAP.call(accessChain, unpackFunction);\n     }\n   }\n \n-  private ImmutableList<CodeChunk.WithValue> buildIntermediateValues() {\n-    ImmutableList.Builder<CodeChunk.WithValue> builder = ImmutableList.builder();\n-    CodeChunk.WithValue prev = base;\n-    builder.add(prev);\n-    for (ChainAccess link : chain) {\n-      prev = link.extend(prev);\n-      builder.add(prev);\n+  private static CodeChunk.WithValue buildAccessChain(\n+      CodeChunk.WithValue base, CodeChunk.Generator generator, Iterator<ChainAccess> chain) {\n+    if (!chain.hasNext()) {\n+      return base; // base case\n+    }\n+    ChainAccess link = chain.next();\n+    if (link.nullSafe) {\n+      if (!base.isCheap()) {\n+        base = generator.declare(base).ref();\n+      }\n+      return ifExpression(base.doubleEqualsNull(), LITERAL_NULL)\n+          .else_(buildAccessChain(link.extend(base), generator, chain))\n+          .build(generator);\n     }\n-    return builder.build();\n+    return buildAccessChain(link.extend(base), generator, chain);\n   }\n \n   /**",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-89",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsExprsVisitorTest",
                "error": "java.lang.AssertionError",
                "message": "Unexpected SoyError: Unexpected close tag for context-changing tag. at no-path:5:1",
                "methodName": "testRawText"
            },
            {
                "className": "com.google.template.soy.parsepasses.contextautoesc.ContextualAutoescaperTest",
                "error": "java.lang.AssertionError",
                "message": "Unexpected SoyError: Unexpected close tag for context-changing tag. at no-path:4:1",
                "methodName": "testTagNameEdgeCases"
            }
        ],
        "metrics": {
            "chunks": 24,
            "classes": 2,
            "files": 2,
            "linesAdd": 22,
            "linesMod": 4,
            "linesRem": 55,
            "methods": 20,
            "sizeInLines": 26
        },
        "program": "RegressionBug-89",
        "project": "RegressionBug-89",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/HtmlRewritePass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/HtmlRewritePass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/HtmlRewritePass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/HtmlRewritePass.java\n@@ -209,14 +209,10 @@\n   private static final SoyErrorKind UNEXPECTED_WS_AFTER_LT =\n       SoyErrorKind.of(\"Unexpected whitespace after ''<'', did you mean ''&lt;''?\");\n \n-  private static final SoyErrorKind UNEXPECTED_CLOSE_TAG =\n-      SoyErrorKind.of(\"Unexpected close tag for context-changing tag.\");\n\n   /** Represents features of the parser states. */\n   private enum StateFeature {\n     /** Means the state is part of an html 'tag' of a node (but not, inside an attribute value). */\n     TAG,\n-    RCDATA,\n     INVALID_END_STATE_FOR_BLOCK;\n   }\n \n@@ -229,11 +225,10 @@\n   private enum State {\n     NONE,\n     PCDATA,\n-    RCDATA_SCRIPT(StateFeature.RCDATA),\n-    RCDATA_TEXTAREA(StateFeature.RCDATA),\n-    RCDATA_TITLE(StateFeature.RCDATA),\n-    RCDATA_STYLE(StateFeature.RCDATA),\n-    RCDATA_XMP(StateFeature.RCDATA),\n+    RCDATA_SCRIPT,\n+    RCDATA_TEXTAREA,\n+    RCDATA_TITLE,\n+    RCDATA_STYLE,\n     HTML_COMMENT,\n     CDATA,\n\n@@ -331,7 +326,6 @@\n         case PCDATA:\n         case RCDATA_STYLE:\n         case RCDATA_TITLE:\n-        case RCDATA_XMP:\n         case RCDATA_SCRIPT:\n         case RCDATA_TEXTAREA:\n         case DOUBLE_QUOTED_ATTRIBUTE_VALUE:\n@@ -361,10 +355,6 @@\n       return stateTypes.contains(StateFeature.INVALID_END_STATE_FOR_BLOCK);\n     }\n \n-    boolean isRcDataState() {\n-      return stateTypes.contains(StateFeature.RCDATA);\n-    }\n-\n     @Override\n     public String toString() {\n       return Ascii.toLowerCase(name().replace('_', ' '));\n@@ -653,9 +643,6 @@\n           case RCDATA_TITLE:\n             handleRcData(TagName.RcDataTagName.TITLE);\n             break;\n-          case RCDATA_XMP:\n-            handleRcData(TagName.RcDataTagName.XMP);\n-            break;\n           case RCDATA_SCRIPT:\n             handleRcData(TagName.RcDataTagName.SCRIPT);\n             break;\n@@ -749,7 +736,6 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n-        case RCDATA_XMP:\n         case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:\n         case XML_DECLARATION:\n           // no op\n@@ -761,14 +747,15 @@\n     void handleRcData(TagName.RcDataTagName tagName) {\n       boolean foundLt = advanceWhileMatches(NOT_LT);\n       if (foundLt) {\n         if (matchPrefixIgnoreCase(\"</\" + tagName, false /* don't advance */)) {\n-          handlePcData();\n+          context.setState(State.PCDATA, currentPoint());\n         } else {\n           advance();\n         }\n@@ -1478,7 +1465,6 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n-        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1534,7 +1520,6 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n-        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1670,7 +1655,6 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n-        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1738,7 +1722,6 @@\n           case RCDATA_STYLE:\n           case RCDATA_TEXTAREA:\n           case RCDATA_TITLE:\n-          case RCDATA_XMP:\n           case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:\n           case XML_DECLARATION:\n             context.reset();\n@@ -1811,7 +1794,6 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n-        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1852,8 +1834,6 @@\n           return didYouForgetToCloseThe(\"<textare> block\");\n         case RCDATA_TITLE:\n           return didYouForgetToCloseThe(\"<title> block\");\n-        case RCDATA_XMP:\n-          return didYouForgetToCloseThe(\"<xmp> block\");\n         case HTML_TAG_NAME: // kind of crazy\n         case AFTER_ATTRIBUTE_NAME:\n         case AFTER_TAG_NAME_OR_ATTRIBUTE:\n@@ -2051,7 +2031,6 @@\n     SourceLocation.Point tagStartPoint;\n     RawTextNode tagStartNode;\n     TagName tagName;\n-    State tagStartState;\n \n     // TODO(lukes): consider lazily allocating these lists.\n     /** All the 'direct' children of the current tag. */\n@@ -2170,9 +2149,6 @@\n       if (tagStartNode != null) {\n         error = format(error, \"Expected tagStartNode to be null, got: %s\", tagStartNode);\n       }\n-      if (tagStartState != null) {\n-        error = format(error, \"Expected tagStartState to be null, got: %s\", tagStartState);\n-      }\n       if (quotedAttributeValueStart != null) {\n         error =\n             format(\n@@ -2202,7 +2178,6 @@\n       tagStartPoint = null;\n       tagStartNode = null;\n       tagName = null;\n-      tagStartState = null;\n       directTagChildren.clear();\n       resetAttribute();\n     }\n@@ -2225,12 +2200,10 @@\n     void startTag(RawTextNode tagStartNode, boolean isCloseTag, SourceLocation.Point point) {\n       checkState(this.tagStartPoint == null);\n       checkState(this.tagStartNode == null);\n-      checkState(this.tagStartState == null);\n       checkState(this.directTagChildren.isEmpty());\n \n       if (startingState != State.PCDATA) {\n         errorReporter.report(\n             point.asLocation(filePath),\n@@ -2241,7 +2214,6 @@\n         throw new AbortParsingBlockError();\n       }\n \n-      this.tagStartState = state;\n       this.tagStartPoint = checkNotNull(point);\n       this.tagStartNode = checkNotNull(tagStartNode);\n       this.isCloseTag = isCloseTag;\n@@ -2386,14 +2358,27 @@\n         replacement = new HtmlOpenTagNode(nodeIdGen.genId(), tagName, sourceLocation, selfClosing);\n       }\n       // Depending on the tag name, we may need to enter a special state after the tag.\n-      State nextState = getNextState(tagName);\n-      if (isCloseTag && nextState.isRcDataState() && tagStartState != nextState) {\n-        errorReporter.report(tagStartLocation(), UNEXPECTED_CLOSE_TAG);\n-      }\n-      if (selfClosing || isCloseTag) {\n-        nextState = State.PCDATA;\n+      State nextState = State.PCDATA;\n+      if (!selfClosing && !isCloseTag) {\n+        TagName.RcDataTagName rcDataTag = tagName.getRcDataTagName();\n+        if (rcDataTag != null) {\n+          switch (rcDataTag) {\n+            case SCRIPT:\n+              nextState = State.RCDATA_SCRIPT;\n+              break;\n+            case STYLE:\n+              nextState = State.RCDATA_STYLE;\n+              break;\n+            case TEXTAREA:\n+              nextState = State.RCDATA_TEXTAREA;\n+              break;\n+            case TITLE:\n+              nextState = State.RCDATA_TITLE;\n+              break;\n+            default:\n+              throw new AssertionError(rcDataTag);\n+          }\n+        }\n       }\n       edits.remove(tagEndNode);\n       edits.addChild(replacement, tagName.getNode());\n@@ -2403,32 +2388,11 @@\n       directTagChildren.clear();\n       tagStartPoint = null;\n       tagName = null;\n-      tagStartState = null;\n       tagStartNode = null;\n       checkEmpty(\"Expected state to be empty after completing a tag\");\n       return nextState;\n     }\n \n-    private static State getNextState(TagName tagName) {\n-      if (tagName.getRcDataTagName() == null) {\n-        return State.PCDATA;\n-      }\n-      switch (tagName.getRcDataTagName()) {\n-        case SCRIPT:\n-          return State.RCDATA_SCRIPT;\n-        case STYLE:\n-          return State.RCDATA_STYLE;\n-        case TEXTAREA:\n-          return State.RCDATA_TEXTAREA;\n-        case TITLE:\n-          return State.RCDATA_TITLE;\n-        case XMP:\n-          return State.RCDATA_XMP;\n-        default:\n-          throw new AssertionError(tagName.getRcDataTagName());\n-      }\n-    }\n\n     void maybeFinishPendingAttribute(SourceLocation.Point currentPoint) {\n       // For quoted attribute values we should have already finished them (when we saw the closing\n       // quote).  But for unquoted attribute values we delay closing them until we see a delimiter\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TagName.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TagName.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TagName.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TagName.java\n@@ -49,8 +49,7 @@\n     SCRIPT,\n     STYLE,\n     TITLE,\n-    TEXTAREA,\n-    XMP;\n+    TEXTAREA;\n \n     @Override\n     public String toString() {\n@@ -111,9 +110,6 @@\n       case \"title\":\n         rcDataTagName = RcDataTagName.TITLE;\n         break;\n-      case \"xmp\":\n-        rcDataTagName = RcDataTagName.XMP;\n-        break;\n       default:\n         rcDataTagName = null;\n         break;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/HtmlRewritePass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/HtmlRewritePass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/HtmlRewritePass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/HtmlRewritePass.java\n@@ -209,10 +209,14 @@\n   private static final SoyErrorKind UNEXPECTED_WS_AFTER_LT =\n       SoyErrorKind.of(\"Unexpected whitespace after ''<'', did you mean ''&lt;''?\");\n \n+  private static final SoyErrorKind UNEXPECTED_CLOSE_TAG =\n+      SoyErrorKind.of(\"Unexpected close tag for context-changing tag.\");\n\n   /** Represents features of the parser states. */\n   private enum StateFeature {\n     /** Means the state is part of an html 'tag' of a node (but not, inside an attribute value). */\n     TAG,\n+    RCDATA,\n     INVALID_END_STATE_FOR_BLOCK;\n   }\n \n@@ -225,10 +229,11 @@\n   private enum State {\n     NONE,\n     PCDATA,\n-    RCDATA_SCRIPT,\n-    RCDATA_TEXTAREA,\n-    RCDATA_TITLE,\n-    RCDATA_STYLE,\n+    RCDATA_SCRIPT(StateFeature.RCDATA),\n+    RCDATA_TEXTAREA(StateFeature.RCDATA),\n+    RCDATA_TITLE(StateFeature.RCDATA),\n+    RCDATA_STYLE(StateFeature.RCDATA),\n+    RCDATA_XMP(StateFeature.RCDATA),\n     HTML_COMMENT,\n     CDATA,\n\n@@ -326,6 +331,7 @@\n         case PCDATA:\n         case RCDATA_STYLE:\n         case RCDATA_TITLE:\n+        case RCDATA_XMP:\n         case RCDATA_SCRIPT:\n         case RCDATA_TEXTAREA:\n         case DOUBLE_QUOTED_ATTRIBUTE_VALUE:\n@@ -355,6 +361,10 @@\n       return stateTypes.contains(StateFeature.INVALID_END_STATE_FOR_BLOCK);\n     }\n \n+    boolean isRcDataState() {\n+      return stateTypes.contains(StateFeature.RCDATA);\n+    }\n\n     @Override\n     public String toString() {\n       return Ascii.toLowerCase(name().replace('_', ' '));\n@@ -643,6 +653,9 @@\n           case RCDATA_TITLE:\n             handleRcData(TagName.RcDataTagName.TITLE);\n             break;\n+          case RCDATA_XMP:\n+            handleRcData(TagName.RcDataTagName.XMP);\n+            break;\n           case RCDATA_SCRIPT:\n             handleRcData(TagName.RcDataTagName.SCRIPT);\n             break;\n@@ -736,6 +749,7 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n+        case RCDATA_XMP:\n         case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:\n         case XML_DECLARATION:\n           // no op\n@@ -747,15 +761,14 @@\n     void handleRcData(TagName.RcDataTagName tagName) {\n       boolean foundLt = advanceWhileMatches(NOT_LT);\n       if (foundLt) {\n         if (matchPrefixIgnoreCase(\"</\" + tagName, false /* don't advance */)) {\n-          context.setState(State.PCDATA, currentPoint());\n+          handlePcData();\n         } else {\n           advance();\n         }\n@@ -1465,6 +1478,7 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n+        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1520,6 +1534,7 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n+        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1655,6 +1670,7 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n+        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1722,6 +1738,7 @@\n           case RCDATA_STYLE:\n           case RCDATA_TEXTAREA:\n           case RCDATA_TITLE:\n+          case RCDATA_XMP:\n           case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:\n           case XML_DECLARATION:\n             context.reset();\n@@ -1794,6 +1811,7 @@\n         case RCDATA_STYLE:\n         case RCDATA_TEXTAREA:\n         case RCDATA_TITLE:\n+        case RCDATA_XMP:\n         case XML_DECLARATION:\n         case CDATA:\n         case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:\n@@ -1834,6 +1852,8 @@\n           return didYouForgetToCloseThe(\"<textare> block\");\n         case RCDATA_TITLE:\n           return didYouForgetToCloseThe(\"<title> block\");\n+        case RCDATA_XMP:\n+          return didYouForgetToCloseThe(\"<xmp> block\");\n         case HTML_TAG_NAME: // kind of crazy\n         case AFTER_ATTRIBUTE_NAME:\n         case AFTER_TAG_NAME_OR_ATTRIBUTE:\n@@ -2031,6 +2051,7 @@\n     SourceLocation.Point tagStartPoint;\n     RawTextNode tagStartNode;\n     TagName tagName;\n+    State tagStartState;\n \n     // TODO(lukes): consider lazily allocating these lists.\n     /** All the 'direct' children of the current tag. */\n@@ -2149,6 +2170,9 @@\n       if (tagStartNode != null) {\n         error = format(error, \"Expected tagStartNode to be null, got: %s\", tagStartNode);\n       }\n+      if (tagStartState != null) {\n+        error = format(error, \"Expected tagStartState to be null, got: %s\", tagStartState);\n+      }\n       if (quotedAttributeValueStart != null) {\n         error =\n             format(\n@@ -2178,6 +2202,7 @@\n       tagStartPoint = null;\n       tagStartNode = null;\n       tagName = null;\n+      tagStartState = null;\n       directTagChildren.clear();\n       resetAttribute();\n     }\n@@ -2200,10 +2225,12 @@\n     void startTag(RawTextNode tagStartNode, boolean isCloseTag, SourceLocation.Point point) {\n       checkState(this.tagStartPoint == null);\n       checkState(this.tagStartNode == null);\n+      checkState(this.tagStartState == null);\n       checkState(this.directTagChildren.isEmpty());\n\n       if (startingState != State.PCDATA) {\n         errorReporter.report(\n             point.asLocation(filePath),\n@@ -2214,6 +2241,7 @@\n         throw new AbortParsingBlockError();\n       }\n \n+      this.tagStartState = state;\n       this.tagStartPoint = checkNotNull(point);\n       this.tagStartNode = checkNotNull(tagStartNode);\n       this.isCloseTag = isCloseTag;\n@@ -2358,27 +2386,14 @@\n         replacement = new HtmlOpenTagNode(nodeIdGen.genId(), tagName, sourceLocation, selfClosing);\n       }\n       // Depending on the tag name, we may need to enter a special state after the tag.\n-      State nextState = State.PCDATA;\n-      if (!selfClosing && !isCloseTag) {\n-        TagName.RcDataTagName rcDataTag = tagName.getRcDataTagName();\n-        if (rcDataTag != null) {\n-          switch (rcDataTag) {\n-            case SCRIPT:\n-              nextState = State.RCDATA_SCRIPT;\n-              break;\n-            case STYLE:\n-              nextState = State.RCDATA_STYLE;\n-              break;\n-            case TEXTAREA:\n-              nextState = State.RCDATA_TEXTAREA;\n-              break;\n-            case TITLE:\n-              nextState = State.RCDATA_TITLE;\n-              break;\n-            default:\n-              throw new AssertionError(rcDataTag);\n-          }\n-        }\n+      State nextState = getNextState(tagName);\n+      if (isCloseTag && nextState.isRcDataState() && tagStartState != nextState) {\n+        errorReporter.report(tagStartLocation(), UNEXPECTED_CLOSE_TAG);\n+      }\n+      if (selfClosing || isCloseTag) {\n+        nextState = State.PCDATA;\n       }\n       edits.remove(tagEndNode);\n       edits.addChild(replacement, tagName.getNode());\n@@ -2388,11 +2403,32 @@\n       directTagChildren.clear();\n       tagStartPoint = null;\n       tagName = null;\n+      tagStartState = null;\n       tagStartNode = null;\n       checkEmpty(\"Expected state to be empty after completing a tag\");\n       return nextState;\n     }\n \n+    private static State getNextState(TagName tagName) {\n+      if (tagName.getRcDataTagName() == null) {\n+        return State.PCDATA;\n+      }\n+      switch (tagName.getRcDataTagName()) {\n+        case SCRIPT:\n+          return State.RCDATA_SCRIPT;\n+        case STYLE:\n+          return State.RCDATA_STYLE;\n+        case TEXTAREA:\n+          return State.RCDATA_TEXTAREA;\n+        case TITLE:\n+          return State.RCDATA_TITLE;\n+        case XMP:\n+          return State.RCDATA_XMP;\n+        default:\n+          throw new AssertionError(tagName.getRcDataTagName());\n+      }\n+    }\n\n     void maybeFinishPendingAttribute(SourceLocation.Point currentPoint) {\n       // For quoted attribute values we should have already finished them (when we saw the closing\n       // quote).  But for unquoted attribute values we delay closing them until we see a delimiter\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TagName.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TagName.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TagName.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TagName.java\n@@ -49,7 +49,8 @@\n     SCRIPT,\n     STYLE,\n     TITLE,\n-    TEXTAREA;\n+    TEXTAREA,\n+    XMP;\n \n     @Override\n     public String toString() {\n@@ -110,6 +111,9 @@\n       case \"title\":\n         rcDataTagName = RcDataTagName.TITLE;\n         break;\n+      case \"xmp\":\n+        rcDataTagName = RcDataTagName.XMP;\n+        break;\n       default:\n         rcDataTagName = null;\n         break;",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-90",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.passes.ResolveNamesPassTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of: message()\nexpected: Variable '$la' already defined at line 4.\nbut was : Local variable '$la' conflicts with symbol defined at 4:8-4:10.",
                "methodName": "testVariableNameRedefinition"
            },
            {
                "className": "com.google.template.soy.passes.ResolveNamesPassTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of: message()\nexpected: Unknown variable.\nbut was : Unknown variable. Did you mean 'foo'?",
                "methodName": "testUnknownVariable"
            },
            {
                "className": "com.google.template.soy.passes.ResolveNamesPassTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of: message()\nexpected: Unknown variable.\nbut was : Unknown variable. Did you mean 'foo'?",
                "methodName": "testUnknownVariable_v1Expression"
            },
            {
                "className": "com.google.template.soy.passes.CheckTemplateHeaderVarsPassTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of: message()\nexpected: Unknown variable.\nbut was : Unknown variable. Did you mean 'foo1'?",
                "methodName": "testV1Expression"
            }
        ],
        "metrics": {
            "chunks": 30,
            "classes": 8,
            "files": 9,
            "linesAdd": 14,
            "linesMod": 13,
            "linesRem": 46,
            "methods": 11,
            "sizeInLines": 27
        },
        "program": "RegressionBug-90",
        "project": "RegressionBug-90",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/exprtree/VarDefn.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/exprtree/VarDefn.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/exprtree/VarDefn.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/exprtree/VarDefn.java\n@@ -50,8 +50,6 @@\n \n     // State variable\n     STATE,\n-    TEMPLATE,\n     // Undeclared variable reference (for legacy templates).\n     UNDECLARED,\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java\n@@ -69,9 +69,8 @@\n         return visitListComprehensionVar(node, (ComprehensionVarDefn) defn);\n       case IMPORT_VAR:\n         throw new IllegalStateException(\"import vars are not implemented yet\");\n-      case TEMPLATE:\n       case UNDECLARED:\n-        throw new RuntimeException(defn.kind() + \" are not supported by jbcsrc\");\n+        throw new RuntimeException(\"undeclared params are not supported by jbcsrc\");\n     }\n     throw new AssertionError(defn.kind());\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java\n@@ -1703,7 +1703,6 @@\n           return false;\n         case UNDECLARED:\n         case IMPORT_VAR:\n-        case TEMPLATE:\n           break;\n       }\n       throw new AssertionError();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java\n@@ -16,7 +16,6 @@\n \n package com.google.template.soy.passes;\n \n-import static com.google.template.soy.soytree.TemplateDelegateNodeBuilder.isDeltemplateTemplateName;\n import static java.util.stream.Collectors.toList;\n \n import com.google.common.base.Preconditions;\n@@ -31,7 +30,6 @@\n import com.google.template.soy.exprtree.ExprRootNode;\n import com.google.template.soy.exprtree.ListComprehensionNode;\n import com.google.template.soy.exprtree.VarDefn;\n-import com.google.template.soy.exprtree.VarDefn.Kind;\n import com.google.template.soy.soytree.AbstractSoyNodeVisitor;\n import com.google.template.soy.soytree.ForNonemptyNode;\n import com.google.template.soy.soytree.ImportNode;\n@@ -46,6 +44,7 @@\n import com.google.template.soy.soytree.SoyNode.ParentSoyNode;\n import com.google.template.soy.soytree.TemplateNode;\n import com.google.template.soy.soytree.defn.ImportedVar;\n+import com.google.template.soy.soytree.defn.LocalVar;\n import com.google.template.soy.soytree.defn.TemplateHeaderVarDefn;\n import java.util.ArrayDeque;\n import java.util.Deque;\n@@ -53,6 +52,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Optional;\n import java.util.function.Predicate;\n import javax.annotation.Nullable;\n \n@@ -80,7 +80,7 @@\n   static final class LocalVariables {\n \n     private static final SoyErrorKind VARIABLE_ALREADY_DEFINED =\n-        SoyErrorKind.of(\"{0} ''{1}'' conflicts with symbol defined at {2}.\");\n+        SoyErrorKind.of(\"Variable ''{0}'' already defined{1}.\");\n \n     private ErrorReporter errorReporter;\n     private final Deque<Map<String, VarDefn>> currentScope = new ArrayDeque<>();\n@@ -123,15 +123,15 @@\n       // Search for the name to see if it is being redefined.\n       VarDefn preexisting = lookupWithReserved(refName);\n       if (preexisting != null) {\n-        if (errorReporter != null && !shouldSkipError(defn, preexisting)) {\n-          SourceLocation defnSourceLocation =\n-              defn.nameLocation() == null ? definingNode.getSourceLocation() : defn.nameLocation();\n-          errorReporter.report(\n-              defnSourceLocation,\n-              VARIABLE_ALREADY_DEFINED,\n-              englishName(defn),\n-              refName,\n-              preexisting.nameLocation().toLineColumnString());\n+        Optional<SourceLocation> preexistingSourceLocation = forVarDefn(preexisting);\n+        SourceLocation defnSourceLocation =\n+            defn.nameLocation() == null ? definingNode.getSourceLocation() : defn.nameLocation();\n+        String location =\n+            preexistingSourceLocation.isPresent()\n+                ? \" at line \" + preexistingSourceLocation.get().getBeginLine()\n+                : \"\";\n+        if (errorReporter != null) {\n+          errorReporter.report(defnSourceLocation, VARIABLE_ALREADY_DEFINED, refName, location);\n         }\n         return false;\n       }\n@@ -192,17 +192,14 @@\n           // TODO(b/175405629): As a step towards supporting templates, we verify that there are no\n           // collisions here.\n           for (ImportedVar var : imp.getIdentifiers()) {\n-            localVariables.reserve(var, imp);\n+            localVariables.reserve(var, node);\n           }\n         } else {\n           for (ImportedVar var : imp.getIdentifiers()) {\n-            localVariables.define(var, imp);\n+            localVariables.define(var, node);\n           }\n         }\n       }\n-      for (TemplateNode template : node.getTemplates()) {\n-        localVariables.reserve(template.asVarDefn(), template);\n-      }\n \n       super.visitSoyFileNode(node);\n       localVariables.exitScope();\n@@ -291,29 +288,21 @@\n     }\n   }\n \n-  private static boolean shouldSkipError(VarDefn defn, VarDefn preexisting) {\n-    return defn.kind() == Kind.TEMPLATE\n-        && preexisting.kind() == Kind.TEMPLATE\n-        && isDeltemplateTemplateName(defn.name())\n-        && isDeltemplateTemplateName(preexisting.name());\n-  }\n-\n-  private static String englishName(VarDefn varDefn) {\n+  private static Optional<SourceLocation> forVarDefn(VarDefn varDefn) {\n     switch (varDefn.kind()) {\n       case PARAM:\n-        return \"Parameter\";\n       case STATE:\n-        return \"State parameter\";\n       case IMPORT_VAR:\n-        return \"Imported symbol\";\n+        return Optional.of(varDefn.nameLocation());\n       case LOCAL_VAR:\n+        return Optional.of(((LocalVar) varDefn).declaringNode().getSourceLocation());\n       case COMPREHENSION_VAR:\n-        return \"Local variable\";\n-      case TEMPLATE:\n-        return \"Template name\";\n+        return Optional.of(\n+            ((ListComprehensionNode.ComprehensionVarDefn) varDefn)\n+                .declaringNode()\n+                .getSourceLocation());\n       case UNDECLARED:\n-        return \"Symbol\";\n+        return Optional.empty();\n     }\n     throw new AssertionError(varDefn.kind());\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java\n@@ -26,6 +26,7 @@\n import com.google.template.soy.base.SourceFilePath;\n import com.google.template.soy.base.internal.IdGenerator;\n import com.google.template.soy.error.ErrorReporter;\n+import com.google.template.soy.error.SoyErrorKind;\n import com.google.template.soy.shared.SoyGeneralOptions;\n import com.google.template.soy.soytree.ImportNode;\n import com.google.template.soy.soytree.ImportNode.ImportType;\n@@ -53,6 +54,9 @@\n })\n public final class ResolveTemplateImportsPass extends ImportsPass implements CompilerFileSetPass {\n \n+  private static final SoyErrorKind IMPORT_CONFLICTS_WITH_TEMPLATE =\n+      SoyErrorKind.of(\"Import conflicts with local template ''{0}''.\");\n+\n   private TemplateNameRegistry templateNameRegistry;\n   private final SoyGeneralOptions options;\n   private final ErrorReporter errorReporter;\n@@ -141,7 +145,8 @@\n         // Consider moving this to ImportsPass.\n         String partialTemplateName = symbolToTemplateName.get(symbol.name());\n         if (partialTemplateName != null) {\n+          errorReporter.report(\n+              symbol.nameLocation(), IMPORT_CONFLICTS_WITH_TEMPLATE, partialTemplateName);\n           symbol.setType(UnknownType.getInstance());\n           continue;\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java\n@@ -122,11 +122,7 @@\n           // Case 1: Basic Template or Element node\n           TemplateMetadata prev =\n               basicTemplatesOrElementsMap.put(template.getTemplateName(), template);\n-          if (prev != null\n-              && !prev.getSourceLocation()\n-                  .getFileName()\n-                  .equals(template.getSourceLocation().getFileName())) {\n+          if (prev != null) {\n             errorReporter.report(\n                 template.getSourceLocation(),\n                 DUPLICATE_TEMPLATES,\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n@@ -129,10 +129,6 @@\n     return \"__deltemplate_\" + delPackageTemplateAndVariantStr;\n   }\n \n-  public static boolean isDeltemplateTemplateName(String templateName) {\n-    return templateName.startsWith(\"__deltemplate_\");\n-  }\n\n   @Override\n   public TemplateDelegateNode build() {\n     Preconditions.checkState(id != null && cmdText != null);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TemplateNode.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TemplateNode.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TemplateNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TemplateNode.java\n@@ -32,9 +32,7 @@\n import com.google.template.soy.basetree.CopyState;\n import com.google.template.soy.error.ErrorReporter;\n import com.google.template.soy.error.SoyErrorKind;\n-import com.google.template.soy.exprtree.AbstractVarDefn;\n import com.google.template.soy.exprtree.ExprRootNode;\n-import com.google.template.soy.exprtree.VarDefn;\n import com.google.template.soy.soytree.CommandTagAttribute.CommandTagAttributesHolder;\n import com.google.template.soy.soytree.SoyNode.ExprHolderNode;\n import com.google.template.soy.soytree.SoyNode.RenderUnitNode;\n@@ -42,8 +40,6 @@\n import com.google.template.soy.soytree.defn.TemplateHeaderVarDefn;\n import com.google.template.soy.soytree.defn.TemplateParam;\n import com.google.template.soy.soytree.defn.TemplateStateVar;\n-import com.google.template.soy.types.SoyType;\n-import com.google.template.soy.types.TemplateImportType;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n@@ -700,28 +696,4 @@\n         srcLocation.getFileName(),\n         srcLocation.getBeginLine());\n   }\n\n-  public VarDefn asVarDefn() {\n-    return new TemplateVarDefn(\n-        getLocalTemplateSymbol(),\n-        getTemplateNameLocation(),\n-        TemplateImportType.create(getTemplateName()));\n-  }\n\n-  private static class TemplateVarDefn extends AbstractVarDefn {\n-    public TemplateVarDefn(\n-        String name, @Nullable SourceLocation nameLocation, @Nullable SoyType type) {\n-      super(name, nameLocation, type);\n-    }\n\n-    @Override\n-    public Kind kind() {\n-      return Kind.TEMPLATE;\n-    }\n\n-    @Override\n-    public boolean isInjected() {\n-      return false;\n-    }\n-  }\n }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/exprtree/VarDefn.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/exprtree/VarDefn.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/exprtree/VarDefn.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/exprtree/VarDefn.java\n@@ -50,6 +50,8 @@\n \n     // State variable\n     STATE,\n+    TEMPLATE,\n     // Undeclared variable reference (for legacy templates).\n     UNDECLARED,\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/EnhancedAbstractExprNodeVisitor.java\n@@ -69,8 +69,9 @@\n         return visitListComprehensionVar(node, (ComprehensionVarDefn) defn);\n       case IMPORT_VAR:\n         throw new IllegalStateException(\"import vars are not implemented yet\");\n+      case TEMPLATE:\n       case UNDECLARED:\n-        throw new RuntimeException(\"undeclared params are not supported by jbcsrc\");\n+        throw new RuntimeException(defn.kind() + \" are not supported by jbcsrc\");\n     }\n     throw new AssertionError(defn.kind());\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/ExpressionCompiler.java\n@@ -1703,6 +1703,7 @@\n           return false;\n         case UNDECLARED:\n         case IMPORT_VAR:\n+        case TEMPLATE:\n           break;\n       }\n       throw new AssertionError();\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/LocalVariablesNodeVisitor.java\n@@ -16,6 +16,7 @@\n \n package com.google.template.soy.passes;\n \n+import static com.google.template.soy.soytree.TemplateDelegateNodeBuilder.isDeltemplateTemplateName;\n import static java.util.stream.Collectors.toList;\n \n import com.google.common.base.Preconditions;\n@@ -30,6 +31,7 @@\n import com.google.template.soy.exprtree.ExprRootNode;\n import com.google.template.soy.exprtree.ListComprehensionNode;\n import com.google.template.soy.exprtree.VarDefn;\n+import com.google.template.soy.exprtree.VarDefn.Kind;\n import com.google.template.soy.soytree.AbstractSoyNodeVisitor;\n import com.google.template.soy.soytree.ForNonemptyNode;\n import com.google.template.soy.soytree.ImportNode;\n@@ -44,7 +46,6 @@\n import com.google.template.soy.soytree.SoyNode.ParentSoyNode;\n import com.google.template.soy.soytree.TemplateNode;\n import com.google.template.soy.soytree.defn.ImportedVar;\n-import com.google.template.soy.soytree.defn.LocalVar;\n import com.google.template.soy.soytree.defn.TemplateHeaderVarDefn;\n import java.util.ArrayDeque;\n import java.util.Deque;\n@@ -52,7 +53,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Optional;\n import java.util.function.Predicate;\n import javax.annotation.Nullable;\n \n@@ -80,7 +80,7 @@\n   static final class LocalVariables {\n \n     private static final SoyErrorKind VARIABLE_ALREADY_DEFINED =\n-        SoyErrorKind.of(\"Variable ''{0}'' already defined{1}.\");\n+        SoyErrorKind.of(\"{0} ''{1}'' conflicts with symbol defined at {2}.\");\n \n     private ErrorReporter errorReporter;\n     private final Deque<Map<String, VarDefn>> currentScope = new ArrayDeque<>();\n@@ -123,15 +123,15 @@\n       // Search for the name to see if it is being redefined.\n       VarDefn preexisting = lookupWithReserved(refName);\n       if (preexisting != null) {\n-        Optional<SourceLocation> preexistingSourceLocation = forVarDefn(preexisting);\n-        SourceLocation defnSourceLocation =\n-            defn.nameLocation() == null ? definingNode.getSourceLocation() : defn.nameLocation();\n-        String location =\n-            preexistingSourceLocation.isPresent()\n-                ? \" at line \" + preexistingSourceLocation.get().getBeginLine()\n-                : \"\";\n-        if (errorReporter != null) {\n-          errorReporter.report(defnSourceLocation, VARIABLE_ALREADY_DEFINED, refName, location);\n+        if (errorReporter != null && !shouldSkipError(defn, preexisting)) {\n+          SourceLocation defnSourceLocation =\n+              defn.nameLocation() == null ? definingNode.getSourceLocation() : defn.nameLocation();\n+          errorReporter.report(\n+              defnSourceLocation,\n+              VARIABLE_ALREADY_DEFINED,\n+              englishName(defn),\n+              refName,\n+              preexisting.nameLocation().toLineColumnString());\n         }\n         return false;\n       }\n@@ -192,14 +192,17 @@\n           // TODO(b/175405629): As a step towards supporting templates, we verify that there are no\n           // collisions here.\n           for (ImportedVar var : imp.getIdentifiers()) {\n-            localVariables.reserve(var, node);\n+            localVariables.reserve(var, imp);\n           }\n         } else {\n           for (ImportedVar var : imp.getIdentifiers()) {\n-            localVariables.define(var, node);\n+            localVariables.define(var, imp);\n           }\n         }\n       }\n+      for (TemplateNode template : node.getTemplates()) {\n+        localVariables.reserve(template.asVarDefn(), template);\n+      }\n \n       super.visitSoyFileNode(node);\n       localVariables.exitScope();\n@@ -288,21 +291,29 @@\n     }\n   }\n \n-  private static Optional<SourceLocation> forVarDefn(VarDefn varDefn) {\n+  private static boolean shouldSkipError(VarDefn defn, VarDefn preexisting) {\n+    return defn.kind() == Kind.TEMPLATE\n+        && preexisting.kind() == Kind.TEMPLATE\n+        && isDeltemplateTemplateName(defn.name())\n+        && isDeltemplateTemplateName(preexisting.name());\n+  }\n\n+  private static String englishName(VarDefn varDefn) {\n     switch (varDefn.kind()) {\n       case PARAM:\n+        return \"Parameter\";\n       case STATE:\n+        return \"State parameter\";\n       case IMPORT_VAR:\n-        return Optional.of(varDefn.nameLocation());\n+        return \"Imported symbol\";\n       case LOCAL_VAR:\n-        return Optional.of(((LocalVar) varDefn).declaringNode().getSourceLocation());\n       case COMPREHENSION_VAR:\n-        return Optional.of(\n-            ((ListComprehensionNode.ComprehensionVarDefn) varDefn)\n-                .declaringNode()\n-                .getSourceLocation());\n+        return \"Local variable\";\n+      case TEMPLATE:\n+        return \"Template name\";\n       case UNDECLARED:\n-        return Optional.empty();\n+        return \"Symbol\";\n     }\n     throw new AssertionError(varDefn.kind());\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveTemplateImportsPass.java\n@@ -26,7 +26,6 @@\n import com.google.template.soy.base.SourceFilePath;\n import com.google.template.soy.base.internal.IdGenerator;\n import com.google.template.soy.error.ErrorReporter;\n-import com.google.template.soy.error.SoyErrorKind;\n import com.google.template.soy.shared.SoyGeneralOptions;\n import com.google.template.soy.soytree.ImportNode;\n import com.google.template.soy.soytree.ImportNode.ImportType;\n@@ -54,9 +53,6 @@\n })\n public final class ResolveTemplateImportsPass extends ImportsPass implements CompilerFileSetPass {\n \n-  private static final SoyErrorKind IMPORT_CONFLICTS_WITH_TEMPLATE =\n-      SoyErrorKind.of(\"Import conflicts with local template ''{0}''.\");\n-\n   private TemplateNameRegistry templateNameRegistry;\n   private final SoyGeneralOptions options;\n   private final ErrorReporter errorReporter;\n@@ -145,8 +141,7 @@\n         // Consider moving this to ImportsPass.\n         String partialTemplateName = symbolToTemplateName.get(symbol.name());\n         if (partialTemplateName != null) {\n-          errorReporter.report(\n-              symbol.nameLocation(), IMPORT_CONFLICTS_WITH_TEMPLATE, partialTemplateName);\n           symbol.setType(UnknownType.getInstance());\n           continue;\n         }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/FileSetTemplateRegistry.java\n@@ -122,7 +122,11 @@\n           // Case 1: Basic Template or Element node\n           TemplateMetadata prev =\n               basicTemplatesOrElementsMap.put(template.getTemplateName(), template);\n-          if (prev != null) {\n+          if (prev != null\n+              && !prev.getSourceLocation()\n+                  .getFileName()\n+                  .equals(template.getSourceLocation().getFileName())) {\n             errorReporter.report(\n                 template.getSourceLocation(),\n                 DUPLICATE_TEMPLATES,\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TemplateDelegateNodeBuilder.java\n@@ -129,6 +129,10 @@\n     return \"__deltemplate_\" + delPackageTemplateAndVariantStr;\n   }\n \n+  public static boolean isDeltemplateTemplateName(String templateName) {\n+    return templateName.startsWith(\"__deltemplate_\");\n+  }\n\n   @Override\n   public TemplateDelegateNode build() {\n     Preconditions.checkState(id != null && cmdText != null);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TemplateNode.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TemplateNode.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TemplateNode.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TemplateNode.java\n@@ -32,7 +32,9 @@\n import com.google.template.soy.basetree.CopyState;\n import com.google.template.soy.error.ErrorReporter;\n import com.google.template.soy.error.SoyErrorKind;\n+import com.google.template.soy.exprtree.AbstractVarDefn;\n import com.google.template.soy.exprtree.ExprRootNode;\n+import com.google.template.soy.exprtree.VarDefn;\n import com.google.template.soy.soytree.CommandTagAttribute.CommandTagAttributesHolder;\n import com.google.template.soy.soytree.SoyNode.ExprHolderNode;\n import com.google.template.soy.soytree.SoyNode.RenderUnitNode;\n@@ -40,6 +42,8 @@\n import com.google.template.soy.soytree.defn.TemplateHeaderVarDefn;\n import com.google.template.soy.soytree.defn.TemplateParam;\n import com.google.template.soy.soytree.defn.TemplateStateVar;\n+import com.google.template.soy.types.SoyType;\n+import com.google.template.soy.types.TemplateImportType;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n@@ -696,4 +700,28 @@\n         srcLocation.getFileName(),\n         srcLocation.getBeginLine());\n   }\n\n+  public VarDefn asVarDefn() {\n+    return new TemplateVarDefn(\n+        getLocalTemplateSymbol(),\n+        getTemplateNameLocation(),\n+        TemplateImportType.create(getTemplateName()));\n+  }\n\n+  private static class TemplateVarDefn extends AbstractVarDefn {\n+    public TemplateVarDefn(\n+        String name, @Nullable SourceLocation nameLocation, @Nullable SoyType type) {\n+      super(name, nameLocation, type);\n+    }\n\n+    @Override\n+    public Kind kind() {\n+      return Kind.TEMPLATE;\n+    }\n\n+    @Override\n+    public boolean isInjected() {\n+      return false;\n+    }\n+  }\n }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-91",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...n {PLACE}.}}');\nvar [msg_s = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'NUM_PEOPLE': opt_data.num_people, 'PLACE': opt_data.place, 'PERSON': opt_data.person, 'XXX': opt_data.num_people - 1});\noutput += msg_s];\n> but was:<...n {PLACE}.}}');\nvar [$tmp = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'NUM_PEOPLE': opt_data.num_people, 'PLACE': opt_data.place, 'PERSON': opt_data.person, 'XXX': opt_data.num_people - 1});\noutput += $tmp];\n>",
                "methodName": "testMsgWithPlural"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...is circle.}}');\nvar [msg_s = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'GENDER': opt_data.gender, 'PERSON': opt_data.person});\noutput += msg_s];\n> but was:<...is circle.}}');\nvar [$tmp = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'GENDER': opt_data.gender, 'PERSON': opt_data.person});\noutput += $tmp];\n>",
                "methodName": "testMsgWithSelect"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...Msg('Archive');\nvar [msg_s = goog.getMsgWithFallback(MSG_UNNAMED, MSG_UNNAMED$$1);\noutput += msg_s];\n> but was:<...Msg('Archive');\nvar [$tmp = goog.getMsgWithFallback(MSG_UNNAMED, MSG_UNNAMED$$1);\noutput += $tmp];\n>",
                "methodName": "testGoogMsgWithFallback"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...a.targetName});\nvar [msg_s = goog.getMsgWithFallback(MSG_UNNAMED, MSG_UNNAMED$$1);\nif (msg_s == MSG_UNNAMED) {\n  msg_s = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'USER_GENDER': opt_data.userGender, 'TARGET_GENDER': opt_data.targetGender, 'TARGET_NAME': opt_data.targetName});\n}\noutput += msg_s];\n> but was:<...a.targetName});\nvar [$tmp = goog.getMsgWithFallback(MSG_UNNAMED, MSG_UNNAMED$$1);\nif ($tmp == MSG_UNNAMED) {\n  $tmp = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'USER_GENDER': opt_data.userGender, 'TARGET_GENDER': opt_data.targetGender, 'TARGET_NAME': opt_data.targetName});\n}\noutput += $tmp];\n>",
                "methodName": "testPlrselMsgWithFallback"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<... circle.}}}}');\nvar [msg_s = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'GENDER': opt_data.gender, 'GENDER_2': opt_data.gender2, 'PERSON_1': opt_data.person1, 'PERSON_2': opt_data.person2});\noutput += msg_s];\n> but was:<... circle.}}}}');\nvar [$tmp = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'GENDER': opt_data.gender, 'GENDER_2': opt_data.gender2, 'PERSON_1': opt_data.person1, 'PERSON_2': opt_data.person2});\noutput += $tmp];\n>",
                "methodName": "testMsgWithNestedSelectPlural"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<... circle.}}}}');\nvar [msg_s = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'FORMAT': opt_data.format, 'GENDER_1': opt_data.user.gender, 'GENDER_2': opt_data.friend.gender, 'PERSON_1': opt_data.person1, 'PERSON_2': opt_data.person2});\noutput += msg_s];\n> but was:<... circle.}}}}');\nvar [$tmp = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'FORMAT': opt_data.format, 'GENDER_1': opt_data.user.gender, 'GENDER_2': opt_data.friend.gender, 'PERSON_1': opt_data.person1, 'PERSON_2': opt_data.person2});\noutput += $tmp];\n>",
                "methodName": "testMsgWithCollidingPlrsel"
            },
            {
                "className": "com.google.template.soy.jssrc.internal.GenJsCodeVisitorTest",
                "error": "org.junit.ComparisonFailure",
                "message": "expected:<...l &rsaquo;}}');\nvar [msg_s = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'NUM_1': opt_data.num, 'START_SPAN_1': '<span class=\"' + goog.getCssName('sharebox-id-email-number') + '\">', 'NUM_2': opt_data.num, 'END_SPAN': '</span>', 'START_SPAN_2': '<span class=\"' + goog.getCssName('sharebox-id-email-number') + '\">'});\noutput += msg_s];\n> but was:<...l &rsaquo;}}');\nvar [$tmp = new goog.i18n.MessageFormat(MSG_UNNAMED).formatIgnoringPound({'NUM_1': opt_data.num, 'START_SPAN_1': '<span class=\"' + goog.getCssName('sharebox-id-email-number') + '\">', 'NUM_2': opt_data.num, 'END_SPAN': '</span>', 'START_SPAN_2': '<span class=\"' + goog.getCssName('sharebox-id-email-number') + '\">'});\noutput += $tmp];\n>",
                "methodName": "testMsgWithPlrselHtml"
            }
        ],
        "metrics": {
            "chunks": 36,
            "classes": 7,
            "files": 7,
            "linesAdd": 32,
            "linesMod": 40,
            "linesRem": 19,
            "methods": 14,
            "sizeInLines": 72
        },
        "program": "RegressionBug-91",
        "project": "RegressionBug-91",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java\n@@ -16,8 +16,6 @@\n package com.google.template.soy.incrementaldomsrc;\n \n import static com.google.template.soy.incrementaldomsrc.IncrementalDomRuntime.INCREMENTAL_DOM_TEXT;\n-import static com.google.template.soy.jssrc.dsl.CodeChunk.WithValue.LITERAL_UNDEFINED;\n-import static com.google.template.soy.jssrc.dsl.CodeChunk.assign;\n import static com.google.template.soy.jssrc.dsl.CodeChunk.id;\n import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_STRING_UNESCAPE_ENTITIES;\n \n@@ -88,7 +86,7 @@\n   }\n \n   @Override\n-  public CodeChunk.WithValue generateMsgGroupVariable(MsgFallbackGroupNode node) {\n+  public String generateMsgGroupVariable(MsgFallbackGroupNode node) {\n     throw new IllegalStateException(\n         \"This class should only be used for via the new idom entry-point.\");\n   }\n@@ -139,11 +137,11 @@\n     // It'd be nice to move this codegen to a Soy template...\n \n     // The raw translated text, with placeholder placeholders.\n-    CodeChunk.WithValue translationVar = super.generateMsgGroupVariable(node);\n+    String translationVar = super.generateMsgGroupVariable(node);\n \n     // If there are no placeholders, we don't need anything special (but we still need to unescape).\n     if (placeholderNames.isEmpty()) {\n-      CodeChunk.WithValue unescape = GOOG_STRING_UNESCAPE_ENTITIES.call(translationVar);\n+      CodeChunk.WithValue unescape = GOOG_STRING_UNESCAPE_ENTITIES.call(id(translationVar));\n       jsCodeBuilder().append(INCREMENTAL_DOM_TEXT.call(unescape));\n       return;\n     }\n@@ -173,13 +171,7 @@\n     jsCodeBuilder().increaseIndent();\n     // Find the placeholder.\n     jsCodeBuilder()\n-        .append(\n-            assign(\n-                matchVar,\n-                id(regexVar)\n-                    .dotAccess(\"exec\")\n-                    .call(translationVar)\n-                    .or(LITERAL_UNDEFINED, translationContext.codeGenerator())));\n+        .appendLine(matchVar, \" = \", regexVar, \".exec(\", translationVar, \") || undefined;\");\n     // Replace null with undefined.  This is necessary to make substring() treat falsy as an omitted\n     // parameter, so that it goes until the end of the string.  Otherwise, the non-numeric parameter\n     // would be coerced to zero.\n@@ -190,7 +182,7 @@\n         id(matchVar).and(id(matchVar).dotAccess(\"index\"), translationContext.codeGenerator());\n     CodeChunk.WithValue unescape =\n         GOOG_STRING_UNESCAPE_ENTITIES.call(\n-            translationVar.dotAccess(\"substring\").call(id(lastIndexVar), endIndex));\n+            id(translationVar).dotAccess(\"substring\").call(id(lastIndexVar), endIndex));\n \n     jsCodeBuilder().append(INCREMENTAL_DOM_TEXT.call(unescape));\n     jsCodeBuilder().appendLine(lastIndexVar, \" = \", regexVar, \".lastIndex;\");\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java\n@@ -677,7 +677,7 @@\n \n   @Override\n   protected void visitMsgFallbackGroupNode(MsgFallbackGroupNode node) {\n-    CodeChunk.WithValue msgExpression;\n+    String msgExpression;\n     switch (node.getHtmlContext()) {\n       case HTML_PCDATA:\n         new AssistantForHtmlMsgs(\n@@ -708,11 +708,12 @@\n                     templateTranslationContext,\n                     errorReporter)\n                 .generateMsgGroupVariable(node);\n-        getJsCodeBuilder().addChunkToOutputVar(GOOG_STRING_UNESCAPE_ENTITIES.call(msgExpression));\n+        getJsCodeBuilder()\n+            .addChunkToOutputVar(GOOG_STRING_UNESCAPE_ENTITIES.call(id(msgExpression)));\n         break;\n       default:\n         msgExpression = getAssistantForMsgs().generateMsgGroupVariable(node);\n-        getJsCodeBuilder().addChunkToOutputVar(msgExpression);\n+        getJsCodeBuilder().addChunkToOutputVar(id(msgExpression));\n         break;\n     }\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n@@ -301,7 +301,6 @@\n     public static final WithValue LITERAL_TRUE = id(\"true\");\n     public static final WithValue LITERAL_FALSE = id(\"false\");\n     public static final WithValue LITERAL_NULL = id(\"null\");\n-    public static final WithValue LITERAL_UNDEFINED = id(\"undefined\");\n     public static final WithValue LITERAL_EMPTY_STRING = Leaf.create(\"''\");\n     public static final WithValue EMPTY_OBJECT_LITERAL = Leaf.create(\"{}\");\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java\n@@ -23,7 +23,6 @@\n import static com.google.template.soy.jssrc.dsl.CodeChunk.new_;\n import static com.google.template.soy.jssrc.dsl.CodeChunk.stringLiteral;\n import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_GET_MSG;\n-import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_GET_MSG_WITH_FALLBACK;\n import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_I18N_MESSAGE_FORMAT;\n \n import com.google.common.base.CaseFormat;\n@@ -34,7 +33,6 @@\n import com.google.template.soy.jssrc.SoyJsSrcOptions;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n import com.google.template.soy.jssrc.dsl.CodeChunkUtils;\n-import com.google.template.soy.jssrc.dsl.Declaration;\n import com.google.template.soy.msgs.internal.IcuSyntaxUtils;\n import com.google.template.soy.msgs.internal.MsgUtils;\n import com.google.template.soy.msgs.restricted.SoyMsgPart;\n@@ -167,76 +168,92 @@\n-  public CodeChunk.WithValue generateMsgGroupVariable(MsgFallbackGroupNode node) {\n-    return node.hasFallbackMsg()\n-        ? generateMsgGroupVariableWithFallbackMsgs(node)\n-        : generateSingleMsgVariable(node.getChild(0));\n+  public String generateMsgGroupVariable(MsgFallbackGroupNode node) {\n+    String tmpVarName = translationContext.nameGenerator().generateName(\"msg_s\");\n+    if (node.numChildren() == 1) {\n+      return generateSingleMsgVariable(node.getChild(0), tmpVarName);\n+    } else { // has fallbackmsg children\n+      generateMsgGroupVariable(node, tmpVarName);\n+      return tmpVarName;\n+    }\n   }\n \n-  private CodeChunk.WithValue generateSingleMsgVariable(MsgNode msgNode) {\n-    String varName = getGoogMsgVarName(msgNode);\n-    GoogMsgCodeGenInfo googMsgCodeGenInfo = genGoogGetMsgCallHelper(varName, msgNode);\n+  private String generateSingleMsgVariable(MsgNode msgNode, String tmpVarName) {\n+    String googMsgVarName = buildGoogMsgVarNameHelper(msgNode);\n+    GoogMsgCodeGenInfo googMsgCodeGenInfo = genGoogGetMsgCallHelper(googMsgVarName, msgNode);\n\n     if (!msgNode.isPlrselMsg()) {\n       // No postprocessing is needed. Simply use the original goog.getMsg var.\n-      return id(varName);\n+      return googMsgVarName;\n     }\n\n-    return translationContext\n-        .codeGenerator()\n-        .declare(googMsgCodeGenInfo.getMessageFormatCall())\n-        .ref();\n+    jsCodeBuilder().append(declare(tmpVarName, getMessageFormatCall(googMsgCodeGenInfo)));\n+    return tmpVarName;\n   }\n \n-  private CodeChunk.WithValue generateMsgGroupVariableWithFallbackMsgs(MsgFallbackGroupNode node) {\n-    List<GoogMsgCodeGenInfo> childGenInfos = new ArrayList<>(node.numChildren());\n+  private void generateMsgGroupVariable(MsgFallbackGroupNode node, String tmpVarName) {\n+    List<GoogMsgCodeGenInfo> childGoogMsgCodeGenInfos = new ArrayList<>(node.numChildren());\n \n     // Generate the goog.getMsg calls for all children.\n     for (MsgNode msgNode : node.getChildren()) {\n-      String googMsgVarName = getGoogMsgVarName(msgNode);\n-      childGenInfos.add(genGoogGetMsgCallHelper(googMsgVarName, msgNode));\n+      String googMsgVarName = buildGoogMsgVarNameHelper(msgNode);\n+      childGoogMsgCodeGenInfos.add(genGoogGetMsgCallHelper(googMsgVarName, msgNode));\n     }\n \n-    ImmutableList.Builder<CodeChunk.WithValue> args = ImmutableList.builder();\n-    for (GoogMsgCodeGenInfo childGoogMsgCodeGenInfo : childGenInfos) {\n-      args.add(CodeChunk.id(childGoogMsgCodeGenInfo.googMsgVarName));\n-    }\n     // Declare a temporary variable to hold the getMsgWithFallback() call so that we can apply any\n-    Declaration decl =\n-        translationContext.codeGenerator().declare(GOOG_GET_MSG_WITH_FALLBACK.call(args.build()));\n\n-    ImmutableList.Builder<CodeChunk> initialStatements = ImmutableList.builder();\n+    jsCodeBuilder().appendLineStart(\"var \", tmpVarName, \" = goog.getMsgWithFallback(\");\n+    boolean isFirst = true;\n+    for (GoogMsgCodeGenInfo childGoogMsgCodeGenInfo : childGoogMsgCodeGenInfos) {\n+      if (isFirst) {\n+        isFirst = false;\n+      } else {\n+        jsCodeBuilder().append(\", \");\n+      }\n+      jsCodeBuilder().append(childGoogMsgCodeGenInfo.googMsgVarName);\n+    }\n+    jsCodeBuilder().appendLineEnd(\");\");\n \n     // Generate the goog.i18n.MessageFormat calls for child plural/select messages (if any), each\n     // wrapped in an if-block that will only execute if that child is the chosen message.\n-    for (GoogMsgCodeGenInfo child : childGenInfos) {\n-      if (child.isPlrselMsg) {\n-        initialStatements.add(\n-            ifStatement(\n-                    decl.ref().doubleEquals(id(child.googMsgVarName)),\n-                    decl.ref().assign(child.getMessageFormatCall()))\n-                .build());\n+    for (GoogMsgCodeGenInfo childGoogMsgCodeGenInfo : childGoogMsgCodeGenInfos) {\n+      if (childGoogMsgCodeGenInfo.isPlrselMsg) {\n+        CodeChunk.WithValue tmpVar = id(tmpVarName);\n+        jsCodeBuilder()\n+            .append(\n+                ifStatement(\n+                        tmpVar.doubleEquals(id(childGoogMsgCodeGenInfo.googMsgVarName)),\n+                        tmpVar.assign(getMessageFormatCall(childGoogMsgCodeGenInfo)))\n+                    .build());\n       }\n     }\n\n-    return decl.ref().withInitialStatements(initialStatements.build());\n   }\n \n-  private String getGoogMsgVarName(MsgNode msgNode) {\n+  private String buildGoogMsgVarNameHelper(MsgNode msgNode) {\n     String desiredName =\n         jsSrcOptions.googMsgsAreExternal()\n             ? \"MSG_EXTERNAL_\" + MsgUtils.computeMsgIdForDualFormat(msgNode)\n@@ -343,6 +360,19 @@\n     return msgStrSb.toString();\n   }\n \n+  private static CodeChunk.WithValue getMessageFormatCall(GoogMsgCodeGenInfo codeGenInfo) {\n+    MapLiteralBuilder builder = codeGenInfo.pluralsAndSelects;\n+    builder.putAll(codeGenInfo.placeholders);\n+    return new_(GOOG_I18N_MESSAGE_FORMAT)\n+        .call(id(codeGenInfo.googMsgVarName))\n+        .dotAccess(\"formatIgnoringPound\")\n+        .call(builder.build());\n+  }\n\n   /** Stores the data required for generating {@code goog.getMsg()} calls. */\n   private static final class GoogMsgCodeGenInfo {\n \n@@ -362,18 +392,6 @@\n       this.googMsgVarName = googMsgVarName;\n       this.isPlrselMsg = isPlrselMsg;\n     }\n\n-    CodeChunk.WithValue getMessageFormatCall() {\n-      pluralsAndSelects.putAll(placeholders);\n-      return new_(GOOG_I18N_MESSAGE_FORMAT)\n-          .call(id(googMsgVarName))\n-          .dotAccess(\"formatIgnoringPound\")\n-          .call(pluralsAndSelects.build());\n-    }\n   }\n \n   /**\n@@ -513,7 +531,8 @@\n \n   /** Returns a code chunk for the given placeholder node. */\n   protected CodeChunk.WithValue genGoogMsgPlaceholder(MsgPlaceholderNode msgPhNode) {\n-    List<CodeChunk.WithValue> contentChunks = new ArrayList<>(msgPhNode.numChildren());\n+    List<CodeChunk.WithValue> contentChunks = new ArrayList<>();\n \n     for (StandaloneNode contentNode : msgPhNode.getChildren()) {\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java\n@@ -959,9 +959,9 @@\n     // Optimization: {msg} nodes emit statements and result in a JsExpr with a single variable.  Use\n     // that variable (typically the MSG_* from getMsg) as-is instead of wrapping a new var around it\n     if (node.getChildren().size() == 1 && node.getChild(0) instanceof MsgFallbackGroupNode) {\n-      CodeChunk.WithValue msgVar =\n+      String msgVar =\n           getAssistantForMsgs().generateMsgGroupVariable((MsgFallbackGroupNode) node.getChild(0));\n-      templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(), msgVar);\n+      templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(), id(msgVar));\n       return;\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java\n@@ -23,6 +23,7 @@\n import com.google.common.base.Strings;\n import com.google.common.collect.ImmutableList;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n+import com.google.template.soy.jssrc.dsl.CodeChunk.RequiresCollector;\n import com.google.template.soy.jssrc.dsl.CodeChunkUtils;\n import com.google.template.soy.jssrc.dsl.GoogRequire;\n import java.util.ArrayDeque;\n@@ -108,7 +109,7 @@\n    * <p>TODO(user): this is always an {@link CodeChunk#id}. Consider exposing a subclass of\n    * CodeChunk so we can enforce this invariant at compile time.\n    */\n-  @Nullable private CodeChunk.WithValue currOutputVar;\n+  @Nullable protected CodeChunk.WithValue currOutputVar;\n \n   /** Whether the current output variable is initialized. */\n   private boolean currOutputVarIsInited;\n@@ -290,7 +291,7 @@\n    * @param codeFragments The code string(s) to append.\n    * @return This CodeBuilder (for stringing together operations).\n    */\n-  JsCodeBuilder appendLineStart(String... codeFragments) {\n+  public JsCodeBuilder appendLineStart(String... codeFragments) {\n     code.append(indent);\n     append(codeFragments);\n     return this;\n@@ -302,18 +303,22 @@\n    * @param codeFragments The code string(s) to append.\n    * @return This CodeBuilder (for stringing together operations).\n    */\n-  JsCodeBuilder appendLineEnd(String... codeFragments) {\n+  public JsCodeBuilder appendLineEnd(String... codeFragments) {\n     append(codeFragments);\n     code.append(\"\\n\");\n     return this;\n   }\n \n+  public RequiresCollector getRequiresCollector() {\n+    return requireCollector;\n+  }\n\n   /**\n    * Adds a {@code goog.require}\n    *\n    * @param require The namespace being required\n    */\n-  protected void addGoogRequire(GoogRequire require) {\n+  public void addGoogRequire(GoogRequire require) {\n     GoogRequire oldRequire = googRequires.put(require.symbol(), require);\n     if (oldRequire != null && !oldRequire.equals(require)) {\n       throw new IllegalArgumentException(\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java\n@@ -57,9 +57,6 @@\n \n   public static final CodeChunk.WithValue GOOG_GET_MSG = dottedIdNoRequire(\"goog.getMsg\");\n \n-  public static final CodeChunk.WithValue GOOG_GET_MSG_WITH_FALLBACK =\n-      dottedIdNoRequire(\"goog.getMsgWithFallback\");\n\n   public static final CodeChunk.WithValue GOOG_IS_ARRAY = dottedIdNoRequire(\"goog.isArray\");\n \n   public static final CodeChunk.WithValue GOOG_IS_BOOLEAN = dottedIdNoRequire(\"goog.isBoolean\");",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/incrementaldomsrc/AssistantForHtmlMsgs.java\t2024-09-08 01:36:29.273914763 +1000\n@@ -16,6 +16,8 @@\n package com.google.template.soy.incrementaldomsrc;\n \n import static com.google.template.soy.incrementaldomsrc.IncrementalDomRuntime.INCREMENTAL_DOM_TEXT;\n+import static com.google.template.soy.jssrc.dsl.CodeChunk.WithValue.LITERAL_UNDEFINED;\n+import static com.google.template.soy.jssrc.dsl.CodeChunk.assign;\n import static com.google.template.soy.jssrc.dsl.CodeChunk.id;\n import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_STRING_UNESCAPE_ENTITIES;\n \n@@ -86,7 +88,7 @@\n   }\n \n   @Override\n-  public String generateMsgGroupVariable(MsgFallbackGroupNode node) {\n+  public CodeChunk.WithValue generateMsgGroupVariable(MsgFallbackGroupNode node) {\n     throw new IllegalStateException(\n         \"This class should only be used for via the new idom entry-point.\");\n   }\n@@ -137,11 +139,11 @@\n     // It'd be nice to move this codegen to a Soy template...\n \n     // The raw translated text, with placeholder placeholders.\n-    String translationVar = super.generateMsgGroupVariable(node);\n+    CodeChunk.WithValue translationVar = super.generateMsgGroupVariable(node);\n \n     // If there are no placeholders, we don't need anything special (but we still need to unescape).\n     if (placeholderNames.isEmpty()) {\n-      CodeChunk.WithValue unescape = GOOG_STRING_UNESCAPE_ENTITIES.call(id(translationVar));\n+      CodeChunk.WithValue unescape = GOOG_STRING_UNESCAPE_ENTITIES.call(translationVar);\n       jsCodeBuilder().append(INCREMENTAL_DOM_TEXT.call(unescape));\n       return;\n     }\n@@ -170,8 +172,14 @@\n     jsCodeBuilder().appendLine(\"do {\");\n     jsCodeBuilder().increaseIndent();\n     // Find the placeholder.\n-    jsCodeBuilder().appendLine(matchVar, \" = \", regexVar,\n-        \".exec(\", translationVar, \") || undefined;\");\n+    jsCodeBuilder()\n+        .append(\n+            assign(\n+                matchVar,\n+                id(regexVar)\n+                    .dotAccess(\"exec\")\n+                    .call(translationVar)\n+                    .or(LITERAL_UNDEFINED, translationContext.codeGenerator())));\n     // Replace null with undefined.  This is necessary to make substring() treat falsy as an omitted\n     // parameter, so that it goes until the end of the string.  Otherwise, the non-numeric parameter\n     // would be coerced to zero.\n@@ -182,7 +190,7 @@\n         id(matchVar).and(id(matchVar).dotAccess(\"index\"), translationContext.codeGenerator());\n     CodeChunk.WithValue unescape =\n         GOOG_STRING_UNESCAPE_ENTITIES.call(\n-            id(translationVar).dotAccess(\"substring\").call(id(lastIndexVar), endIndex));\n+            translationVar.dotAccess(\"substring\").call(id(lastIndexVar), endIndex));\n \n     jsCodeBuilder().append(INCREMENTAL_DOM_TEXT.call(unescape));\n     jsCodeBuilder().appendLine(lastIndexVar, \" = \", regexVar, \".lastIndex;\");\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/incrementaldomsrc/GenIncrementalDomCodeVisitor.java\t2024-09-08 01:36:29.273914763 +1000\n@@ -677,7 +677,7 @@\n \n   @Override\n   protected void visitMsgFallbackGroupNode(MsgFallbackGroupNode node) {\n-    String msgExpression;\n+    CodeChunk.WithValue msgExpression;\n     switch (node.getHtmlContext()) {\n       case HTML_PCDATA:\n         new AssistantForHtmlMsgs(\n@@ -708,12 +708,11 @@\n                     templateTranslationContext,\n                     errorReporter)\n                 .generateMsgGroupVariable(node);\n-        getJsCodeBuilder()\n-            .addChunkToOutputVar(GOOG_STRING_UNESCAPE_ENTITIES.call(id(msgExpression)));\n+        getJsCodeBuilder().addChunkToOutputVar(GOOG_STRING_UNESCAPE_ENTITIES.call(msgExpression));\n         break;\n       default:\n         msgExpression = getAssistantForMsgs().generateMsgGroupVariable(node);\n-        getJsCodeBuilder().addChunkToOutputVar(id(msgExpression));\n+        getJsCodeBuilder().addChunkToOutputVar(msgExpression);\n         break;\n     }\n   }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/dsl/CodeChunk.java\t2024-09-08 01:36:29.273914763 +1000\n@@ -301,6 +301,7 @@\n     public static final WithValue LITERAL_TRUE = id(\"true\");\n     public static final WithValue LITERAL_FALSE = id(\"false\");\n     public static final WithValue LITERAL_NULL = id(\"null\");\n+    public static final WithValue LITERAL_UNDEFINED = id(\"undefined\");\n     public static final WithValue LITERAL_EMPTY_STRING = Leaf.create(\"''\");\n     public static final WithValue EMPTY_OBJECT_LITERAL = Leaf.create(\"{}\");\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitorAssistantForMsgs.java\t2024-09-08 01:36:29.277914791 +1000\n@@ -23,6 +23,7 @@\n import static com.google.template.soy.jssrc.dsl.CodeChunk.new_;\n import static com.google.template.soy.jssrc.dsl.CodeChunk.stringLiteral;\n import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_GET_MSG;\n+import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_GET_MSG_WITH_FALLBACK;\n import static com.google.template.soy.jssrc.internal.JsRuntime.GOOG_I18N_MESSAGE_FORMAT;\n \n import com.google.common.base.CaseFormat;\n@@ -33,6 +34,7 @@\n import com.google.template.soy.jssrc.SoyJsSrcOptions;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n import com.google.template.soy.jssrc.dsl.CodeChunkUtils;\n+import com.google.template.soy.jssrc.dsl.Declaration;\n import com.google.template.soy.msgs.internal.IcuSyntaxUtils;\n import com.google.template.soy.msgs.internal.MsgUtils;\n import com.google.template.soy.msgs.restricted.SoyMsgPart;\n@@ -166,90 +167,76 @@\n-  public String generateMsgGroupVariable(MsgFallbackGroupNode node) {\n-    String tmpVarName = translationContext.nameGenerator().generateName(\"msg_s\");\n-    if (node.numChildren() == 1) {\n-      return generateSingleMsgVariable(node.getChild(0), tmpVarName);\n-    } else {  // has fallbackmsg children\n-      generateMsgGroupVariable(node, tmpVarName);\n-      return tmpVarName;\n-    }\n+  public CodeChunk.WithValue generateMsgGroupVariable(MsgFallbackGroupNode node) {\n+    return node.hasFallbackMsg()\n+        ? generateMsgGroupVariableWithFallbackMsgs(node)\n+        : generateSingleMsgVariable(node.getChild(0));\n   }\n \n-  private String generateSingleMsgVariable(MsgNode msgNode, String tmpVarName) {\n-    String googMsgVarName = buildGoogMsgVarNameHelper(msgNode);\n-    GoogMsgCodeGenInfo googMsgCodeGenInfo = genGoogGetMsgCallHelper(googMsgVarName, msgNode);\n+  private CodeChunk.WithValue generateSingleMsgVariable(MsgNode msgNode) {\n+    String varName = getGoogMsgVarName(msgNode);\n+    GoogMsgCodeGenInfo googMsgCodeGenInfo = genGoogGetMsgCallHelper(varName, msgNode);\n     if (!msgNode.isPlrselMsg()) {\n       // No postprocessing is needed. Simply use the original goog.getMsg var.\n-      return googMsgVarName;\n+      return id(varName);\n     }\n-    jsCodeBuilder().append(declare(tmpVarName, getMessageFormatCall(googMsgCodeGenInfo)));\n-    return tmpVarName;\n+    return translationContext\n+        .codeGenerator()\n+        .declare(googMsgCodeGenInfo.getMessageFormatCall())\n+        .ref();\n   }\n\n-  private void generateMsgGroupVariable(MsgFallbackGroupNode node, String tmpVarName) {\n-    List<GoogMsgCodeGenInfo> childGoogMsgCodeGenInfos = new ArrayList<>(node.numChildren());\n+  private CodeChunk.WithValue generateMsgGroupVariableWithFallbackMsgs(MsgFallbackGroupNode node) {\n+    List<GoogMsgCodeGenInfo> childGenInfos = new ArrayList<>(node.numChildren());\n \n     // Generate the goog.getMsg calls for all children.\n     for (MsgNode msgNode : node.getChildren()) {\n-      String googMsgVarName = buildGoogMsgVarNameHelper(msgNode);\n-      childGoogMsgCodeGenInfos.add(genGoogGetMsgCallHelper(googMsgVarName, msgNode));\n+      String googMsgVarName = getGoogMsgVarName(msgNode);\n+      childGenInfos.add(genGoogGetMsgCallHelper(googMsgVarName, msgNode));\n     }\n \n-    jsCodeBuilder().appendLineStart(\"var \", tmpVarName, \" = goog.getMsgWithFallback(\");\n-    boolean isFirst = true;\n-    for (GoogMsgCodeGenInfo childGoogMsgCodeGenInfo : childGoogMsgCodeGenInfos) {\n-      if (isFirst) {\n-        isFirst = false;\n-      } else {\n-        jsCodeBuilder().append(\", \");\n-      }\n-      jsCodeBuilder().append(childGoogMsgCodeGenInfo.googMsgVarName);\n+    ImmutableList.Builder<CodeChunk.WithValue> args = ImmutableList.builder();\n+    for (GoogMsgCodeGenInfo childGoogMsgCodeGenInfo : childGenInfos) {\n+      args.add(CodeChunk.id(childGoogMsgCodeGenInfo.googMsgVarName));\n     }\n-    jsCodeBuilder().appendLineEnd(\");\");\n+    Declaration decl =\n+        translationContext.codeGenerator().declare(GOOG_GET_MSG_WITH_FALLBACK.call(args.build()));\n+\n+    ImmutableList.Builder<CodeChunk> initialStatements = ImmutableList.builder();\n \n     // Generate the goog.i18n.MessageFormat calls for child plural/select messages (if any), each\n     // wrapped in an if-block that will only execute if that child is the chosen message.\n-    for (GoogMsgCodeGenInfo childGoogMsgCodeGenInfo : childGoogMsgCodeGenInfos) {\n-      if (childGoogMsgCodeGenInfo.isPlrselMsg) {\n-        CodeChunk.WithValue tmpVar = id(tmpVarName);\n-        jsCodeBuilder()\n-            .append(\n-                ifStatement(\n-                        tmpVar.doubleEquals(id(childGoogMsgCodeGenInfo.googMsgVarName)),\n-                        tmpVar.assign(getMessageFormatCall(childGoogMsgCodeGenInfo)))\n-                    .build());\n+    for (GoogMsgCodeGenInfo child : childGenInfos) {\n+      if (child.isPlrselMsg) {\n+        initialStatements.add(\n+            ifStatement(\n+                    decl.ref().doubleEquals(id(child.googMsgVarName)),\n+                    decl.ref().assign(child.getMessageFormatCall()))\n+                .build());\n       }\n     }\n+    return decl.ref().withInitialStatements(initialStatements.build());\n   }\n \n-  private String buildGoogMsgVarNameHelper(MsgNode msgNode) {\n+  private String getGoogMsgVarName(MsgNode msgNode) {\n     String desiredName =\n         jsSrcOptions.googMsgsAreExternal()\n             ? \"MSG_EXTERNAL_\" + MsgUtils.computeMsgIdForDualFormat(msgNode)\n@@ -356,19 +343,6 @@\n     return msgStrSb.toString();\n   }\n \n-  private static CodeChunk.WithValue getMessageFormatCall(GoogMsgCodeGenInfo codeGenInfo) {\n-    MapLiteralBuilder builder = codeGenInfo.pluralsAndSelects;\n-    builder.putAll(codeGenInfo.placeholders);\n-    return new_(GOOG_I18N_MESSAGE_FORMAT)\n-        .call(id(codeGenInfo.googMsgVarName))\n-        .dotAccess(\"formatIgnoringPound\")\n-        .call(builder.build());\n-  }\n\n   /** Stores the data required for generating {@code goog.getMsg()} calls. */\n   private static final class GoogMsgCodeGenInfo {\n \n@@ -388,6 +362,18 @@\n       this.googMsgVarName = googMsgVarName;\n       this.isPlrselMsg = isPlrselMsg;\n     }\n\n+    CodeChunk.WithValue getMessageFormatCall() {\n+      pluralsAndSelects.putAll(placeholders);\n+      return new_(GOOG_I18N_MESSAGE_FORMAT)\n+          .call(id(googMsgVarName))\n+          .dotAccess(\"formatIgnoringPound\")\n+          .call(pluralsAndSelects.build());\n+    }\n   }\n \n   /**\n@@ -527,8 +513,7 @@\n \n   /** Returns a code chunk for the given placeholder node. */\n   protected CodeChunk.WithValue genGoogMsgPlaceholder(MsgPlaceholderNode msgPhNode) {\n\n-    List<CodeChunk.WithValue> contentChunks = new ArrayList<>();\n+    List<CodeChunk.WithValue> contentChunks = new ArrayList<>(msgPhNode.numChildren());\n \n     for (StandaloneNode contentNode : msgPhNode.getChildren()) {\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/GenJsCodeVisitor.java\t2024-09-08 01:36:29.273914763 +1000\n@@ -959,13 +959,9 @@\n     // Optimization: {msg} nodes emit statements and result in a JsExpr with a single variable.  Use\n     // that variable (typically the MSG_* from getMsg) as-is instead of wrapping a new var around it\n     if (node.getChildren().size() == 1 && node.getChild(0) instanceof MsgFallbackGroupNode) {\n-      String msgVar = getAssistantForMsgs()\n-          .generateMsgGroupVariable((MsgFallbackGroupNode) node.getChild(0));\n-      templateTranslationContext\n-          .soyToJsVariableMappings()\n-          .put(\n-              node.getVarName(),\n-              id(msgVar));\n+      CodeChunk.WithValue msgVar =\n+          getAssistantForMsgs().generateMsgGroupVariable((MsgFallbackGroupNode) node.getChild(0));\n+      templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(), msgVar);\n       return;\n     }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsCodeBuilder.java\t2024-09-08 01:36:29.277914791 +1000\n@@ -23,7 +23,6 @@\n import com.google.common.base.Strings;\n import com.google.common.collect.ImmutableList;\n import com.google.template.soy.jssrc.dsl.CodeChunk;\n-import com.google.template.soy.jssrc.dsl.CodeChunk.RequiresCollector;\n import com.google.template.soy.jssrc.dsl.CodeChunkUtils;\n import com.google.template.soy.jssrc.dsl.GoogRequire;\n import java.util.ArrayDeque;\n@@ -109,7 +108,7 @@\n    * <p>TODO(user): this is always an {@link CodeChunk#id}. Consider exposing a subclass of\n    * CodeChunk so we can enforce this invariant at compile time.\n    */\n-  @Nullable protected CodeChunk.WithValue currOutputVar;\n+  @Nullable private CodeChunk.WithValue currOutputVar;\n \n   /** Whether the current output variable is initialized. */\n   private boolean currOutputVarIsInited;\n@@ -287,10 +286,11 @@\n \n   /**\n    * Appends the current indent, then the given strings.\n    *\n    * @param codeFragments The code string(s) to append.\n    * @return This CodeBuilder (for stringing together operations).\n    */\n-  public JsCodeBuilder appendLineStart(String... codeFragments) {\n+  JsCodeBuilder appendLineStart(String... codeFragments) {\n     code.append(indent);\n     append(codeFragments);\n     return this;\n@@ -298,25 +298,22 @@\n \n   /**\n    * Appends the given strings, then a newline.\n    *\n    * @param codeFragments The code string(s) to append.\n    * @return This CodeBuilder (for stringing together operations).\n    */\n-  public JsCodeBuilder appendLineEnd(String... codeFragments) {\n+  JsCodeBuilder appendLineEnd(String... codeFragments) {\n     append(codeFragments);\n     code.append(\"\\n\");\n     return this;\n   }\n \n-  public RequiresCollector getRequiresCollector() {\n-    return requireCollector;\n-  }\n\n   /**\n    * Adds a {@code goog.require}\n    *\n    * @param require The namespace being required\n    */\n-  public void addGoogRequire(GoogRequire require) {\n+  protected void addGoogRequire(GoogRequire require) {\n     GoogRequire oldRequire = googRequires.put(require.symbol(), require);\n     if (oldRequire != null && !oldRequire.equals(require)) {\n       throw new IllegalArgumentException(\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java\t2024-09-08 01:36:29.325915127 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsRuntime.java\t2024-09-08 01:36:29.277914791 +1000\n@@ -57,6 +57,9 @@\n \n   public static final CodeChunk.WithValue GOOG_GET_MSG = dottedIdNoRequire(\"goog.getMsg\");\n \n+  public static final CodeChunk.WithValue GOOG_GET_MSG_WITH_FALLBACK =\n+      dottedIdNoRequire(\"goog.getMsgWithFallback\");\n\n   public static final CodeChunk.WithValue GOOG_IS_ARRAY = dottedIdNoRequire(\"goog.isArray\");\n \n   public static final CodeChunk.WithValue GOOG_IS_BOOLEAN = dottedIdNoRequire(\"goog.isBoolean\");",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-92",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.base.internal.SanitizedContentKindTest",
                "error": "com.google.common.truth.AssertionErrorWithFacts",
                "message": "value of      : attributeValues()\nunexpected (1): html_element\n---\nexpected      : [attributes, css, html, js, text, trusted_resource_uri, uri]\nbut was       : [attributes, css, html, html_element, js, text, trusted_resource_uri, uri]",
                "methodName": "testGetAttributeValues"
            },
            {
                "className": "com.google.template.soy.base.internal.TemplateContentKindTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of: getSanitizedContentKind()\nexpected: HTML\nbut was : HTML_ELEMENT",
                "methodName": "testForAttributeValue_element"
            }
        ],
        "metrics": {
            "chunks": 48,
            "classes": 23,
            "files": 23,
            "linesAdd": 8,
            "linesMod": 11,
            "linesRem": 78,
            "methods": 35,
            "sizeInLines": 19
        },
        "program": "RegressionBug-92",
        "project": "RegressionBug-92",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n@@ -39,8 +39,6 @@\n    * domain.\n    */\n   HTML,\n-  HTML_ELEMENT,\n \n   /**\n    * Executable Javascript code or expression, safe for insertion in a script-tag or event handler*/\n@@ -93,11 +91,6 @@\n     return attributeValue;\n   }\n \n-  public boolean isAssignableFrom(SanitizedContentKind sanitizedType) {\n-    return this == sanitizedType || (this == HTML && sanitizedType == HTML_ELEMENT);\n-  }\n\n   /** Returns the kind for the given attribute value. Or {@code null} if it is invalid. */\n   public static Optional<SanitizedContentKind> fromAttributeValue(String attributeValue) {\n     checkNotNull(attributeValue);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/TemplateContentKind.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n@@ -42,11 +42,11 @@\n    */\n   public static Optional<TemplateContentKind> fromAttributeValue(String attrValue) {\n     checkNotNull(attrValue);\n-    if (attrValue.equals(\"html<?>\")) {\n-      return Optional.of(ElementContentKind.ELEMENT);\n-    }\n     if (BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.containsKey(attrValue)) {\n       return Optional.of(BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.get(attrValue));\n+    } else if (attrValue.equals(\"html<?>\")) {\n+      return Optional.of(ElementContentKind.ELEMENT);\n     }\n     return Optional.empty();\n   }\n@@ -113,7 +113,7 @@\n \n     @Override\n     public SanitizedContentKind getSanitizedContentKind() {\n-      return SanitizedContentKind.HTML_ELEMENT;\n+      return SanitizedContentKind.HTML;\n     }\n   }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n@@ -45,7 +45,6 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_CTOR_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"goog.soy.data.SanitizedHtml\")\n-          .put(SanitizedContentKind.HTML_ELEMENT, \"goog.soy.data.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"goog.soy.data.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"goog.soy.data.SanitizedJs\")\n           .put(SanitizedContentKind.URI, \"goog.soy.data.SanitizedUri\")\n@@ -60,7 +59,6 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_ORDAINER_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n-          .put(SanitizedContentKind.HTML_ELEMENT, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"soydata.VERY_UNSAFE.ordainSanitizedJs\")\n           .put(SanitizedContentKind.URI, \"soydata.VERY_UNSAFE.ordainSanitizedUri\")\n@@ -83,9 +81,6 @@\n                   SanitizedContentKind.HTML,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n               .put(\n-                  SanitizedContentKind.HTML_ELEMENT,\n-                  \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n-              .put(\n                   SanitizedContentKind.ATTRIBUTES,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedAttributesForInternalBlocks\")\n               .put(\n@@ -121,7 +116,6 @@\n   /** The Python sanitized classes. */\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_PY_SANITIZED_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n-          .put(SanitizedContentKind.HTML_ELEMENT, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.HTML, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"sanitize.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"sanitize.SanitizedJs\")\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/SanitizedContent.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/SanitizedContent.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/SanitizedContent.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/SanitizedContent.java\n@@ -93,9 +93,6 @@\n      */\n     HTML,\n \n-    HTML_ELEMENT,\n\n     /**\n      * Executable Javascript code or expression, safe for insertion in a script-tag or event handler\n      * context, known to be free of any attacker-controlled scripts. This can either be*/\n@@ -155,7 +152,6 @@\n         case TRUSTED_RESOURCE_URI:\n           return Dir.LTR;\n         case HTML:\n-        case HTML_ELEMENT:\n         case TEXT:\n           return null;\n       }\n@@ -254,7 +250,7 @@\n    */\n   public SafeHtml toSafeHtml() {\n     Preconditions.checkState(\n-        getContentKind() == ContentKind.HTML || getContentKind() == ContentKind.HTML_ELEMENT,\n+        getContentKind() == ContentKind.HTML,\n         \"toSafeHtml() only valid for SanitizedContent of kind HTML, is: %s\",\n         getContentKind());\n     return UncheckedConversions.safeHtmlFromStringKnownToSatisfyTypeContract(getContent());\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n@@ -79,7 +79,6 @@\n       case STRING:\n         types = ImmutableList.of(SimpleJavaType.STRING);\n         break;\n-      case ELEMENT:\n       case HTML:\n         types = ImmutableList.of(SimpleJavaType.HTML);\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n@@ -99,7 +99,6 @@\n       return super.getTemplateFactory(name);\n     }\n     switch (contentKind) {\n-      case HTML_ELEMENT:\n       case HTML:\n         return new Factory<>(\n             contentKind, stubFactory.createHtmlTemplate(name), SafeHtml::getSafeHtmlString);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n@@ -72,7 +72,6 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n-      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\n@@ -148,7 +147,6 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n-      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsType.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsType.java\n@@ -283,7 +283,6 @@\n         }\n         // fall through\n       case HTML:\n-      case ELEMENT:\n         if (isIncrementalDom) {\n           // idom has a different strategy for handling these\n           return IDOM_HTML;\n@@ -487,7 +486,6 @@\n         return STRING_TYPE;\n       case ATTRIBUTES:\n       case CSS:\n-      case HTML_ELEMENT:\n       case HTML:\n       case JS:\n       case URI:\n@@ -643,7 +641,6 @@\n       case CSS:\n         builder.addType(\"!goog.html.SafeStyle\");\n         break;\n-      case HTML_ELEMENT:\n       case HTML:\n         builder.addType(\"!goog.html.SafeHtml\");\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n@@ -930,7 +930,6 @@\n     switch (contentKind) {\n       case CSS:\n         return state() == HtmlContext.CSS && elType() == ElementType.NONE;\n-      case HTML_ELEMENT:\n       case HTML:\n         return state() == HtmlContext.HTML_PCDATA && elType() == ElementType.NONE;\n       case ATTRIBUTES:\n@@ -1745,7 +1744,6 @@\n         case CSS:\n           withState(HtmlContext.CSS);\n           break;\n-        case HTML_ELEMENT:\n         case HTML:\n           withState(HtmlContext.HTML_PCDATA);\n           break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n@@ -111,8 +111,6 @@\n           }\n           node.arguments().get(0).accept(this);\n           break;\n-        case ELEMENT:\n-          break;\n         default:\n           throw new AssertionError(\"unexpected generic type: \" + node.getResolvedType().getKind());\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n@@ -422,8 +422,7 @@\n       if (callerTemplate.isStrictHtml()\n           && caller.getIsPcData()\n           && callee != null\n-          && (callee.getContentKind() == SanitizedContentKind.HTML\n-              || callee.getContentKind() == SanitizedContentKind.HTML_ELEMENT)\n+          && callee.getContentKind() == SanitizedContentKind.HTML\n           && !callee.isStrictHtml()) {\n         errorReporter.report(caller.getSourceLocation(), STRICT_HTML);\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/KeyCommandPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/KeyCommandPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/KeyCommandPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/KeyCommandPass.java\n@@ -145,7 +145,6 @@\n           break;\n         case BOOL:\n         case HTML:\n-        case ELEMENT:\n         case ATTRIBUTES:\n         case JS:\n         case CSS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n@@ -56,7 +56,6 @@\n import com.google.template.soy.types.SoyTypeRegistry;\n import com.google.template.soy.types.SoyTypeVisitor;\n import com.google.template.soy.types.SoyTypes;\n-import com.google.template.soy.types.StringType;\n import com.google.template.soy.types.TemplateBindingUtil;\n import com.google.template.soy.types.TemplateType;\n import com.google.template.soy.types.UnionType;\n@@ -204,15 +203,7 @@\n     Set<FunctionNode> correctlyPlaced = new HashSet<>();\n     for (HtmlTagNode tagNode :\n         SoyTreeUtils.getAllMatchingNodesOfType(\n-            file,\n-            HtmlTagNode.class,\n-            (tag) ->\n-                !tag.getTagName().isStatic()\n-                    && tag.getTagName()\n-                        .getDynamicTagName()\n-                        .getExpr()\n-                        .getType()\n-                        .isAssignableFrom(StringType.getInstance()))) {\n+            file, HtmlTagNode.class, (tag) -> !tag.getTagName().isStatic())) {\n       handleDynamicTag(tagNode, correctlyPlaced);\n     }\n     // No other uses of legacyDynamicTag are allowed.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n@@ -1796,7 +1796,6 @@\n         case CSS:\n         case JS:\n         case ATTRIBUTES:\n-        case ELEMENT:\n         case HTML:\n         case URI:\n           if (fieldName.equals(\"length\")) {\n@@ -1916,7 +1915,6 @@\n         case INT:\n         case FLOAT:\n         case STRING:\n-        case ELEMENT:\n         case HTML:\n         case ATTRIBUTES:\n         case JS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/SoyElementPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/SoyElementPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/SoyElementPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/SoyElementPass.java\n@@ -109,8 +109,7 @@\n       // we can use it like a TemplateRegistry, but for templates in the immediate compilation unit.\n       for (TemplateNode template : file.getTemplates()) {\n         if (!(template instanceof TemplateDelegateNode)\n-            && (template.getContentKind() == SanitizedContentKind.HTML\n-                || template.getContentKind() == SanitizedContentKind.HTML_ELEMENT)) {\n+            && template.getContentKind() == SanitizedContentKind.HTML) {\n           templatesInLibrary.put(template.getTemplateName(), template);\n         } else {\n           template.setHtmlElementMetadata(DEFAULT_HTML_METADATA);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n@@ -352,7 +352,6 @@\n         break;\n       case ATTRIBUTES:\n       case CSS:\n-      case ELEMENT:\n       case HTML:\n       case URI:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n@@ -131,7 +131,6 @@\n       case FLOAT:\n         return CheckResult.fromBool(value instanceof FloatData);\n       case HTML:\n-      case ELEMENT:\n         return isSanitizedofKind(value, ContentKind.HTML);\n       case INT:\n         return CheckResult.fromBool(value instanceof IntegerData);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soyparse/HtmlRewriter.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n@@ -326,7 +326,6 @@\n         case ATTRIBUTES:\n           return BEFORE_ATTRIBUTE_NAME;\n         case HTML:\n-        case HTML_ELEMENT:\n           return PCDATA;\n           // You might be thinking that some of these should be RCDATA_STYLE or RCDATA_SCRIPT, but\n           // that wouldn't be accurate since rcdata is specific to the context of js on an html page\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TagName.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TagName.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TagName.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TagName.java\n@@ -209,9 +209,6 @@\n           .putAll(\"th\", \"td\", \"th\")\n           .build();\n \n-  private static final TemplateType ELEMENT_TEMPLATE =\n-      TemplateType.declaredTypeOf(ImmutableList.of(), SanitizedType.ElementType.getInstance());\n\n   private final StandaloneNode node;\n   @Nullable private final String nameAsLowerCase;\n   @Nullable private final RcDataTagName rcDataTagName;\n@@ -253,7 +250,12 @@\n \n   public boolean isTemplateCall() {\n     return !isStatic()\n-        && ELEMENT_TEMPLATE.isAssignableFrom(getDynamicTagName().getExpr().getType());\n+        && getDynamicTagName()\n+            .getExpr()\n+            .getType()\n+            .isAssignableFrom(\n+                TemplateType.declaredTypeOf(\n+                    ImmutableList.of(), SanitizedType.HtmlType.getInstance()));\n   }\n \n   public boolean isWildCard() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n@@ -35,7 +35,6 @@\n import com.google.template.soy.types.ProtoTypeRegistry;\n import com.google.template.soy.types.RecordType;\n import com.google.template.soy.types.SanitizedType;\n-import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SoyType;\n import com.google.template.soy.types.SoyType.Kind;\n import com.google.template.soy.types.SoyTypeRegistry;\n@@ -84,7 +83,6 @@\n \n   private static final ImmutableSet<Kind> ALLOWED_TEMPLATE_RETURN_TYPES =\n       Sets.immutableEnumSet(\n-          Kind.ELEMENT,\n           Kind.HTML,\n           Kind.ATTRIBUTES,\n           Kind.STRING,\n@@ -124,19 +122,6 @@\n             }\n           });\n \n-  private static final ImmutableMap<String, GenericTypeInfo> GENERIC_TYPES_WITH_ELEMENT =\n-      new ImmutableMap.Builder<String, GenericTypeInfo>()\n-          .putAll(GENERIC_TYPES)\n-          .put(\n-              \"html\",\n-              new GenericTypeInfo(1) {\n-                @Override\n-                SoyType create(List<SoyType> types, TypeInterner interner) {\n-                  return ElementType.getInstance();\n-                }\n-              })\n-          .build();\n\n   /** Simple representation of a generic type specification. */\n   private abstract static class GenericTypeInfo {\n     final int numParams;\n@@ -282,13 +267,9 @@\n \n   @Override\n   public SoyType visit(GenericTypeNode node) {\n-    return visit(node, GENERIC_TYPES);\n-  }\n\n-  private SoyType visit(GenericTypeNode node, ImmutableMap<String, GenericTypeInfo> genericTypes) {\n     ImmutableList<TypeNode> args = node.arguments();\n     String name = node.name();\n-    GenericTypeInfo genericType = genericTypes.get(name);\n+    GenericTypeInfo genericType = GENERIC_TYPES.get(name);\n     if (genericType == null) {\n       errorReporter.report(node.sourceLocation(), NOT_A_GENERIC_TYPE, name);\n       return UnknownType.getInstance();\n@@ -364,7 +345,7 @@\n         map.put(parameter.name(), oldParameter);\n       }\n     }\n-    SoyType returnType = handleReturnTypeOfTemplateType(node.returnType());\n+    SoyType returnType = node.returnType().accept(this);\n     // Validate return type.\n     if (!ALLOWED_TEMPLATE_RETURN_TYPES.contains(returnType.getKind())) {\n       errorReporter.report(node.returnType().sourceLocation(), INVALID_TEMPLATE_RETURN_TYPE);\n@@ -375,13 +356,6 @@\n     return type;\n   }\n \n-  private SoyType handleReturnTypeOfTemplateType(TypeNode node) {\n-    if (node instanceof GenericTypeNode) {\n-      return visit((GenericTypeNode) node, GENERIC_TYPES_WITH_ELEMENT);\n-    }\n-    return node.accept(this);\n-  }\n\n   @DoNotCall\n   @Override\n   public SoyType apply(TypeNode node) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SanitizedType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SanitizedType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SanitizedType.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SanitizedType.java\n@@ -49,9 +49,6 @@\n       case CSS:\n         return StyleType.getInstance();\n \n-      case HTML_ELEMENT:\n-        return ElementType.getInstance();\n\n       case HTML:\n         return HtmlType.getInstance();\n \n@@ -101,36 +98,6 @@\n       return INSTANCE;\n     }\n   }\n-  public static final class ElementType extends SanitizedType {\n-    private static final ElementType INSTANCE = new ElementType();\n\n-    private ElementType() {}\n\n-    @Override\n-    public Kind getKind() {\n-      return Kind.ELEMENT;\n-    }\n\n-    @Override\n-    public SanitizedContentKind getContentKind() {\n-      return SanitizedContentKind.HTML_ELEMENT;\n-    }\n\n-    @Override\n-    void doToProto(SoyTypeP.Builder builder) {\n-      builder.setPrimitive(SoyTypeP.PrimitiveTypeP.HTML);\n-    }\n\n-    public static ElementType getInstance() {\n-      return INSTANCE;\n-    }\n-  }\n \n   /** Type produced by templates whose kind is \"attributes\". */\n   public static final class AttributesType extends SanitizedType {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SoyType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SoyType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SoyType.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SoyType.java\n@@ -93,7 +93,6 @@\n     STRING,\n     // Sanitized types (subtypes of string)\n     HTML,\n-    ELEMENT,\n     ATTRIBUTES,\n     JS,\n     CSS,\n@@ -118,7 +117,6 @@\n         Sets.immutableEnumSet(\n             Kind.STRING,\n             Kind.HTML,\n-            Kind.ELEMENT,\n             Kind.ATTRIBUTES,\n             Kind.JS,\n             Kind.CSS,\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/TemplateType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/TemplateType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/TemplateType.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/TemplateType.java\n@@ -122,9 +122,7 @@\n         .setContentKind(contentKind)\n         // Declared HTML templates are implicitly strict. A separate check enforces that\n         // non-strict templates may not be bound in template literals.\n-        .setStrictHtml(\n-            contentKind == SanitizedContentKind.HTML\n-                || contentKind == SanitizedContentKind.HTML_ELEMENT)\n+        .setStrictHtml(contentKind == SanitizedContentKind.HTML)\n         .setParameters(ImmutableList.copyOf(parameters))\n         // data=all is banned on declared templates.\n         .setDataAllCallSituations(ImmutableList.of())\n@@ -163,7 +161,7 @@\n           }\n         }\n       }\n-      if (!this.getContentKind().isAssignableFrom(srcTemplate.getContentKind())) {\n+      if (!srcTemplate.getContentKind().equals(this.getContentKind())) {\n         return false;\n       }\n       return true;",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n@@ -39,6 +39,8 @@\n    * domain.\n    */\n   HTML,\n+  HTML_ELEMENT,\n \n   /**\n    * Executable Javascript code or expression, safe for insertion in a script-tag or event handler*/\n@@ -91,6 +93,11 @@\n     return attributeValue;\n   }\n \n+  public boolean isAssignableFrom(SanitizedContentKind sanitizedType) {\n+    return this == sanitizedType || (this == HTML && sanitizedType == HTML_ELEMENT);\n+  }\n\n   /** Returns the kind for the given attribute value. Or {@code null} if it is invalid. */\n   public static Optional<SanitizedContentKind> fromAttributeValue(String attributeValue) {\n     checkNotNull(attributeValue);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/TemplateContentKind.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n@@ -42,11 +42,11 @@\n    */\n   public static Optional<TemplateContentKind> fromAttributeValue(String attrValue) {\n     checkNotNull(attrValue);\n\n+    if (attrValue.equals(\"html<?>\")) {\n+      return Optional.of(ElementContentKind.ELEMENT);\n+    }\n     if (BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.containsKey(attrValue)) {\n       return Optional.of(BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.get(attrValue));\n-    } else if (attrValue.equals(\"html<?>\")) {\n-      return Optional.of(ElementContentKind.ELEMENT);\n     }\n     return Optional.empty();\n   }\n@@ -113,7 +113,7 @@\n \n     @Override\n     public SanitizedContentKind getSanitizedContentKind() {\n-      return SanitizedContentKind.HTML;\n+      return SanitizedContentKind.HTML_ELEMENT;\n     }\n   }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n@@ -45,6 +45,7 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_CTOR_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"goog.soy.data.SanitizedHtml\")\n+          .put(SanitizedContentKind.HTML_ELEMENT, \"goog.soy.data.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"goog.soy.data.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"goog.soy.data.SanitizedJs\")\n           .put(SanitizedContentKind.URI, \"goog.soy.data.SanitizedUri\")\n@@ -59,6 +60,7 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_ORDAINER_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n+          .put(SanitizedContentKind.HTML_ELEMENT, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"soydata.VERY_UNSAFE.ordainSanitizedJs\")\n           .put(SanitizedContentKind.URI, \"soydata.VERY_UNSAFE.ordainSanitizedUri\")\n@@ -81,6 +83,9 @@\n                   SanitizedContentKind.HTML,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n               .put(\n+                  SanitizedContentKind.HTML_ELEMENT,\n+                  \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n+              .put(\n                   SanitizedContentKind.ATTRIBUTES,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedAttributesForInternalBlocks\")\n               .put(\n@@ -116,6 +121,7 @@\n   /** The Python sanitized classes. */\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_PY_SANITIZED_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n+          .put(SanitizedContentKind.HTML_ELEMENT, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.HTML, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"sanitize.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"sanitize.SanitizedJs\")\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/SanitizedContent.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/SanitizedContent.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/SanitizedContent.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/SanitizedContent.java\n@@ -93,6 +93,9 @@\n      */\n     HTML,\n \n+    HTML_ELEMENT,\n\n     /**\n      * Executable Javascript code or expression, safe for insertion in a script-tag or event handler\n      * context, known to be free of any attacker-controlled scripts. This can either be*/\n@@ -152,6 +155,7 @@\n         case TRUSTED_RESOURCE_URI:\n           return Dir.LTR;\n         case HTML:\n+        case HTML_ELEMENT:\n         case TEXT:\n           return null;\n       }\n@@ -250,7 +254,7 @@\n    */\n   public SafeHtml toSafeHtml() {\n     Preconditions.checkState(\n-        getContentKind() == ContentKind.HTML,\n+        getContentKind() == ContentKind.HTML || getContentKind() == ContentKind.HTML_ELEMENT,\n         \"toSafeHtml() only valid for SanitizedContent of kind HTML, is: %s\",\n         getContentKind());\n     return UncheckedConversions.safeHtmlFromStringKnownToSatisfyTypeContract(getContent());\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n@@ -79,6 +79,7 @@\n       case STRING:\n         types = ImmutableList.of(SimpleJavaType.STRING);\n         break;\n+      case ELEMENT:\n       case HTML:\n         types = ImmutableList.of(SimpleJavaType.HTML);\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n@@ -99,6 +99,7 @@\n       return super.getTemplateFactory(name);\n     }\n     switch (contentKind) {\n+      case HTML_ELEMENT:\n       case HTML:\n         return new Factory<>(\n             contentKind, stubFactory.createHtmlTemplate(name), SafeHtml::getSafeHtmlString);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n@@ -72,6 +72,7 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n+      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\n@@ -147,6 +148,7 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n+      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsType.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsType.java\n@@ -283,6 +283,7 @@\n         }\n         // fall through\n       case HTML:\n+      case ELEMENT:\n         if (isIncrementalDom) {\n           // idom has a different strategy for handling these\n           return IDOM_HTML;\n@@ -486,6 +487,7 @@\n         return STRING_TYPE;\n       case ATTRIBUTES:\n       case CSS:\n+      case HTML_ELEMENT:\n       case HTML:\n       case JS:\n       case URI:\n@@ -641,6 +643,7 @@\n       case CSS:\n         builder.addType(\"!goog.html.SafeStyle\");\n         break;\n+      case HTML_ELEMENT:\n       case HTML:\n         builder.addType(\"!goog.html.SafeHtml\");\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n@@ -930,6 +930,7 @@\n     switch (contentKind) {\n       case CSS:\n         return state() == HtmlContext.CSS && elType() == ElementType.NONE;\n+      case HTML_ELEMENT:\n       case HTML:\n         return state() == HtmlContext.HTML_PCDATA && elType() == ElementType.NONE;\n       case ATTRIBUTES:\n@@ -1744,6 +1745,7 @@\n         case CSS:\n           withState(HtmlContext.CSS);\n           break;\n+        case HTML_ELEMENT:\n         case HTML:\n           withState(HtmlContext.HTML_PCDATA);\n           break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n@@ -111,6 +111,8 @@\n           }\n           node.arguments().get(0).accept(this);\n           break;\n+        case ELEMENT:\n+          break;\n         default:\n           throw new AssertionError(\"unexpected generic type: \" + node.getResolvedType().getKind());\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n@@ -422,7 +422,8 @@\n       if (callerTemplate.isStrictHtml()\n           && caller.getIsPcData()\n           && callee != null\n-          && callee.getContentKind() == SanitizedContentKind.HTML\n+          && (callee.getContentKind() == SanitizedContentKind.HTML\n+              || callee.getContentKind() == SanitizedContentKind.HTML_ELEMENT)\n           && !callee.isStrictHtml()) {\n         errorReporter.report(caller.getSourceLocation(), STRICT_HTML);\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/KeyCommandPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/KeyCommandPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/KeyCommandPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/KeyCommandPass.java\n@@ -145,6 +145,7 @@\n           break;\n         case BOOL:\n         case HTML:\n+        case ELEMENT:\n         case ATTRIBUTES:\n         case JS:\n         case CSS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n@@ -56,6 +56,7 @@\n import com.google.template.soy.types.SoyTypeRegistry;\n import com.google.template.soy.types.SoyTypeVisitor;\n import com.google.template.soy.types.SoyTypes;\n+import com.google.template.soy.types.StringType;\n import com.google.template.soy.types.TemplateBindingUtil;\n import com.google.template.soy.types.TemplateType;\n import com.google.template.soy.types.UnionType;\n@@ -203,7 +204,15 @@\n     Set<FunctionNode> correctlyPlaced = new HashSet<>();\n     for (HtmlTagNode tagNode :\n         SoyTreeUtils.getAllMatchingNodesOfType(\n-            file, HtmlTagNode.class, (tag) -> !tag.getTagName().isStatic())) {\n+            file,\n+            HtmlTagNode.class,\n+            (tag) ->\n+                !tag.getTagName().isStatic()\n+                    && tag.getTagName()\n+                        .getDynamicTagName()\n+                        .getExpr()\n+                        .getType()\n+                        .isAssignableFrom(StringType.getInstance()))) {\n       handleDynamicTag(tagNode, correctlyPlaced);\n     }\n     // No other uses of legacyDynamicTag are allowed.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n@@ -1796,6 +1796,7 @@\n         case CSS:\n         case JS:\n         case ATTRIBUTES:\n+        case ELEMENT:\n         case HTML:\n         case URI:\n           if (fieldName.equals(\"length\")) {\n@@ -1915,6 +1916,7 @@\n         case INT:\n         case FLOAT:\n         case STRING:\n+        case ELEMENT:\n         case HTML:\n         case ATTRIBUTES:\n         case JS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/SoyElementPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/SoyElementPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/SoyElementPass.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/SoyElementPass.java\n@@ -109,7 +109,8 @@\n       // we can use it like a TemplateRegistry, but for templates in the immediate compilation unit.\n       for (TemplateNode template : file.getTemplates()) {\n         if (!(template instanceof TemplateDelegateNode)\n-            && template.getContentKind() == SanitizedContentKind.HTML) {\n+            && (template.getContentKind() == SanitizedContentKind.HTML\n+                || template.getContentKind() == SanitizedContentKind.HTML_ELEMENT)) {\n           templatesInLibrary.put(template.getTemplateName(), template);\n         } else {\n           template.setHtmlElementMetadata(DEFAULT_HTML_METADATA);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n@@ -352,6 +352,7 @@\n         break;\n       case ATTRIBUTES:\n       case CSS:\n+      case ELEMENT:\n       case HTML:\n       case URI:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n@@ -131,6 +131,7 @@\n       case FLOAT:\n         return CheckResult.fromBool(value instanceof FloatData);\n       case HTML:\n+      case ELEMENT:\n         return isSanitizedofKind(value, ContentKind.HTML);\n       case INT:\n         return CheckResult.fromBool(value instanceof IntegerData);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soyparse/HtmlRewriter.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n@@ -326,6 +326,7 @@\n         case ATTRIBUTES:\n           return BEFORE_ATTRIBUTE_NAME;\n         case HTML:\n+        case HTML_ELEMENT:\n           return PCDATA;\n           // You might be thinking that some of these should be RCDATA_STYLE or RCDATA_SCRIPT, but\n           // that wouldn't be accurate since rcdata is specific to the context of js on an html page\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TagName.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TagName.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TagName.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TagName.java\n@@ -209,6 +209,9 @@\n           .putAll(\"th\", \"td\", \"th\")\n           .build();\n \n+  private static final TemplateType ELEMENT_TEMPLATE =\n+      TemplateType.declaredTypeOf(ImmutableList.of(), SanitizedType.ElementType.getInstance());\n\n   private final StandaloneNode node;\n   @Nullable private final String nameAsLowerCase;\n   @Nullable private final RcDataTagName rcDataTagName;\n@@ -250,12 +253,7 @@\n \n   public boolean isTemplateCall() {\n     return !isStatic()\n-        && getDynamicTagName()\n-            .getExpr()\n-            .getType()\n-            .isAssignableFrom(\n-                TemplateType.declaredTypeOf(\n-                    ImmutableList.of(), SanitizedType.HtmlType.getInstance()));\n+        && ELEMENT_TEMPLATE.isAssignableFrom(getDynamicTagName().getExpr().getType());\n   }\n \n   public boolean isWildCard() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n@@ -35,6 +35,7 @@\n import com.google.template.soy.types.ProtoTypeRegistry;\n import com.google.template.soy.types.RecordType;\n import com.google.template.soy.types.SanitizedType;\n+import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SoyType;\n import com.google.template.soy.types.SoyType.Kind;\n import com.google.template.soy.types.SoyTypeRegistry;\n@@ -83,6 +84,7 @@\n \n   private static final ImmutableSet<Kind> ALLOWED_TEMPLATE_RETURN_TYPES =\n       Sets.immutableEnumSet(\n+          Kind.ELEMENT,\n           Kind.HTML,\n           Kind.ATTRIBUTES,\n           Kind.STRING,\n@@ -122,6 +124,19 @@\n             }\n           });\n \n+  private static final ImmutableMap<String, GenericTypeInfo> GENERIC_TYPES_WITH_ELEMENT =\n+      new ImmutableMap.Builder<String, GenericTypeInfo>()\n+          .putAll(GENERIC_TYPES)\n+          .put(\n+              \"html\",\n+              new GenericTypeInfo(1) {\n+                @Override\n+                SoyType create(List<SoyType> types, TypeInterner interner) {\n+                  return ElementType.getInstance();\n+                }\n+              })\n+          .build();\n\n   /** Simple representation of a generic type specification. */\n   private abstract static class GenericTypeInfo {\n     final int numParams;\n@@ -267,9 +282,13 @@\n \n   @Override\n   public SoyType visit(GenericTypeNode node) {\n+    return visit(node, GENERIC_TYPES);\n+  }\n\n+  private SoyType visit(GenericTypeNode node, ImmutableMap<String, GenericTypeInfo> genericTypes) {\n     ImmutableList<TypeNode> args = node.arguments();\n     String name = node.name();\n-    GenericTypeInfo genericType = GENERIC_TYPES.get(name);\n+    GenericTypeInfo genericType = genericTypes.get(name);\n     if (genericType == null) {\n       errorReporter.report(node.sourceLocation(), NOT_A_GENERIC_TYPE, name);\n       return UnknownType.getInstance();\n@@ -345,7 +364,7 @@\n         map.put(parameter.name(), oldParameter);\n       }\n     }\n-    SoyType returnType = node.returnType().accept(this);\n+    SoyType returnType = handleReturnTypeOfTemplateType(node.returnType());\n     // Validate return type.\n     if (!ALLOWED_TEMPLATE_RETURN_TYPES.contains(returnType.getKind())) {\n       errorReporter.report(node.returnType().sourceLocation(), INVALID_TEMPLATE_RETURN_TYPE);\n@@ -356,6 +375,13 @@\n     return type;\n   }\n \n+  private SoyType handleReturnTypeOfTemplateType(TypeNode node) {\n+    if (node instanceof GenericTypeNode) {\n+      return visit((GenericTypeNode) node, GENERIC_TYPES_WITH_ELEMENT);\n+    }\n+    return node.accept(this);\n+  }\n\n   @DoNotCall\n   @Override\n   public SoyType apply(TypeNode node) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SanitizedType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SanitizedType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SanitizedType.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SanitizedType.java\n@@ -49,6 +49,9 @@\n       case CSS:\n         return StyleType.getInstance();\n \n+      case HTML_ELEMENT:\n+        return ElementType.getInstance();\n\n       case HTML:\n         return HtmlType.getInstance();\n \n@@ -98,6 +101,36 @@\n       return INSTANCE;\n     }\n   }\n\n+  public static final class ElementType extends SanitizedType {\n+    private static final ElementType INSTANCE = new ElementType();\n\n+    private ElementType() {}\n\n+    @Override\n+    public Kind getKind() {\n+      return Kind.ELEMENT;\n+    }\n\n+    @Override\n+    public SanitizedContentKind getContentKind() {\n+      return SanitizedContentKind.HTML_ELEMENT;\n+    }\n\n+    @Override\n+    void doToProto(SoyTypeP.Builder builder) {\n+      builder.setPrimitive(SoyTypeP.PrimitiveTypeP.HTML);\n+    }\n\n+    public static ElementType getInstance() {\n+      return INSTANCE;\n+    }\n+  }\n \n   /** Type produced by templates whose kind is \"attributes\". */\n   public static final class AttributesType extends SanitizedType {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SoyType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SoyType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SoyType.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SoyType.java\n@@ -93,6 +93,7 @@\n     STRING,\n     // Sanitized types (subtypes of string)\n     HTML,\n+    ELEMENT,\n     ATTRIBUTES,\n     JS,\n     CSS,\n@@ -117,6 +118,7 @@\n         Sets.immutableEnumSet(\n             Kind.STRING,\n             Kind.HTML,\n+            Kind.ELEMENT,\n             Kind.ATTRIBUTES,\n             Kind.JS,\n             Kind.CSS,\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TemplateType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TemplateType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TemplateType.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TemplateType.java\n@@ -122,7 +122,9 @@\n         .setContentKind(contentKind)\n         // Declared HTML templates are implicitly strict. A separate check enforces that\n         // non-strict templates may not be bound in template literals.\n-        .setStrictHtml(contentKind == SanitizedContentKind.HTML)\n+        .setStrictHtml(\n+            contentKind == SanitizedContentKind.HTML\n+                || contentKind == SanitizedContentKind.HTML_ELEMENT)\n         .setParameters(ImmutableList.copyOf(parameters))\n         // data=all is banned on declared templates.\n         .setDataAllCallSituations(ImmutableList.of())\n@@ -161,7 +163,7 @@\n           }\n         }\n       }\n-      if (!srcTemplate.getContentKind().equals(this.getContentKind())) {\n+      if (!this.getContentKind().isAssignableFrom(srcTemplate.getContentKind())) {\n         return false;\n       }\n       return true;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TypeRegistries.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TypeRegistries.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TypeRegistries.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TypeRegistries.java\n@@ -31,6 +31,7 @@\n import com.google.template.soy.error.SoyErrorKind;\n import com.google.template.soy.types.RecordType.Member;\n import com.google.template.soy.types.SanitizedType.AttributesType;\n+import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SanitizedType.HtmlType;\n import com.google.template.soy.types.SanitizedType.JsType;\n import com.google.template.soy.types.SanitizedType.StyleType;\n@@ -244,6 +245,7 @@\n             .put(\"number\", NUMBER_TYPE)\n             .put(\"html\", HtmlType.getInstance())\n             .put(\"attributes\", AttributesType.getInstance())\n+            .put(\"element\", ElementType.getInstance())\n             .put(\"css\", StyleType.getInstance())\n             .put(\"uri\", UriType.getInstance())\n             .put(\"trusted_resource_uri\", TrustedResourceUriType.getInstance())",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-93",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.google.template.soy.base.internal.SanitizedContentKindTest",
                "error": "com.google.common.truth.AssertionErrorWithFacts",
                "message": "value of      : attributeValues()\nunexpected (1): html_element\n---\nexpected      : [attributes, css, html, js, text, trusted_resource_uri, uri]\nbut was       : [attributes, css, html, html_element, js, text, trusted_resource_uri, uri]",
                "methodName": "testGetAttributeValues"
            },
            {
                "className": "com.google.template.soy.base.internal.TemplateContentKindTest",
                "error": "com.google.common.truth.ComparisonFailureWithFacts",
                "message": "value of: getSanitizedContentKind()\nexpected: HTML\nbut was : HTML_ELEMENT",
                "methodName": "testForAttributeValue_element"
            }
        ],
        "metrics": {
            "chunks": 49,
            "classes": 24,
            "files": 24,
            "linesAdd": 9,
            "linesMod": 11,
            "linesRem": 92,
            "methods": 35,
            "sizeInLines": 30
        },
        "program": "RegressionBug-93",
        "project": "RegressionBug-93",
        "repairOperators": [
            "rev"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\t2024-09-08 01:36:30.125920731 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\t2024-09-08 01:36:30.013919946 +1000\n@@ -39,8 +39,6 @@\n    * domain.\n    */\n   HTML,\n-  HTML_ELEMENT,\n \n   /**\n    * Executable Javascript code or expression, safe for insertion in a script-tag or event handler.*/\n@@ -93,11 +91,6 @@\n     return attributeValue;\n   }\n \n-  public boolean isAssignableFrom(SanitizedContentKind sanitizedType) {\n-    return this == sanitizedType || (this == HTML && sanitizedType == HTML_ELEMENT);\n-  }\n\n   /** Returns the kind for the given attribute value. Or {@code null} if it is invalid. */\n   public static Optional<SanitizedContentKind> fromAttributeValue(String attributeValue) {\n     checkNotNull(attributeValue);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/TemplateContentKind.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\t2024-09-08 01:36:30.125920731 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\t2024-09-08 01:36:30.013919946 +1000\n@@ -42,11 +42,11 @@\n    */\n   public static Optional<TemplateContentKind> fromAttributeValue(String attrValue) {\n     checkNotNull(attrValue);\n-    if (attrValue.equals(\"html<?>\")) {\n-      return Optional.of(ElementContentKind.ELEMENT);\n-    }\n\n     if (BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.containsKey(attrValue)) {\n       return Optional.of(BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.get(attrValue));\n+    } else if (attrValue.equals(\"html<?>\")) {\n+      return Optional.of(ElementContentKind.ELEMENT);\n     }\n     return Optional.empty();\n   }\n@@ -113,7 +113,7 @@\n \n     @Override\n     public SanitizedContentKind getSanitizedContentKind() {\n-      return SanitizedContentKind.HTML_ELEMENT;\n+      return SanitizedContentKind.HTML;\n     }\n   }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\t2024-09-08 01:36:30.129920758 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\t2024-09-08 01:36:30.017919974 +1000\n@@ -45,7 +45,6 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_CTOR_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"goog.soy.data.SanitizedHtml\")\n-          .put(SanitizedContentKind.HTML_ELEMENT, \"goog.soy.data.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"goog.soy.data.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"goog.soy.data.SanitizedJs\")\n           .put(SanitizedContentKind.URI, \"goog.soy.data.SanitizedUri\")\n@@ -60,7 +59,6 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_ORDAINER_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n-          .put(SanitizedContentKind.HTML_ELEMENT, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"soydata.VERY_UNSAFE.ordainSanitizedJs\")\n           .put(SanitizedContentKind.URI, \"soydata.VERY_UNSAFE.ordainSanitizedUri\")\n@@ -83,9 +81,6 @@\n                   SanitizedContentKind.HTML,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n               .put(\n-                  SanitizedContentKind.HTML_ELEMENT,\n-                  \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n-              .put(\n                   SanitizedContentKind.ATTRIBUTES,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedAttributesForInternalBlocks\")\n               .put(\n@@ -121,7 +116,6 @@\n   /** The Python sanitized classes. */\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_PY_SANITIZED_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n-          .put(SanitizedContentKind.HTML_ELEMENT, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.HTML, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"sanitize.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"sanitize.SanitizedJs\")\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/SanitizedContent.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/SanitizedContent.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/data/SanitizedContent.java\t2024-09-08 01:36:30.125920731 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/data/SanitizedContent.java\t2024-09-08 01:36:30.017919974 +1000\n@@ -93,9 +93,6 @@\n      */\n     HTML,\n \n-    HTML_ELEMENT,\n\n     /**\n      * Executable Javascript code or expression, safe for insertion in a script-tag or event handler\n      * context, known to be free of any attacker-controlled scripts. This can either be*/\n@@ -155,7 +152,6 @@\n         case TRUSTED_RESOURCE_URI:\n           return Dir.LTR;\n         case HTML:\n-        case HTML_ELEMENT:\n         case TEXT:\n           return null;\n       }\n@@ -254,7 +250,7 @@\n    */\n   public SafeHtml toSafeHtml() {\n     Preconditions.checkState(\n-        getContentKind() == ContentKind.HTML || getContentKind() == ContentKind.HTML_ELEMENT,\n+        getContentKind() == ContentKind.HTML,\n         \"toSafeHtml() only valid for SanitizedContent of kind HTML, is: %s\",\n         getContentKind());\n     return UncheckedConversions.safeHtmlFromStringKnownToSatisfyTypeContract(getContent());\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\t2024-09-08 01:36:30.129920758 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\t2024-09-08 01:36:30.025920030 +1000\n@@ -79,7 +79,6 @@\n       case STRING:\n         types = ImmutableList.of(SimpleJavaType.STRING);\n         break;\n-      case ELEMENT:\n       case HTML:\n         types = ImmutableList.of(SimpleJavaType.HTML);\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\t2024-09-08 01:36:30.133920786 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\t2024-09-08 01:36:30.025920030 +1000\n@@ -99,7 +99,6 @@\n       return super.getTemplateFactory(name);\n     }\n     switch (contentKind) {\n-      case HTML_ELEMENT:\n       case HTML:\n         return new Factory<>(\n             contentKind, stubFactory.createHtmlTemplate(name), SafeHtml::getSafeHtmlString);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\t2024-09-08 01:36:30.133920786 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\t2024-09-08 01:36:30.029920058 +1000\n@@ -72,7 +72,6 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n-      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\n@@ -148,7 +147,6 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n-      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/jssrc/internal/JsType.java\t2024-09-08 01:36:30.137920814 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/jssrc/internal/JsType.java\t2024-09-08 01:36:30.029920058 +1000\n@@ -283,7 +283,6 @@\n         }\n         // fall through\n       case HTML:\n-      case ELEMENT:\n         if (isIncrementalDom) {\n           // idom has a different strategy for handling these\n           return IDOM_HTML;\n@@ -487,7 +486,6 @@\n         return STRING_TYPE;\n       case ATTRIBUTES:\n       case CSS:\n-      case HTML_ELEMENT:\n       case HTML:\n       case JS:\n       case URI:\n@@ -643,7 +641,6 @@\n       case CSS:\n         builder.addType(\"!goog.html.SafeStyle\");\n         break;\n-      case HTML_ELEMENT:\n       case HTML:\n         builder.addType(\"!goog.html.SafeHtml\");\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\t2024-09-08 01:36:30.137920814 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\t2024-09-08 01:36:30.033920086 +1000\n@@ -930,7 +930,6 @@\n     switch (contentKind) {\n       case CSS:\n         return state() == HtmlContext.CSS && elType() == ElementType.NONE;\n-      case HTML_ELEMENT:\n       case HTML:\n         return state() == HtmlContext.HTML_PCDATA && elType() == ElementType.NONE;\n       case ATTRIBUTES:\n@@ -1745,7 +1744,6 @@\n         case CSS:\n           withState(HtmlContext.CSS);\n           break;\n-        case HTML_ELEMENT:\n         case HTML:\n           withState(HtmlContext.HTML_PCDATA);\n           break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\t2024-09-08 01:36:30.033920086 +1000\n@@ -111,8 +111,6 @@\n           }\n           node.arguments().get(0).accept(this);\n           break;\n-        case ELEMENT:\n-          break;\n         default:\n           throw new AssertionError(\"unexpected generic type: \" + node.getResolvedType().getKind());\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\t2024-09-08 01:36:30.033920086 +1000\n@@ -422,8 +422,7 @@\n       if (callerTemplate.isStrictHtml()\n           && caller.getIsPcData()\n           && callee != null\n-          && (callee.getContentKind() == SanitizedContentKind.HTML\n-              || callee.getContentKind() == SanitizedContentKind.HTML_ELEMENT)\n+          && callee.getContentKind() == SanitizedContentKind.HTML\n           && !callee.isStrictHtml()) {\n         errorReporter.report(caller.getSourceLocation(), STRICT_HTML);\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/KeyCommandPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/KeyCommandPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/KeyCommandPass.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/KeyCommandPass.java\t2024-09-08 01:36:30.037920114 +1000\n@@ -145,7 +145,6 @@\n           break;\n         case BOOL:\n         case HTML:\n-        case ELEMENT:\n         case ATTRIBUTES:\n         case JS:\n         case CSS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\t2024-09-08 01:36:30.037920114 +1000\n@@ -56,7 +56,6 @@\n import com.google.template.soy.types.SoyTypeRegistry;\n import com.google.template.soy.types.SoyTypeVisitor;\n import com.google.template.soy.types.SoyTypes;\n-import com.google.template.soy.types.StringType;\n import com.google.template.soy.types.TemplateBindingUtil;\n import com.google.template.soy.types.TemplateType;\n import com.google.template.soy.types.UnionType;\n@@ -204,15 +203,7 @@\n     Set<FunctionNode> correctlyPlaced = new HashSet<>();\n     for (HtmlTagNode tagNode :\n         SoyTreeUtils.getAllMatchingNodesOfType(\n-            file,\n-            HtmlTagNode.class,\n-            (tag) ->\n-                !tag.getTagName().isStatic()\n-                    && tag.getTagName()\n-                        .getDynamicTagName()\n-                        .getExpr()\n-                        .getType()\n-                        .isAssignableFrom(StringType.getInstance()))) {\n+            file, HtmlTagNode.class, (tag) -> !tag.getTagName().isStatic())) {\n       handleDynamicTag(tagNode, correctlyPlaced);\n     }\n     // No other uses of legacyDynamicTag are allowed.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\t2024-09-08 01:36:30.037920114 +1000\n@@ -1796,7 +1796,6 @@\n         case CSS:\n         case JS:\n         case ATTRIBUTES:\n-        case ELEMENT:\n         case HTML:\n         case URI:\n           if (fieldName.equals(\"length\")) {\n@@ -1916,7 +1915,6 @@\n         case INT:\n         case FLOAT:\n         case STRING:\n-        case ELEMENT:\n         case HTML:\n         case ATTRIBUTES:\n         case JS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/SoyElementPass.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/SoyElementPass.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/passes/SoyElementPass.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/passes/SoyElementPass.java\t2024-09-08 01:36:30.037920114 +1000\n@@ -109,8 +109,7 @@\n       // we can use it like a TemplateRegistry, but for templates in the immediate compilation unit.\n       for (TemplateNode template : file.getTemplates()) {\n         if (!(template instanceof TemplateDelegateNode)\n-            && (template.getContentKind() == SanitizedContentKind.HTML\n-                || template.getContentKind() == SanitizedContentKind.HTML_ELEMENT)) {\n+            && template.getContentKind() == SanitizedContentKind.HTML) {\n           templatesInLibrary.put(template.getTemplateName(), template);\n         } else {\n           template.setHtmlElementMetadata(DEFAULT_HTML_METADATA);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\t2024-09-08 01:36:30.141920843 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\t2024-09-08 01:36:30.037920114 +1000\n@@ -352,7 +352,6 @@\n         break;\n       case ATTRIBUTES:\n       case CSS:\n-      case ELEMENT:\n       case HTML:\n       case URI:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\t2024-09-08 01:36:30.145920870 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\t2024-09-08 01:36:30.041920142 +1000\n@@ -131,7 +131,6 @@\n       case FLOAT:\n         return CheckResult.fromBool(value instanceof FloatData);\n       case HTML:\n-      case ELEMENT:\n         return isSanitizedofKind(value, ContentKind.HTML);\n       case INT:\n         return CheckResult.fromBool(value instanceof IntegerData);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soyparse/HtmlRewriter.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\t2024-09-08 01:36:30.149920898 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\t2024-09-08 01:36:30.045920170 +1000\n@@ -326,7 +326,6 @@\n         case ATTRIBUTES:\n           return BEFORE_ATTRIBUTE_NAME;\n         case HTML:\n-        case HTML_ELEMENT:\n           return PCDATA;\n           // You might be thinking that some of these should be RCDATA_STYLE or RCDATA_SCRIPT, but\n           // that wouldn't be accurate since rcdata is specific to the context of js on an html page\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TagName.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TagName.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/soytree/TagName.java\t2024-09-08 01:36:30.149920898 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/soytree/TagName.java\t2024-09-08 01:36:30.049920198 +1000\n@@ -209,9 +209,6 @@\n           .putAll(\"th\", \"td\", \"th\")\n           .build();\n \n-  private static final TemplateType ELEMENT_TEMPLATE =\n-      TemplateType.declaredTypeOf(ImmutableList.of(), SanitizedType.ElementType.getInstance());\n-\n   private final StandaloneNode node;\n   @Nullable private final String nameAsLowerCase;\n   @Nullable private final RcDataTagName rcDataTagName;\n@@ -253,7 +250,12 @@\n \n   public boolean isTemplateCall() {\n     return !isStatic()\n-        && ELEMENT_TEMPLATE.isAssignableFrom(getDynamicTagName().getExpr().getType());\n+        && getDynamicTagName()\n+            .getExpr()\n+            .getType()\n+            .isAssignableFrom(\n+                TemplateType.declaredTypeOf(\n+                    ImmutableList.of(), SanitizedType.HtmlType.getInstance()));\n   }\n \n   public boolean isWildCard() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\t2024-09-08 01:36:30.153920926 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\t2024-09-08 01:36:30.049920198 +1000\n@@ -35,7 +35,6 @@\n import com.google.template.soy.types.ProtoTypeRegistry;\n import com.google.template.soy.types.RecordType;\n import com.google.template.soy.types.SanitizedType;\n-import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SoyType;\n import com.google.template.soy.types.SoyType.Kind;\n import com.google.template.soy.types.SoyTypeRegistry;\n@@ -84,7 +83,6 @@\n \n   private static final ImmutableSet<Kind> ALLOWED_TEMPLATE_RETURN_TYPES =\n       Sets.immutableEnumSet(\n-          Kind.ELEMENT,\n           Kind.HTML,\n           Kind.ATTRIBUTES,\n           Kind.STRING,\n@@ -124,19 +122,6 @@\n             }\n           });\n \n-  private static final ImmutableMap<String, GenericTypeInfo> GENERIC_TYPES_WITH_ELEMENT =\n-      new ImmutableMap.Builder<String, GenericTypeInfo>()\n-          .putAll(GENERIC_TYPES)\n-          .put(\n-              \"html\",\n-              new GenericTypeInfo(1) {\n-                @Override\n-                SoyType create(List<SoyType> types, TypeInterner interner) {\n-                  return ElementType.getInstance();\n-                }\n-              })\n-          .build();\n\n   /** Simple representation of a generic type specification. */\n   private abstract static class GenericTypeInfo {\n     final int numParams;\n@@ -282,13 +267,9 @@\n \n   @Override\n   public SoyType visit(GenericTypeNode node) {\n-    return visit(node, GENERIC_TYPES);\n-  }\n\n-  private SoyType visit(GenericTypeNode node, ImmutableMap<String, GenericTypeInfo> genericTypes) {\n     ImmutableList<TypeNode> args = node.arguments();\n     String name = node.name();\n-    GenericTypeInfo genericType = genericTypes.get(name);\n+    GenericTypeInfo genericType = GENERIC_TYPES.get(name);\n     if (genericType == null) {\n       errorReporter.report(node.sourceLocation(), NOT_A_GENERIC_TYPE, name);\n       return UnknownType.getInstance();\n@@ -364,7 +345,7 @@\n         map.put(parameter.name(), oldParameter);\n       }\n     }\n-    SoyType returnType = handleReturnTypeOfTemplateType(node.returnType());\n+    SoyType returnType = node.returnType().accept(this);\n     // Validate return type.\n     if (!ALLOWED_TEMPLATE_RETURN_TYPES.contains(returnType.getKind())) {\n       errorReporter.report(node.returnType().sourceLocation(), INVALID_TEMPLATE_RETURN_TYPE);\n@@ -375,13 +356,6 @@\n     return type;\n   }\n \n-  private SoyType handleReturnTypeOfTemplateType(TypeNode node) {\n-    if (node instanceof GenericTypeNode) {\n-      return visit((GenericTypeNode) node, GENERIC_TYPES_WITH_ELEMENT);\n-    }\n-    return node.accept(this);\n-  }\n\n   @DoNotCall\n   @Override\n   public SoyType apply(TypeNode node) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SanitizedType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SanitizedType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SanitizedType.java\t2024-09-08 01:36:30.153920926 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SanitizedType.java\t2024-09-08 01:36:30.049920198 +1000\n@@ -49,9 +49,6 @@\n       case CSS:\n         return StyleType.getInstance();\n \n-      case HTML_ELEMENT:\n-        return ElementType.getInstance();\n\n       case HTML:\n         return HtmlType.getInstance();\n \n@@ -101,36 +98,6 @@\n       return INSTANCE;\n     }\n   }\n\n-  public static final class ElementType extends SanitizedType {\n\n-    private static final ElementType INSTANCE = new ElementType();\n\n-    private ElementType() {}\n\n-    @Override\n-    public Kind getKind() {\n-      return Kind.ELEMENT;\n-    }\n\n-    @Override\n-    public SanitizedContentKind getContentKind() {\n-      return SanitizedContentKind.HTML_ELEMENT;\n-    }\n\n-    @Override\n-    void doToProto(SoyTypeP.Builder builder) {\n-      builder.setPrimitive(SoyTypeP.PrimitiveTypeP.HTML);\n-    }\n\n-    public static ElementType getInstance() {\n-      return INSTANCE;\n-    }\n-  }\n \n   /** Type produced by templates whose kind is \"attributes\". */\n   public static final class AttributesType extends SanitizedType {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SoyType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SoyType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/SoyType.java\t2024-09-08 01:36:30.153920926 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/SoyType.java\t2024-09-08 01:36:30.049920198 +1000\n@@ -93,7 +93,6 @@\n     STRING,\n     // Sanitized types (subtypes of string)\n     HTML,\n-    ELEMENT,\n     ATTRIBUTES,\n     JS,\n     CSS,\n@@ -118,7 +117,6 @@\n         Sets.immutableEnumSet(\n             Kind.STRING,\n             Kind.HTML,\n-            Kind.ELEMENT,\n             Kind.ATTRIBUTES,\n             Kind.JS,\n             Kind.CSS,\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/TemplateType.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/TemplateType.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/TemplateType.java\t2024-09-08 01:36:30.153920926 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/TemplateType.java\t2024-09-08 01:36:30.049920198 +1000\n@@ -122,9 +122,7 @@\n         .setContentKind(contentKind)\n         // Declared HTML templates are implicitly strict. A separate check enforces that\n         // non-strict templates may not be bound in template literals.\n-        .setStrictHtml(\n-            contentKind == SanitizedContentKind.HTML\n-                || contentKind == SanitizedContentKind.HTML_ELEMENT)\n+        .setStrictHtml(contentKind == SanitizedContentKind.HTML)\n         .setParameters(ImmutableList.copyOf(parameters))\n         // data=all is banned on declared templates.\n         .setDataAllCallSituations(ImmutableList.of())\n@@ -163,7 +161,7 @@\n           }\n         }\n       }\n-      if (!this.getContentKind().isAssignableFrom(srcTemplate.getContentKind())) {\n+      if (!srcTemplate.getContentKind().equals(this.getContentKind())) {\n         return false;\n       }\n       return true;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/TypeRegistries.java ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/TypeRegistries.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/java/src/com/google/template/soy/types/TypeRegistries.java\t2024-09-08 01:36:30.153920926 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BFC/java/src/com/google/template/soy/types/TypeRegistries.java\t2024-09-08 01:36:30.049920198 +1000\n@@ -31,7 +31,6 @@\n import com.google.template.soy.error.SoyErrorKind;\n import com.google.template.soy.types.RecordType.Member;\n import com.google.template.soy.types.SanitizedType.AttributesType;\n-import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SanitizedType.HtmlType;\n import com.google.template.soy.types.SanitizedType.JsType;\n import com.google.template.soy.types.SanitizedType.StyleType;\n@@ -245,7 +244,6 @@\n             .put(\"number\", NUMBER_TYPE)\n             .put(\"html\", HtmlType.getInstance())\n             .put(\"attributes\", AttributesType.getInstance())\n-            .put(\"element\", ElementType.getInstance())\n             .put(\"css\", StyleType.getInstance())\n             .put(\"uri\", UriType.getInstance())\n             .put(\"trusted_resource_uri\", TrustedResourceUriType.getInstance())",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\t2024-09-08 01:36:30.173921067 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/SanitizedContentKind.java\t2024-09-08 01:36:30.073920367 +1000\n@@ -39,6 +39,8 @@\n    * domain.\n    */\n   HTML,\n+  HTML_ELEMENT,\n \n   /**\n    * Executable Javascript code or expression, safe for insertion in a script-tag or event handler*/\n@@ -91,6 +93,11 @@\n     return attributeValue;\n   }\n \n+  public boolean isAssignableFrom(SanitizedContentKind sanitizedType) {\n+    return this == sanitizedType || (this == HTML && sanitizedType == HTML_ELEMENT);\n+  }\n\n   /** Returns the kind for the given attribute value. Or {@code null} if it is invalid. */\n   public static Optional<SanitizedContentKind> fromAttributeValue(String attributeValue) {\n     checkNotNull(attributeValue);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/TemplateContentKind.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\t2024-09-08 01:36:30.173921067 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/base/internal/TemplateContentKind.java\t2024-09-08 01:36:30.073920367 +1000\n@@ -42,11 +42,11 @@\n    */\n   public static Optional<TemplateContentKind> fromAttributeValue(String attrValue) {\n     checkNotNull(attrValue);\n\n+    if (attrValue.equals(\"html<?>\")) {\n+      return Optional.of(ElementContentKind.ELEMENT);\n+    }\n     if (BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.containsKey(attrValue)) {\n       return Optional.of(BasicTemplateContentKind.KINDS_BY_ATTR_VALUE.get(attrValue));\n-    } else if (attrValue.equals(\"html<?>\")) {\n-      return Optional.of(ElementContentKind.ELEMENT);\n     }\n     return Optional.empty();\n   }\n@@ -113,7 +113,7 @@\n \n     @Override\n     public SanitizedContentKind getSanitizedContentKind() {\n-      return SanitizedContentKind.HTML;\n+      return SanitizedContentKind.HTML_ELEMENT;\n     }\n   }\n \ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\t2024-09-08 01:36:30.177921094 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/internalutils/NodeContentKinds.java\t2024-09-08 01:36:30.077920394 +1000\n@@ -45,6 +45,7 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_CTOR_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"goog.soy.data.SanitizedHtml\")\n+          .put(SanitizedContentKind.HTML_ELEMENT, \"goog.soy.data.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"goog.soy.data.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"goog.soy.data.SanitizedJs\")\n           .put(SanitizedContentKind.URI, \"goog.soy.data.SanitizedUri\")\n@@ -59,6 +60,7 @@\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_JS_ORDAINER_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n           .put(SanitizedContentKind.HTML, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n+          .put(SanitizedContentKind.HTML_ELEMENT, \"soydata.VERY_UNSAFE.ordainSanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"soydata.VERY_UNSAFE.ordainSanitizedJs\")\n           .put(SanitizedContentKind.URI, \"soydata.VERY_UNSAFE.ordainSanitizedUri\")\n@@ -81,6 +83,9 @@\n                   SanitizedContentKind.HTML,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n               .put(\n+                  SanitizedContentKind.HTML_ELEMENT,\n+                  \"soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks\")\n+              .put(\n                   SanitizedContentKind.ATTRIBUTES,\n                   \"soydata.VERY_UNSAFE.$$ordainSanitizedAttributesForInternalBlocks\")\n               .put(\n@@ -116,6 +121,7 @@\n   /** The Python sanitized classes. */\n   private static final ImmutableMap<SanitizedContentKind, String> KIND_TO_PY_SANITIZED_NAME =\n       ImmutableMap.<SanitizedContentKind, String>builder()\n+          .put(SanitizedContentKind.HTML_ELEMENT, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.HTML, \"sanitize.SanitizedHtml\")\n           .put(SanitizedContentKind.ATTRIBUTES, \"sanitize.SanitizedHtmlAttribute\")\n           .put(SanitizedContentKind.JS, \"sanitize.SanitizedJs\")\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/SanitizedContent.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/SanitizedContent.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/data/SanitizedContent.java\t2024-09-08 01:36:30.177921094 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/data/SanitizedContent.java\t2024-09-08 01:36:30.077920394 +1000\n@@ -93,6 +93,9 @@\n      */\n     HTML,\n \n+    HTML_ELEMENT,\n\n     /**\n      * Executable Javascript code or expression, safe for insertion in a script-tag or event handler\n      * context, known to be free of any attacker-controlled scripts. This can either be\n@@ -152,6 +155,7 @@\n         case TRUSTED_RESOURCE_URI:\n           return Dir.LTR;\n         case HTML:\n+        case HTML_ELEMENT:\n         case TEXT:\n           return null;\n       }\n@@ -250,7 +254,7 @@\n    */\n   public SafeHtml toSafeHtml() {\n     Preconditions.checkState(\n-        getContentKind() == ContentKind.HTML,\n+        getContentKind() == ContentKind.HTML || getContentKind() == ContentKind.HTML_ELEMENT,\n         \"toSafeHtml() only valid for SanitizedContent of kind HTML, is: %s\",\n         getContentKind());\n     return UncheckedConversions.safeHtmlFromStringKnownToSatisfyTypeContract(getContent());\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\t2024-09-08 01:36:30.181921122 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/invocationbuilders/passes/InvocationBuilderTypeUtils.java\t2024-09-08 01:36:30.081920422 +1000\n@@ -79,6 +79,7 @@\n       case STRING:\n         types = ImmutableList.of(SimpleJavaType.STRING);\n         break;\n+      case ELEMENT:\n       case HTML:\n         types = ImmutableList.of(SimpleJavaType.HTML);\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\t2024-09-08 01:36:30.181921122 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/api/StubbingCompiledTemplates.java\t2024-09-08 01:36:30.085920450 +1000\n@@ -99,6 +99,7 @@\n       return super.getTemplateFactory(name);\n     }\n     switch (contentKind) {\n+      case HTML_ELEMENT:\n       case HTML:\n         return new Factory<>(\n             contentKind, stubFactory.createHtmlTemplate(name), SafeHtml::getSafeHtmlString);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\t2024-09-08 01:36:30.185921151 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jbcsrc/restricted/SoyRuntimeType.java\t2024-09-08 01:36:30.085920450 +1000\n@@ -72,6 +72,7 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n+      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\n@@ -147,6 +148,7 @@\n       case ATTRIBUTES:\n       case CSS:\n       case URI:\n+      case ELEMENT:\n       case HTML:\n       case JS:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/jssrc/internal/JsType.java\t2024-09-08 01:36:30.185921151 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/jssrc/internal/JsType.java\t2024-09-08 01:36:30.089920479 +1000\n@@ -283,6 +283,7 @@\n         }\n         // fall through\n       case HTML:\n+      case ELEMENT:\n         if (isIncrementalDom) {\n           // idom has a different strategy for handling these\n           return IDOM_HTML;\n@@ -486,6 +487,7 @@\n         return STRING_TYPE;\n       case ATTRIBUTES:\n       case CSS:\n+      case HTML_ELEMENT:\n       case HTML:\n       case JS:\n       case URI:\n@@ -641,6 +643,7 @@\n       case CSS:\n         builder.addType(\"!goog.html.SafeStyle\");\n         break;\n+      case HTML_ELEMENT:\n       case HTML:\n         builder.addType(\"!goog.html.SafeHtml\");\n         break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\t2024-09-08 01:36:30.189921179 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/parsepasses/contextautoesc/Context.java\t2024-09-08 01:36:30.089920479 +1000\n@@ -930,6 +930,7 @@\n     switch (contentKind) {\n       case CSS:\n         return state() == HtmlContext.CSS && elType() == ElementType.NONE;\n+      case HTML_ELEMENT:\n       case HTML:\n         return state() == HtmlContext.HTML_PCDATA && elType() == ElementType.NONE;\n       case ATTRIBUTES:\n@@ -1744,6 +1745,7 @@\n         case CSS:\n           withState(HtmlContext.CSS);\n           break;\n+        case HTML_ELEMENT:\n         case HTML:\n           withState(HtmlContext.HTML_PCDATA);\n           break;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\t2024-09-08 01:36:30.189921179 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckDeclaredTypesPass.java\t2024-09-08 01:36:30.089920479 +1000\n@@ -111,6 +111,8 @@\n           }\n           node.arguments().get(0).accept(this);\n           break;\n+        case ELEMENT:\n+          break;\n         default:\n           throw new AssertionError(\"unexpected generic type: \" + node.getResolvedType().getKind());\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\t2024-09-08 01:36:30.189921179 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/CheckTemplateCallsPass.java\t2024-09-08 01:36:30.089920479 +1000\n@@ -422,7 +422,8 @@\n       if (callerTemplate.isStrictHtml()\n           && caller.getIsPcData()\n           && callee != null\n-          && callee.getContentKind() == SanitizedContentKind.HTML\n+          && (callee.getContentKind() == SanitizedContentKind.HTML\n+              || callee.getContentKind() == SanitizedContentKind.HTML_ELEMENT)\n           && !callee.isStrictHtml()) {\n         errorReporter.report(caller.getSourceLocation(), STRICT_HTML);\n       }\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/KeyCommandPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/KeyCommandPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/KeyCommandPass.java\t2024-09-08 01:36:30.189921179 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/KeyCommandPass.java\t2024-09-08 01:36:30.093920506 +1000\n@@ -145,6 +145,7 @@\n           break;\n         case BOOL:\n         case HTML:\n+        case ELEMENT:\n         case ATTRIBUTES:\n         case JS:\n         case CSS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\t2024-09-08 01:36:30.189921179 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesCrossTemplatePass.java\t2024-09-08 01:36:30.093920506 +1000\n@@ -56,6 +56,7 @@\n import com.google.template.soy.types.SoyTypeRegistry;\n import com.google.template.soy.types.SoyTypeVisitor;\n import com.google.template.soy.types.SoyTypes;\n+import com.google.template.soy.types.StringType;\n import com.google.template.soy.types.TemplateBindingUtil;\n import com.google.template.soy.types.TemplateType;\n import com.google.template.soy.types.UnionType;\n@@ -203,7 +204,15 @@\n     Set<FunctionNode> correctlyPlaced = new HashSet<>();\n     for (HtmlTagNode tagNode :\n         SoyTreeUtils.getAllMatchingNodesOfType(\n-            file, HtmlTagNode.class, (tag) -> !tag.getTagName().isStatic())) {\n+            file,\n+            HtmlTagNode.class,\n+            (tag) ->\n+                !tag.getTagName().isStatic()\n+                    && tag.getTagName()\n+                        .getDynamicTagName()\n+                        .getExpr()\n+                        .getType()\n+                        .isAssignableFrom(StringType.getInstance()))) {\n       handleDynamicTag(tagNode, correctlyPlaced);\n     }\n     // No other uses of legacyDynamicTag are allowed.\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\t2024-09-08 01:36:30.189921179 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/ResolveExpressionTypesPass.java\t2024-09-08 01:36:30.093920506 +1000\n@@ -1796,6 +1796,7 @@\n         case CSS:\n         case JS:\n         case ATTRIBUTES:\n+        case ELEMENT:\n         case HTML:\n         case URI:\n           if (fieldName.equals(\"length\")) {\n@@ -1915,6 +1916,7 @@\n         case INT:\n         case FLOAT:\n         case STRING:\n+        case ELEMENT:\n         case HTML:\n         case ATTRIBUTES:\n         case JS:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/SoyElementPass.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/SoyElementPass.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/passes/SoyElementPass.java\t2024-09-08 01:36:30.193921206 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/passes/SoyElementPass.java\t2024-09-08 01:36:30.093920506 +1000\n@@ -109,7 +109,8 @@\n       // we can use it like a TemplateRegistry, but for templates in the immediate compilation unit.\n       for (TemplateNode template : file.getTemplates()) {\n         if (!(template instanceof TemplateDelegateNode)\n-            && template.getContentKind() == SanitizedContentKind.HTML) {\n+            && (template.getContentKind() == SanitizedContentKind.HTML\n+                || template.getContentKind() == SanitizedContentKind.HTML_ELEMENT)) {\n           templatesInLibrary.put(template.getTemplateName(), template);\n         } else {\n           template.setHtmlElementMetadata(DEFAULT_HTML_METADATA);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\t2024-09-08 01:36:30.193921206 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/plugin/java/internal/ValidatorFactory.java\t2024-09-08 01:36:30.093920506 +1000\n@@ -352,6 +352,7 @@\n         break;\n       case ATTRIBUTES:\n       case CSS:\n+      case ELEMENT:\n       case HTML:\n       case URI:\n       case TRUSTED_RESOURCE_URI:\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\t2024-09-08 01:36:30.197921234 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/sharedpasses/render/TofuTypeChecks.java\t2024-09-08 01:36:30.097920534 +1000\n@@ -131,6 +131,7 @@\n       case FLOAT:\n         return CheckResult.fromBool(value instanceof FloatData);\n       case HTML:\n+      case ELEMENT:\n         return isSanitizedofKind(value, ContentKind.HTML);\n       case INT:\n         return CheckResult.fromBool(value instanceof IntegerData);\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soyparse/HtmlRewriter.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\t2024-09-08 01:36:30.197921234 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soyparse/HtmlRewriter.java\t2024-09-08 01:36:30.097920534 +1000\n@@ -326,6 +326,7 @@\n         case ATTRIBUTES:\n           return BEFORE_ATTRIBUTE_NAME;\n         case HTML:\n+        case HTML_ELEMENT:\n           return PCDATA;\n           // You might be thinking that some of these should be RCDATA_STYLE or RCDATA_SCRIPT, but\n           // that wouldn't be accurate since rcdata is specific to the context of js on an html page\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TagName.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TagName.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/soytree/TagName.java\t2024-09-08 01:36:30.201921263 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/soytree/TagName.java\t2024-09-08 01:36:30.101920562 +1000\n@@ -209,6 +209,9 @@\n           .putAll(\"th\", \"td\", \"th\")\n           .build();\n \n+  private static final TemplateType ELEMENT_TEMPLATE =\n+      TemplateType.declaredTypeOf(ImmutableList.of(), SanitizedType.ElementType.getInstance());\n+\n   private final StandaloneNode node;\n   @Nullable private final String nameAsLowerCase;\n   @Nullable private final RcDataTagName rcDataTagName;\n@@ -250,12 +253,7 @@\n \n   public boolean isTemplateCall() {\n     return !isStatic()\n-        && getDynamicTagName()\n-            .getExpr()\n-            .getType()\n-            .isAssignableFrom(\n-                TemplateType.declaredTypeOf(\n-                    ImmutableList.of(), SanitizedType.HtmlType.getInstance()));\n+        && ELEMENT_TEMPLATE.isAssignableFrom(getDynamicTagName().getExpr().getType());\n   }\n \n   public boolean isWildCard() {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\t2024-09-08 01:36:30.201921263 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/ast/TypeNodeConverter.java\t2024-09-08 01:36:30.101920562 +1000\n@@ -35,6 +35,7 @@\n import com.google.template.soy.types.ProtoTypeRegistry;\n import com.google.template.soy.types.RecordType;\n import com.google.template.soy.types.SanitizedType;\n+import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SoyType;\n import com.google.template.soy.types.SoyType.Kind;\n import com.google.template.soy.types.SoyTypeRegistry;\n@@ -83,6 +84,7 @@\n \n   private static final ImmutableSet<Kind> ALLOWED_TEMPLATE_RETURN_TYPES =\n       Sets.immutableEnumSet(\n+          Kind.ELEMENT,\n           Kind.HTML,\n           Kind.ATTRIBUTES,\n           Kind.STRING,\n@@ -122,6 +124,19 @@\n             }\n           });\n \n+  private static final ImmutableMap<String, GenericTypeInfo> GENERIC_TYPES_WITH_ELEMENT =\n+      new ImmutableMap.Builder<String, GenericTypeInfo>()\n+          .putAll(GENERIC_TYPES)\n+          .put(\n+              \"html\",\n+              new GenericTypeInfo(1) {\n+                @Override\n+                SoyType create(List<SoyType> types, TypeInterner interner) {\n+                  return ElementType.getInstance();\n+                }\n+              })\n+          .build();\n\n   /** Simple representation of a generic type specification. */\n   private abstract static class GenericTypeInfo {\n     final int numParams;\n@@ -267,9 +282,13 @@\n \n   @Override\n   public SoyType visit(GenericTypeNode node) {\n+    return visit(node, GENERIC_TYPES);\n+  }\n\n+  private SoyType visit(GenericTypeNode node, ImmutableMap<String, GenericTypeInfo> genericTypes) {\n     ImmutableList<TypeNode> args = node.arguments();\n     String name = node.name();\n-    GenericTypeInfo genericType = GENERIC_TYPES.get(name);\n+    GenericTypeInfo genericType = genericTypes.get(name);\n     if (genericType == null) {\n       errorReporter.report(node.sourceLocation(), NOT_A_GENERIC_TYPE, name);\n       return UnknownType.getInstance();\n@@ -345,7 +364,7 @@\n         map.put(parameter.name(), oldParameter);\n       }\n     }\n-    SoyType returnType = node.returnType().accept(this);\n+    SoyType returnType = handleReturnTypeOfTemplateType(node.returnType());\n     // Validate return type.\n     if (!ALLOWED_TEMPLATE_RETURN_TYPES.contains(returnType.getKind())) {\n       errorReporter.report(node.returnType().sourceLocation(), INVALID_TEMPLATE_RETURN_TYPE);\n@@ -356,6 +375,13 @@\n     return type;\n   }\n \n+  private SoyType handleReturnTypeOfTemplateType(TypeNode node) {\n+    if (node instanceof GenericTypeNode) {\n+      return visit((GenericTypeNode) node, GENERIC_TYPES_WITH_ELEMENT);\n+    }\n+    return node.accept(this);\n+  }\n\n   @DoNotCall\n   @Override\n   public SoyType apply(TypeNode node) {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SanitizedType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SanitizedType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SanitizedType.java\t2024-09-08 01:36:30.201921263 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SanitizedType.java\t2024-09-08 01:36:30.101920562 +1000\n@@ -49,6 +49,9 @@\n       case CSS:\n         return StyleType.getInstance();\n \n+      case HTML_ELEMENT:\n+        return ElementType.getInstance();\n\n       case HTML:\n         return HtmlType.getInstance();\n \n@@ -98,6 +101,36 @@\n       return INSTANCE;\n     }\n   }\n\n+  public static final class ElementType extends SanitizedType {\n+    private static final ElementType INSTANCE = new ElementType();\n\n+    private ElementType() {}\n\n+    @Override\n+    public Kind getKind() {\n+      return Kind.ELEMENT;\n+    }\n\n+    @Override\n+    public SanitizedContentKind getContentKind() {\n+      return SanitizedContentKind.HTML_ELEMENT;\n+    }\n\n+    @Override\n+    void doToProto(SoyTypeP.Builder builder) {\n+      builder.setPrimitive(SoyTypeP.PrimitiveTypeP.HTML);\n+    }\n\n+    public static ElementType getInstance() {\n+      return INSTANCE;\n+    }\n+  }\n \n   /** Type produced by templates whose kind is \"attributes\". */\n   public static final class AttributesType extends SanitizedType {\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SoyType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SoyType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/SoyType.java\t2024-09-08 01:36:30.201921263 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/SoyType.java\t2024-09-08 01:36:30.101920562 +1000\n@@ -93,6 +93,7 @@\n     STRING,\n     // Sanitized types (subtypes of string)\n     HTML,\n+    ELEMENT,\n     ATTRIBUTES,\n     JS,\n     CSS,\n@@ -117,6 +118,7 @@\n         Sets.immutableEnumSet(\n             Kind.STRING,\n             Kind.HTML,\n+            Kind.ELEMENT,\n             Kind.ATTRIBUTES,\n             Kind.JS,\n             Kind.CSS,\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TemplateType.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TemplateType.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TemplateType.java\t2024-09-08 01:36:30.201921263 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TemplateType.java\t2024-09-08 01:36:30.101920562 +1000\n@@ -122,7 +122,9 @@\n         .setContentKind(contentKind)\n         // Declared HTML templates are implicitly strict. A separate check enforces that\n         // non-strict templates may not be bound in template literals.\n-        .setStrictHtml(contentKind == SanitizedContentKind.HTML)\n+        .setStrictHtml(\n+            contentKind == SanitizedContentKind.HTML\n+                || contentKind == SanitizedContentKind.HTML_ELEMENT)\n         .setParameters(ImmutableList.copyOf(parameters))\n         // data=all is banned on declared templates.\n         .setDataAllCallSituations(ImmutableList.of())\n@@ -161,7 +163,7 @@\n           }\n         }\n       }\n-      if (!srcTemplate.getContentKind().equals(this.getContentKind())) {\n+      if (!this.getContentKind().isAssignableFrom(srcTemplate.getContentKind())) {\n         return false;\n       }\n       return true;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TypeRegistries.java ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TypeRegistries.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/java/src/com/google/template/soy/types/TypeRegistries.java\t2024-09-08 01:36:30.201921263 +1000\n+++ ./RegMiner4APR-Regression-Bugs/BIC/java/src/com/google/template/soy/types/TypeRegistries.java\t2024-09-08 01:36:30.101920562 +1000\n@@ -31,6 +31,7 @@\n import com.google.template.soy.error.SoyErrorKind;\n import com.google.template.soy.types.RecordType.Member;\n import com.google.template.soy.types.SanitizedType.AttributesType;\n+import com.google.template.soy.types.SanitizedType.ElementType;\n import com.google.template.soy.types.SanitizedType.HtmlType;\n import com.google.template.soy.types.SanitizedType.JsType;\n import com.google.template.soy.types.SanitizedType.StyleType;\n@@ -244,6 +245,7 @@\n             .put(\"number\", NUMBER_TYPE)\n             .put(\"html\", HtmlType.getInstance())\n             .put(\"attributes\", AttributesType.getInstance())\n+            .put(\"element\", ElementType.getInstance())\n             .put(\"css\", StyleType.getInstance())\n             .put(\"uri\", UriType.getInstance())\n             .put(\"trusted_resource_uri\", TrustedResourceUriType.getInstance())",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-94",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.blade.mvc.handler.RequestInvokerTest",
                "error": "java.lang.IllegalStateException",
                "message": ": handle in com.blade.types.BladeWebHookType@6cc558c6",
                "methodName": "testRequestHandlerWebHook"
            }
        ],
        "metrics": {
            "chunks": 2,
            "classes": 1,
            "files": 1,
            "linesAdd": 7,
            "linesMod": 0,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 8
        },
        "program": "RegressionBug-94",
        "project": "RegressionBug-94",
        "repairOperators": [
            "condBranIfElseAdd",
            "assignAdd",
            "exThrowsAdd",
            "objInstAdd",
            "mcAdd"
        ],
        "repairTools": [],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/blade/mvc/handler/RequestInvoker.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/blade/mvc/handler/RequestInvoker.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/blade/mvc/handler/RequestInvoker.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/blade/mvc/handler/RequestInvoker.java\n@@ -2,6 +2,7 @@\n \n import com.blade.Blade;\n import com.blade.exception.BladeException;\n+import com.blade.exception.InternalErrorException;\n import com.blade.ioc.Ioc;\n import com.blade.kit.BladeKit;\n import com.blade.kit.ReflectKit;\n@@ -123,7 +124,13 @@\n \n         Object returnParam;\n         if (len > 0) {\n+            if (len == 1) {\n                 returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature);\n+            } else if (len == 2) {\n+                returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature.request(), routeSignature.response());\n+            } else {\n+                throw new InternalErrorException(\"Bad web hook structure\");\n+            }\n         } else {\n             returnParam = ReflectKit.invokeMethod(target, hookMethod);\n         }",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/blade/mvc/handler/RequestInvoker.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/blade/mvc/handler/RequestInvoker.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/blade/mvc/handler/RequestInvoker.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/blade/mvc/handler/RequestInvoker.java\n@@ -109,8 +109,8 @@\n      * @throws Exception throw like parse param exception\n      */\n     public boolean invokeHook(Signature routeSignature, Route hookRoute) throws Exception {\n-        Method actionMethod = hookRoute.getAction();\n-        Object target       = hookRoute.getTarget();\n+        Method hookMethod = hookRoute.getAction();\n+        Object target     = hookRoute.getTarget();\n         if (null == target) {\n             Class<?> clazz = hookRoute.getAction().getDeclaringClass();\n             target = ioc.getBean(clazz);\n@@ -118,20 +118,14 @@\n         }\n \n         // execute\n-        int len = actionMethod.getParameterTypes().length;\n-        actionMethod.setAccessible(true);\n+        int len = hookMethod.getParameterTypes().length;\n+        hookMethod.setAccessible(true);\n \n         Object returnParam;\n         if (len > 0) {\n-            Signature signature = Signature.builder().route(hookRoute)\n-                    .request(routeSignature.request()).response(routeSignature.response())\n-                    .parameters(routeSignature.getParameters())\n-                    .action(actionMethod).build();\n\n-            Object[] args = MethodArgument.getArgs(signature);\n-            returnParam = ReflectKit.invokeMethod(target, actionMethod, args);\n+            returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature);\n         } else {\n-            returnParam = ReflectKit.invokeMethod(target, actionMethod);\n+            returnParam = ReflectKit.invokeMethod(target, hookMethod);\n         }\n \n         if (null == returnParam) return true;\ndiff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/blade/mvc/hook/Signature.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/blade/mvc/hook/Signature.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/blade/mvc/hook/Signature.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/blade/mvc/hook/Signature.java\n@@ -43,12 +43,6 @@\n         this.route = route;\n         this.action = route.getAction();\n         if (null != this.action && !this.action.toString().contains(\"$$Lambda$\")) {\n-            this.initParameters();\n-        }\n-    }\n\n-    private void initParameters() throws Exception {\n-        if (null != this.action) {\n             this.parameters = MethodArgument.getArgs(this);\n         }\n     }",
        "bugType": "Local"
    },
    {
        "bugId": "RegressionBug-95",
        "changedFiles": {},
        "failingTests": [
            {
                "className": "com.alibaba.json.bvt.issue_3000.Issue3093",
                "error": "java.lang.ArrayIndexOutOfBoundsException",
                "message": ": 29",
                "methodName": "test_for_issue"
            }
        ],
        "metrics": {
            "chunks": 1,
            "classes": 1,
            "files": 1,
            "linesAdd": 0,
            "linesMod": 1,
            "linesRem": 0,
            "methods": 1,
            "sizeInLines": 1
        },
        "program": "RegressionBug-95",
        "project": "RegressionBug-95",
        "repairOperators": [
            "mcParValChange"
        ],
        "repairTools": [
            "rtRepairLLama"
        ],
        "bfcdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java\n--- ./RegMiner4APR-Regression-Bugs/BUGGY/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java\n+++ ./RegMiner4APR-Regression-Bugs/BFC/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java\n@@ -156,7 +156,7 @@\n             if (nanos > 0) {\n                 buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n                 int nanoSize = IOUtils.stringSize(nanos);\n-                IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);\n+                IOUtils.getChars(nanos, 29 - (9 - nanoSize), buf);\n                 IOUtils.getChars(second, 19, buf);\n                 IOUtils.getChars(minute, 16, buf);\n                 IOUtils.getChars(hour, 13, buf);",
        "bicdiff": "diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java\n--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java\n+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/alibaba/fastjson/serializer/DateCodec.java\n@@ -82,6 +82,12 @@\n                 return;\n             }\n         }\n\n+        int nanos = 0;\n+        if (clazz == java.sql.Timestamp.class) {\n+            java.sql.Timestamp ts = (java.sql.Timestamp) object;\n+            nanos = ts.getNanos();\n+        }\n         \n         Date date;\n         if (object instanceof Date) {\n@@ -147,7 +153,17 @@\n             int millis = calendar.get(Calendar.MILLISECOND);\n \n             char[] buf;\n-            if (millis != 0) {\n+            if (nanos > 0) {\n+                buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n+                int nanoSize = IOUtils.stringSize(nanos);\n+                IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);\n+                IOUtils.getChars(second, 19, buf);\n+                IOUtils.getChars(minute, 16, buf);\n+                IOUtils.getChars(hour, 13, buf);\n+                IOUtils.getChars(day, 10, buf);\n+                IOUtils.getChars(month, 7, buf);\n+                IOUtils.getChars(year, 4, buf);\n+            } else if (millis != 0) {\n                 buf = \"0000-00-00T00:00:00.000\".toCharArray();\n                 IOUtils.getChars(millis, 23, buf);\n                 IOUtils.getChars(second, 19, buf);\n@@ -175,6 +191,10 @@\n             }\n             \n             out.write(buf);\n+            if (nanos > 0) { // java.sql.Timestamp\n+                out.write(quote);\n+                return;\n+            }\n \n             float timeZoneF = calendar.getTimeZone().getOffset(calendar.getTimeInMillis()) / (3600.0f * 1000);\n             int timeZone = (int)timeZoneF;",
        "bugType": "Local"
    }
]